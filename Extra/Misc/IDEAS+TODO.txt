§ TODOs ------------------------------------

    󰤱  Documentation (oh gosh people are finding the project now)
    󰤱  Angle of complex number
    󰤱  option for operator to ignore superscripts like →
    󰤱  __setminus__, __crossprod__, __union__, __intersection__, __subset__ ; mutex
    󰤱  bootstrap everything
    󰤱  normalize binds/stuff for edits/cross-plat
        󰤱 SCRIPT_MAP hardcoded in moonvert rn
    󰤱  regex but better
    󰤱  add the edge cases for the new compose ops
    󰤱  Ponder shape ⥊ operator
    󰤱  Better ☾
    󰤱  proper cli for generating font
    󰤱  side-invarient unary doesn't work ⓦ implicit multiplication
    󰤱  eval bar: 󷺄x󰄎2󰄎3⁞, 󷺄x󰄎⬤󰄎⬤⁞
    󰤱  implicit imports are jank
    󰤱􊽨 Web/phone-app maker
    󰤱􊽨  option to print progress
    󰤱􊽨 Make x⭜y⭝z store vals
    󰤱􊽨 Star versions of: 󰈲󰈳󰒼󰒽
    󰤱􊽨 Font generator slow

§ CoolCharBank™ ------------------------------------

    ꝛᴥ
    󷸟󷸝󷸞 󷸣󷸤󷸥 󷸠󷸡󷸢 󷸦⍜⍥󷸧
    ⌾✪🅭⚆⍟⦾⦿⏣
    ⧿ 󰹳  ⧟ 󱗘
    󷹾 󷺀 󷹽 󷹿 󷹥 󷹧 󰇘 󷹦 󰘣 󰝔 󰡏 󰘡 󷹠 󰘞 󷹟 󰘟 󷹡 󰘠 󰩀 󰨾 󰨿
    󰅳⌘ℿ⩇⌢⌣⏜⏝≬𝄞⦁⦂⦇⦈⦉⦊⨾⩤⩥϶⛯
    󱣬󰈴 󰨑󱓝 󰇙
    󰕖 󰆍󰸇󰉉󰄷󰄶󰈝󰈔󰈕󰴜󰏢󰈋󰋋󰈸󰥓
    󰩹󰩺 󰔛󱫭󱫟󱫍 󱎫󱫤󱫞󱫦 󱫌 󰔟
    󰣡󰣢󰣣󰣤󰣥󰣦󰣧 󰫃󰫄󰫅󰫆󰫇󰫈 󰯁󰯂󰯃 🮦 🮧
    ⏶⏷⏴⏵▲▼▶◀🞁🞃🞀🞂▴▾◂▸▵▿◃▹◢◣◤◥◸◹◺◿ ⎔⬡
    𝛬󰎦󰎩󰎬󰎮󰎰󰎵󰎸󰎻󰎾󰎣
    󰅊󰱗󰆏󰆒󱉬󱉧󰅇󰅌󱓥
    󰅲 󰅪 󰅩 󰅴     
    𝼋 ⥾ 𖣂 󰙨 ⹔ 󱗘 󱕛    
    ᚢᚣᚤᚥ ᛥᛝᛞᛜ
    ᚵᚡ ᚦᚧ ᛒᛔ ᚷᚸᛤ ᛖᛗ ᚺᚻ ᛕᚱ
    ᛄᚼᛡᛀᚽᛂ ᚶᛙᛍ ᛌᛧᛁ
    ᚿᛆᚾᛅᚭᚮᚬᚯ ᚴᛮᚳᚠᚨᚩᚪᚫᚰᛓ
    ᛚᛐᛛᛑ ᛸᛣᛦ ᛉᛠᛘᛯ ᛨᛏᛎ
    ᚹᛩᛇᛢᛈᚲᛊᛋᛪᛶᛵᛳᛟᛃᛴᛲ᛬᛫
    ᕻᓐᓒᔥᣛ ᔇᔅᔉᔊᓪᣗᕐᔾᖮ ᣜᣝᓫᕑᣞᣟᐝ ᗮᐪ󰂅ᓑᣕᐡᐢ ᐤᐞᐠᑊᘁᣔ
§ OverPowered STUFF [f,⬤,g,√🍊] ------------------------------------
    
    ␛a 󱖔⁺􍮡􋄎􍯏² ␛b
    
    f○[1,2,0] = f(𝔸₁,𝔸₂,𝔸₀)
    f○[1,2,*,0] = f(𝔸₁,𝔸₂,⠤𝔸₃﹕,𝔸₀)
    
    Signatures􊽨:
        (    f    {󰬩,󰬫,󱖚,󱖘,⍥,○}􋀐    g    )(⠤𝔸🃌=m)
        (    f    {󰬩,󰬫,󱖚,󱖘,⍥,○}􋀐[g₀,g₁,…])(⠤𝔸🃌=m)
        ([f₀,f₁,…]{󰬩,󰬫,󱖚,󱖘,⍥,○}􋀐    g    )(⠤𝔸🃌=m)
        ([f₀,f₁,…]{󰬩,󰬫,󱖚,󱖘,⍥,○}􋀐[g₀,g₁,…])(⠤𝔸🃌=m)

     ¿(<⋅>)ⁿ each g gets n args, where do the extra arguments go?
     ᴍO⟦:_<>AD⟧ ⟶ ⍥⍜󰬫󰬩󱖚󱖘
     󰬩󰬫󱖚󱖘○⍜⍥⊙⚆⌾⍟⌽⊸⟜
    
     󰬫/󰬩:
        default is 𝗙(y)⭜s=2⭝s=1
         g takes 2 arguments, as many times as possible (or once for each function in list), and puts excess to the right(󰬫)/left(󰬩)

        {󰬩,󰬫} = {󰬩,󰬫}⁺,{󰬩,󰬫}⁻: distribute

        f 󰬫² g  (𝟘,𝟙,𝟚) = f(g(𝟘,𝟙),𝟚)
        f 󰬫􍧱 g  (𝟘,𝟙,𝟚) = f(g(𝟙,𝟚),𝟘)
        f 󰬩² g  (𝟘,𝟙,𝟚) = f(𝟘,g(𝟙,𝟚))
        f 󰬩􍧱 g  (𝟘,𝟙,𝟚) = f(𝟚,g(𝟘,𝟙))

        f 󰬫² [g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟙),h(𝟚,𝟛),𝟜)
        f 󰬫􍧱 [g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟙,𝟚),h(𝟛,𝟜),𝟘)
        f 󰬩² [g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(𝟘,g(𝟙,𝟚),h(𝟛,𝟜))
        f 󰬩􍧱 [g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(𝟜,g(𝟘,𝟙),h(𝟚,𝟛))
        
         󷹇 if it was just g instead of [g,h] it would just have all g's

         what about underflow? fill in as much as possible, keep empty args still.
        f 󰬩⁰ g (𝟘) = f(𝟘, g())
        f 󰬫⁰ g (𝟘) = f(g(), 𝟘)
        f {󰬫,󰬩}􋀐􋁎􊽭¹ g  (𝟘) = f(𝟘)
        f {󰬩,󰬫}􊽭¹   g  (𝟘) = f(g(𝟘))
        
        f 󰬫⁰ [g,h] (𝟘)   = f(g(),h(),𝟘)
        f 󰬩⁰ [g,h] (𝟘)   = f(𝟘,g(),h())
        
        f 󰬫¹ [g,h] (𝟘)   = f(g(𝟘),h())
        f 󰬫􍨅 [g,h] (𝟘)   = f(g(),h(𝟘))
        f 󰬩¹ [g,h] (𝟘)   = f(g(𝟘),h())
        f 󰬩􍨅 [g,h] (𝟘)   = f(g(),h(𝟘))
        
        f 󰬫² [g,h] (𝟘,𝟙)   = f(g(𝟘,𝟙),h())
        f 󰬫􍧱 [g,h] (𝟘,𝟙)   = f(g(),h(𝟘,𝟙))
        f 󰬩² [g,h] (𝟘,𝟙)   = f(g(𝟘,𝟙),h())
        f 󰬩􍧱 [g,h] (𝟘,𝟙)   = f(g(),h(𝟘,𝟙))
        f 󰬫² [g,h] (𝟘,𝟙,𝟚) = f(g(𝟘,𝟙),h(𝟚))
        f 󰬫􍧱 [g,h] (𝟘,𝟙,𝟚) = f(g(𝟘),h(𝟙,𝟚))
        f 󰬩² [g,h] (𝟘,𝟙,𝟚) = f(g(𝟘,𝟙),h(𝟚))
        f 󰬩􍧱 [g,h] (𝟘,𝟙,𝟚) = f(g(𝟘),h(𝟙,𝟚))
    
     ○/⍜
        󷹇 concat = 𝑖○+´○²ᔐ
        
        f ○¹ g = f ○ g = f(g(⠤𝔸))
        
        󷹇 part_R is the one that may be small
        󷹇 FT{L,R} = fill towards left/right
        f ○² g  (⠤𝔸) = f(g(part_L       ),g(part_R    FTR))
        f ○􍧱 g  (⠤𝔸) = f(g(part_L       ),g(FTL    part_R))
        f ⍜² g  (⠤𝔸) = f(g(part_L    FTR),g(       part_R))
        f ⍜􍧱 g  (⠤𝔸) = f(g(FTL    part_L),g(       part_R))
        
        f ○􋀐 [g]   (⠤𝔸)          = f(g(⠤𝔸))
        f ○² [g]   (𝟘,𝟙)         = f(g(𝟘,𝟙))
        f ○¹ [g,h] (𝟘,𝟙)         = f(g(𝟘),h(𝟙))
        f ○² [g,h] (𝟘,𝟙,𝟚,𝟛,𝟜)   = f(g(𝟘,𝟙,𝟜),h(𝟚,𝟛,𝟜))
        f ○² [g,h] (𝟘,𝟙,𝟚,𝟛,𝟜,𝟝) = f(g(𝟘,𝟙,𝟜,𝟝),h(𝟚,𝟛,𝟜,𝟝))
        
        
        
        f ○􋔛 [g,h] (𝟘,𝟙,𝟚,𝟛,𝟜,𝟝) = f(g(𝟘,𝟙,𝟜,𝟝),h(𝟚,𝟛,𝟜,𝟝))
        f○³[g,h]   (𝟘,𝟙)     ≟ f(g(𝟘,𝟘,𝟘),h(𝟙,𝟙,𝟙))
        f○³[g,h]   (𝟘,𝟙,𝟚,𝟛) ≟ f(g(𝟘,𝟙,𝟚),h(𝟛,𝟙,𝟚))
        f○􍧟[g,h]   (𝟘,𝟙,𝟚,𝟛) ≟ f(g(𝟘,𝟙,𝟚),h(𝟘,𝟙,𝟛))
        f○³[g,h,i] (𝟘,𝟙,𝟚,𝟛) ≟ f(g(𝟘,𝟙,𝟚),h(𝟛,𝟙,𝟚),i(𝟛,𝟙,𝟚))
        
        f○¹g (𝟘,𝟙,𝟚,𝟛) = f(g(𝟘,𝟙,𝟚,𝟛))
        
        f○³[g,h,i] (𝟘,𝟙,𝟚,𝟛) = f(g(𝟘),h(𝟙),i(𝟚))
        
        f○³[g,h,i] (𝟘,𝟙,𝟚,𝟛) = f(g(𝟘,𝟙,𝟚),h(𝟛),i())
        f󰬫³[g,h,i] (𝟘,𝟙,𝟚,𝟛) = f(g(𝟘,𝟙,𝟚),h(𝟛),i())
        f○􍧟[g,h,i] (𝟘,𝟙,𝟚,𝟛) = f(g(),h(𝟘),i(𝟙,𝟚,𝟛))
        f󰬩³[g,h,i] (𝟘,𝟙,𝟚,𝟛) = f(g(),h(𝟘),i(𝟙,𝟚,𝟛))
        f○􋔛[g,h,i] (⠤𝔸)      = f(g(⠤𝔸),h(),i())
        f○􍰓[g,h,i] (⠤𝔸)      = f(g(),h(),i(⠤𝔸))
        
        f○¹[g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟚,𝟛,𝟜),h(𝟙,𝟚,𝟛,𝟜))
        f○􍨅[g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟙,𝟚,𝟛),h(𝟘,𝟙,𝟚,𝟜))
        
        f○²[g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟙,𝟜),h(𝟚,𝟛,𝟜))

        f󰬫²[g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟙),h(𝟚,𝟛),𝟜)
        f󰬩²[g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(𝟜,g(𝟘,𝟙),h(𝟚,𝟛))
        f󰬩􍧱[g,h] (𝟘,𝟙,𝟚,𝟛,𝟜) = f(𝟘,g(𝟙,𝟚),h(𝟛,𝟜))
        f○􍧱g     (𝟘,𝟙,𝟚,𝟛,𝟜) ≟ f(g(𝟘,𝟙,𝟚),g(𝟛,𝟜,𝟚))
        f○􍧱g     (𝟘,𝟙,𝟚,𝟛,𝟜) ≟ f(g(𝟘,𝟙,𝟚),g(𝟘,𝟛,𝟜))
        f○􍧱g     (𝟘,𝟙,𝟚,𝟛,𝟜) ≟ f(g(𝟙,𝟚,𝟘),g(𝟛,𝟜,𝟘))
        f○􍧟g     (𝟘,𝟙,𝟚,𝟛,𝟜) ≟ f(g(𝟘,𝟙),g(𝟚,𝟛),g(𝟜,𝟙))
        
        f○²g     (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟙,𝟜),g(𝟚,𝟛,𝟜))
        f󰬫²g     (𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟙),g(𝟚,𝟛),𝟜)
        f󰬩²g     (𝟘,𝟙,𝟚,𝟛,𝟜) = f(𝟜,g(𝟘,𝟙),g(𝟚,𝟛))
        f󰬩􍧱g     (𝟘,𝟙,𝟚,𝟛,𝟜) = f(𝟘,g(𝟙,𝟚),g(𝟛,𝟜)) ¿ maybe reverse ±
        
        (f ? [g,h])(𝟘,𝟙,𝟚,𝟛) = f(g(𝟘,𝟙),h(𝟚,𝟛))
        (f ? [g,h])(𝟘,𝟙,𝟚,𝟛,𝟜,𝟝) = f(g(𝟘,𝟙,𝟚),h(𝟛,𝟜,𝟝))
        
        f󰬩²g = f(g(𝟘, 𝟙), 𝟚)
        f󰬫²g = f(𝟘, g(𝟙, 𝟚))

        f󰬩²[g,h] (𝟘,…,𝟜) = f(g(𝟘,𝟙), g(𝟚,𝟛), 𝟜)
        f󰬫²[g,h] (𝟘,…,𝟜) = f(𝟘, g(𝟙, 𝟚))

        (f○¹g) = f(g(⠤𝔸))
        (f○􋔛g) = f(⠤𝔸ᴍg)
        f○²g←(𝟘)           = f(g(𝟘    ), g(𝟘    ))
        f○²g←(𝟘,𝟙)         = f(g(𝟘    ), g(𝟙    ))
        f○²g←(𝟘,𝟙,𝟚)       = f(g(𝟘,𝟚  ), g(𝟙,𝟚  ))
        f○²g←(𝟘,𝟙,𝟚,𝟛)     = f(g(𝟘,𝟙  ), g(𝟚,𝟛  ))
        f○²g←(𝟘,𝟙,𝟚,𝟛,𝟜)   = f(g(𝟘,𝟙,𝟜), g(𝟚,𝟛,𝟜))
        f○²g←(𝟘,𝟙,𝟚,𝟛,𝟜,𝟝) = f(g(𝟘,𝟙,𝟚), g(𝟛,𝟜,𝟝))

        f○³g←(𝟘)             = f(g(𝟘    ), g(𝟘    ), g(𝟘    ))
        f○³g←(𝟘,𝟙)           = f(g(𝟘,𝟙  ), g(𝟘,𝟙  ), g(𝟘,𝟙  ))
        f○³g←(𝟘,𝟙,𝟚)         = f(g(𝟘    ), g(𝟙    ), g(𝟚    ))
        f○³g←(𝟘,𝟙,𝟚,𝟛)       = f(g(𝟘,𝟛  ), g(𝟙,𝟛  ), g(𝟚,𝟛  ))
        f○³g←(𝟘,𝟙,𝟚,𝟛,𝟜)     = f(g(𝟘,𝟛,𝟜), g(𝟙,𝟛,𝟜), g(𝟚,𝟛,𝟜))
        f○³g←(𝟘,𝟙,𝟚,𝟛,𝟜,𝟝)   = f(g(𝟘,𝟙  ), g(𝟚,𝟛  ), g(𝟜,𝟝  ))
        f○³g←(𝟘,𝟙,𝟚,𝟛,𝟜,𝟝,𝟞) = f(g(𝟘,𝟙,𝟞), g(𝟚,𝟛,𝟞), g(𝟜,𝟝,𝟞))

        f○⁴g←(𝟘)         = f(g(𝟘    ), g(𝟘    ), g(𝟘    ), g(𝟘    ))
        f○⁴g←(𝟘,𝟙)       = f(g(𝟘,𝟙  ), g(𝟘,𝟙  ), g(𝟘,𝟙  ), g(𝟘,𝟙  ))
        f○⁴g←(𝟘,𝟙,𝟚)     = f(g(𝟘,𝟙,𝟚), g(𝟘,𝟙,𝟚), g(𝟘,𝟙,𝟚), g(𝟘,𝟙,𝟚))
        f○⁴g←(𝟘,𝟙,𝟚,𝟛)   = f(g(𝟘    ), g(𝟙    ), g(𝟚    ), g(𝟛    ))
        f○⁴g←(𝟘,𝟙,𝟚,𝟛,𝟜) = f(g(𝟘,𝟜  ), g(𝟙,𝟜  ), g(𝟚,𝟜  ), g(𝟛,𝟜  ))

        (f○¹g) = f(g(⠤𝔸))
        (f○􋔛g) = f(⠤𝔸ᴍg)

        f○¹g⋄h = f(g(h(⠤𝔸)))
        f○􋔛g⋄h = f(⠤𝔸ᴍg○h)
        f○²g⋄h = f(g(𝟘),h(𝟙))
        f○³g⋄h = f(g(𝟘,𝟙),h(𝟘,𝟙))
        f○⁴g⋄h = f(g(𝟘,𝟙),h(𝟚,𝟛))

    󱖚/󱖘 (♺):
         @OPWRAP_
         ⊢ op´(x=␀, y=␀, s=1):  by ♺
              where x⫢LHS, y⫢RHS, s=superscript
             ↪ result
        choices:
            start adding arguments from outside vs inside
            n describes num of args on all but inside vs outside
        f󱖘ⁿg (𝟘,𝟙,𝟚,𝟛) = f(g(g(n_itms),n-1_itms),rest_itms)
        f󱖘[g,h] (𝟘,𝟙,𝟚,𝟛) = f(g(𝟙,𝟚,𝟛),𝟘)
        f󱖘[g,h] (𝟘,𝟙,𝟚,𝟛) = f(g(h(𝟚,𝟛),𝟙),𝟘)
        f󱖘ⁿ[g,h  ] (𝟘,𝟙,𝟚,𝟛,𝟜,𝟝,𝟞) = f(g(h(rest_itms),n_itms),n_itms)
        f󱖘ⁿ[g,h,i] (𝟘,𝟙,𝟚,𝟛,𝟜,𝟝,𝟞) = f(g(h(i(rest_itms), n_itms), n_itms), n_itms)

        (󱖘¹ops)(l) ; l↨ ſ 󰲣opsₓ􊬤(x₀,y)

        f󱖚g (𝟘,𝟙,𝟚) = f(g(𝟘,𝟙),𝟚)
        f󱖘g (𝟘,𝟙,𝟚) = f(𝟘,g(𝟙,𝟚))

§ Regex STUFF ------------------------------------

    $ ^ ? | + * [^-] ( ) {,} \
        ¿ ∨ ⨁ ⨀ ⁅⌐…⁆ ⟨ ⟩ ⟮…⟯ ␐ ⮞ ← → 𝘀 𝘁 𝘄 𝗻 𝗪

    We remove space/tabs/newlines automatically

    ⟨stuff⭣󰮈⟩        removes this match
    ⟨stuff⭣ƒ⟩        applies ƒ to this match
    ⟨stuff⭣"a⟨0⟩b"⟩  applies replacement
    ⟨␛h⭡stuff⟩       match named ␛h
    ⟨⭡stuff⟩         match named 0 (increments every "⟨⭡…⟩")
    ⟨␛h⭡stuff⭣ƒ⟩     applies ƒ to this match named ␛h

    𝔯   @s does str match?
    𝔯   %s apply match-functions and repack into string
    𝔯   ÷s ℵ: match_names↦ordered_matches
    𝔯   ⋅s match
    𝔯􊯛ₕ ⋅s list of matches named ␛h
    𝔯₀󰄎₃⋅s zipmatch [[r₀􊬣,r₃􊬣], [r₀􊬤,r₃􊬤], …]
    𝔯  ⋅s match (w/o nesting, i.e. [a,[b,c]] becomes [[a,b,c],[b,c]])

    𝔯 = ⟨ ⟨␛m⭡mul(⟨⁅0…9⁆⨁⭣𝑖⟩, ⟨⁅0…9⁆⨁⭣𝑖⟩)⟩ ∨ do() ∨ don't() ⟩
    𝔯⋅‹mul(5,2) do() mul(2,8) don't()›
    = [(‹m›, [5, 2]), ‹do()›, (‹m›, [5, 2]), ‹don't()›]

§ Better Syntax STUFF ------------------------------------

    x⇒⟦  just find matching
        in_block
    in_block
    ⟧ out_block

     Δ=𝘀⋅4 happens here:
    ¿x: in_block
        in_block
        j = ‹some
        abc
        ›  j ≡ ‹some𝗻abc𝗻› ; trick doesn't apply to magic 󰦥
        in_block
       out_block
       
     Δ=𝘀⋅1 happens here:
    ¿x:
     in_block
     in_block
     in_block
    out_block

    𝑓 = 󷺄x󰄎y󰄎z↦w,[h,i],v↦[w,x]⁞ ⟦h+=1 ; h+=2 ; h ⟧ ֎ rets h ֎
    𝑓 = 󷺄x󰄎y󰄎z↦w,[h,i],v↦[w,x]⁞ ⟦
        h+=1 ; h+2 ⟧ ֎ rets h+2 ֎
    𝑓 = 󷺄x󰄎y󰄎z↦w,[h,i],v↦[w,x]⁞
        h+=1
        h+2
    ֎ rets h+2 ֎

§ What if ☾ was fast? ------------------------------------

    Actual AST tree
    Target llvm?
        exec/eval would be impossible/inefficent but that's ok
    
    Internal types:
        ᔐ: [graphemes: 𝑖]
        𝑖{1,2,4,8,16,32,64,128,256,∞}
        ℵ
        ƒ?
    
    Typing is implicit, regenerate functions/code snippets  
        ƒ = x↦x²
        X = ƒ(5)
          = ƒ(5 ⫢ ©,𝑖64)
            ƒ(𝑖64) = (𝑖64)⁽􋇖⁶⁴⁾
                   = (𝑖64).__sup__(𝑖64)
                   = 𝑖64
            ∴ ƒ:𝑖64→𝑖64
            (𝑖64).__sup__(𝑖64)
             ¯¯¯↖primitive¯¯¯↖primitive
            ∴ llvm.powi.i64.i64
            5,2⫢© ∴ llvm.powi.i64.i64(5,2)
                  ∴ llvm will auto reduce this for us
                  ∴ final expression would be like
                        SETLOCAL(id(X), 25⫢𝑖64)
            
            
            
            (ᐹx).__sup__(2) 󷹇 2ᐹ𝑖
        ƒ = x⫢𝑖64 ↦ resolve((𝑖64).__sup__, (𝑖64))
                
        󱀘 𝑖:
            __sup__ = 󰲣POW_INT_INT 