parse_ot = ó°»¾ î¬¦ ó°¤±

OP_TIERS = "ó·°œó·°ó·°ó·°Ÿó·° ó·°¡ó·°¢ó·°£ó·°¤ó·°¥ó·°¦ó·°§ó·°¨ó·°©ó·°ªó·°«ó·°¬ó·°­ó·°®ó·°¯ó·°°ó·°±"
OPS = ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥
ó·°§ +    ğš¡ó·¸ôŠ½¨ğš¢
ó·°§ -    ğš¡ó·¸ôŠ½¨ğš¢
ó·°­ â‹…    ğš¡âˆ§ôŠ½¨ğš¢
ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥

OPS = (OPSâ¬„ğ˜€ğ—»ó·¹ğ—»áµâ¬„ğ˜€ğ—»ğŒ‚ó·º¹â‰¡ğ˜€â­œó°®ˆâ­âœ“)â›
      êŸ¿ó°²¥OP_TIERSó°‘…á”¨x, y, parse_ot(z)ó°…‚
OPSâ˜¾
exitî®¦

î¬¦ 
î¬¦ l, âŸ¨;âŸ©, r
î¬¦ 

_OP_TYPES = "NPSB"
_or  = ó°²£x | 1âª¡_OP_TYPES.index(y)
_and = ó°²£x & 1âª¡_OP_TYPES.index(y)
ó±€˜ OP:
    __slots__ = [â ¤"tvFLRf"]
    
    âŠ¢ __init__(ğ•Š, t, v=á¦, L=â–¡, R=â–¡, f=print):
        v, F = ğ‘ (vó°ˆ³ó°²¡xâˆˆ_OP_TYPES), ğ‘ (vó°ˆ³ó°²¡xâˆ‰_OP_TYPES)
        ğ•Šáµ—, ğ•Šáµ›, ğ•Šó°€… = t, vÅ¿â°|Â´, F
        ğ•Šá´¸, ğ•Šá´¿, ğ•Šá¶  = Lâˆ¨ğ‘ (), Râˆ¨ğ‘ (), f
    âŠ¢ __contains__(ğ•Š,v): â†ª vâˆˆğ•Šó°€…
    âŠ¢ __repr__(ğ•Š): â†ª â€¹âŸ¨âŸ¦ğ•Šáµ—âŸ§â”‚âŸ¦bin(ğ•Šáµ›)â‚‚ï¹•.zfill(_OP_TYPESğŸƒŒ)ï¹•ï¹•ô¨„âŸ§âŸ¦(ğ•Šó°€…â­œâ›â”‚+á”(ğ•Šó°€…)â­á¦) + â›âŸ©âŸ§â€º
    âŠ¢ __eq__(ğ•Š, n):
        O = L, base, R = ğ•Š.is_op(n)
        â†ª base.as_txt()â‰¡ğ•Š.t â­œOâ­ âœ—
    âŠ¢ __call__(ğ•Š, L, R, op_):
        ğ•Š.check_args(L, R) â¨³ â€¹Invalid args for op!â€º
        â†ª ğ•Š.f(L, R, op_)
    âŠ¢ __getattr__(ğ•Š, a):
        Â¿aâ‰¡â›M: â†ª ğ•Šá´¾âˆ§ğ•Šó°€’
        Â¿aáµâˆˆ_OP_TYPESá¸â‹€:
            â†ª ğ•Šáµ›â›¶ô‹•Ÿá´¼á´¾ô‹•Ÿáµ€ó°€˜á´¾á´±ó°€’ô‹Œµáµâˆ§á‘ˆa â†’ â‹
        raise AttributeError
    
    copy = â¥Œğ•Š  â†¦(á¹ğ•Š)(ğ•Šáµ—, ğ•Šáµ›, ğ•Šá´¸.copy(), ğ•Šá´¿.copy(), ğ•Šá¶ )
    mod  = â¥Œğ•Š,vâ†¦(á¹ğ•Š)(ğ•Šáµ—, v, ğ•Šá´¸, ğ•Šá´¿, ğ•Šá¶ )
    
    @ğ’â„³
    âŠ¢ TND(â„‚, s, l=á¦, r=á¦):
        â†ª Åƒ("oper", ("oper_mod_l", l), ("oper_lit", s), ("oper_mod_r", r))
    
    @ğ’â„³
    âŠ¢ is_op(â„‚, n, ops=â–¡):
        Â¿nó·¹µNode âˆ¨ náµ—â‰ "oper": â†ªâœ—
        
        L, base, R = O = n.C
        base = base.as_txt()
        
        Â¿Ró°€’ âˆ§ â›Â´âˆˆR.as_txt(): â†ª âœ—
        â†ª L, base, R
    
    âŠ¢ check_args(ğ•Š, L=â–¡, R=â–¡):
        l, r = Lâ‰‡â–¡, Râ‰‡â–¡
        Â¿lâˆ§r: â†ª ğ•Šá´®
        Â¿lâˆ¨r: â†ª ğ•Šá´¾âˆ§R âˆ¨ Lâˆ§ğ•Šó°€’
        â†ª ğ•Šá´º
    
    âŠ¢ part(ğ•Š, nodes, d, op_man):
        dâˆˆ"lr" â¨³
        
        i = 0
        Â¿dâ‰¡â›r: î¬¦ ó·¹‡ this code is scary!!1
            stack = [ğ•Šá´¿]
            âˆ€i,n in nodesâ†¨:
                Â¿ğ•Š.is_op(n)â‰•OÂ¬: â†º
                l, op_t, r = O
                â°stack:
                    pretend_op = op_t
                    Â¿â›â‰º âˆˆ l.as_txt():
                        pretend_op = â›á´ î¬¦ ó·¹‡ stupid
                    Â¿pretend_op âˆˆ stackô¨„:
                        stack ó·¸Š+ [op_manâ‚™á´¿]
                        â‡¥
                    
                    î¬¦ ó·¹‡ weird
                    Â¿ (ğ•Šá´¾ âˆ¨ (ğ•Šá´® âˆ§ Â¬ğ•Šó°€’)) â›
                          âˆ§ op_manâ‚™áµ— âˆˆ op_man.tableôŠ¯›ôŠ±µá´¿ â›
                          âˆ§ op_manâ‚™á´¾ âˆ§ iâ‰¡0:
                        stack ó·¸Š+ [op_manâ‚™á´¿]
                        â‡¥
                    stack.pop()
                Â¡:
                    â‡¥
            Â¡:
                i ó·¸Š+ 1
        â¸˜dâ‰¡â›l:
            âˆ€i,n âˆˆ nodesâ†¨ï¹•ï¹•ô¨„:
                Â¿ğ•Š.is_op(n)â‰•OÂ¬: â†º
                l, op_t, r = O
                Â¿op_t âˆ‰ ğ•Šá´¸: â‡¥
        â†ª nodesï¹•áµ¢, nodesáµ¢ï¹•
        
    âŠ¢ apply(ğ•Š, L, R, op_man, op_):
        î¬¦ â€¹âŸ¦L=âŸ§ âŸ¦op_=âŸ§ âŸ¦R=âŸ§â€ºâ˜¾
        ll, lr = ğ•Š.part(L, â›l, op_man)
        rl, rr = ğ•Š.part(R, â›r, op_man)
        î¬¦ â€¹ll=âŸ¦llâŸ§â€ºâ˜¾
        î¬¦ â€¹lr=âŸ¦lrâŸ§â€ºâ˜¾
        î¬¦ â˜¾(ğ•Š)
        î¬¦ â€¹rl=âŸ¦rlâŸ§â€ºâ˜¾
        î¬¦ â€¹rr=âŸ¦rrâŸ§â€ºâ˜¾
        
        Â¿rl: rl = op_man.parse_expr(rl)
        
        Â¿ğ•Šá´® âˆ§ lr âˆ§ rl: â†ª ll + [ğ•Š(lr, rl, op_)], rr î¬¦ Binary
        Â¿ğ•Šó°€’ âˆ§ lr     : â†ª ll + [ğ•Š(lr,  â–¡, op_)], R  î¬¦ Suffix
        Â¿ğ•Šá´¾      âˆ§ rl: â†ª L  + [ğ•Š(â–¡ , rl, op_)], rr î¬¦ Prefix
        Â¿ğ•Šá´º          : â†ª L  + [ğ•Š(â–¡ ,  â–¡, op_)], R  î¬¦ Nullary
        
        âœ—â¨³â€¹"Unable to apply operator âŸ¦ğ•ŠâŸ§: âŸ¦ll=âŸ§; âŸ¦lr=âŸ§; âŸ¦rl=âŸ§; âŸ¦rr=âŸ§â€º

ó±€˜ OP_Manager:
    __slots__ = "table", 

    âŠ¢ __init__(ğ•Š, table):
        ğ•Š.table = table
    âŠ¢ __repr__(ğ•Š):
        â†ª â€¹âŸ¦(á¹ğ•Š).__name__âŸ§[table=âŸ¦ğ•Š.tableâŸ§]â€º
    âŠ¢ __getitem__(ğ•Š, n):
        Â¿Â¬nâ‰”OP.is_op(n): â†ª
        L, op_t, R = n
        op = ğ•Š.tableó°‚¼â‚šô‹•â‚œ
        â†ª ğ•Š.gen_op(L, op, R)
    
    âŠ¢ gen_op(ğ•Š, l, op, r):
        láµ—â‰¡"oper_mod_l" â¨³
        âˆ€uâˆˆl.as_txt():
            Â¿uâ‰¡â›âŸ¥:
                opá´® â¨³
                op = op.mod(opá´ºâ‹…â›N + â›P)
            â¸˜uâ‰¡â›â‰º:
                opá´® â¨³
                op = op.mod(opá´ºâ‹…â›N + â›S)
            Â¡:
                âœ—â¨³
        
        Â¿ráµ—â‰ "oper_mod_r": â†ª op
        
        âˆ€uâˆˆr.as_txt():
            Â¿uâ‰¡â›êœ :
                opá´® â¨³
                op = op.mod(opá´ºâ‹…â›N + â›Pâ›S)
            â¸˜uâ‰¡â›áµœ:
                Â¿opá´¾ âˆ¨ opó°€’:
                    op = op.mod(opá´ºâ‹…â›N + opá´¾â‹…â›S + opó°€’â‹…â›P + opá´®â‹…â›B, opá´¿, opá´¸)
            â¸˜uâ‰¡â›âŸ¤:
                opá´® â¨³
                op = op.mod(opá´ºâ‹…â›N + â›S)
            î¬¦ ó·¹‡ postfix modifiers can be dynamic
        â†ª op
    
    âŠ¢ parse_expr(ğ•Š, n):
        î¬¦ print("parse_expr:")
        î¬¦ âˆ€xâˆˆn: x.print()
        î¬¦ PD(1, "PARSE", n)
        L, R = [], n.copy()
        â°R:
            c = R.pop(0)
            î¬¦ PD(0, f"STACKS: {L=} â”‚{c}â”‚ {R=}")
            Â¿OP.is_op(c): L, R = ğ•Šî .apply(L, R, ğ•Š, c)
            Â¡           : L ó·¸Š+ [c]
        î¬¦ PD(-1, L+R)
        â†ª L + R