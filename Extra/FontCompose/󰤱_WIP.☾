SCRIPT_EXIST = 󰦥󰦥󰦥󰦥󰦥
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,<>;+-*=()[]{}~?&$%:!
ₐₑₕᵢⱼₖₗₘₙ󰂼ₚᵣₛₜᵤᵥₓ󰂓󰂔󰂕󰂖󰂗󰂘󰂙󰂚󰂛󰂜󰂝󰂞󰂟󰂠󰂡󰂢󰂣󰂤󰂥󰂦󰂧󰂨󰂩󰂪󰂫󰂬₀₁₂₃₄₅₆₇₈₉󰄎󰄟󰄞󰄏₊₋₌₍₎󰄗󰄘󰄕󰄖˷﹖﹠﹩﹪﹕◌
ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻᴬᴮ󰀂ᴰᴱ󰀅ᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾ󰀐ᴿ󰀒ᵀᵁⱽᵂ󰀗󰀘󰀙⁰¹²³⁴⁵⁶⁷⁸⁹󰁱󰂂󰂁󰁲⁺⁻⁼⁽⁾󰁺󰁻󰁸󰁹˜◌◌◌◌◌ꜝ 󰦥󰦥󰦥󰦥󰦥

DAT = ␛
󰦥󰦥󰦥󰦥󰦥

¡alpha  ⟦abcdefghijklmnopqrstuvwxyz⟧
¡ALPHA  ⟦ABCDEFGHIJKLMNOPQRSTUVWXYZ⟧
¡number ⟦0123456789                ⟧
¡letter ⟦⟨@alpha⟩⟨@ALPHA⟩          ⟧
¡letnum ⟦⟨@letter⟩⟨@number⟩        ⟧
¡greek ⦑c⦑A00⦒⦒ ⟦
  ⁅⟦⁅_s⁆⁅0⟦-ᐦv⟧⁆ab⁅d⟦egpᐦ⟧⁆⁅e⟦ᐦt⟧⁆⁅f⟦ei⟧⁆⁅Fi⁆⁅io⁆⟧𝕊 ⟶
      ς    Θθϑ  αβ   δ∇∂Δ     εη     φϕ    Φ   ι  ⁆
  ⁅⟦kl⁅mu⁆⁅p⟦ᐦs⟧⁆⁅P⟦ᐦs⟧⁆⁅rh⁆sSt⁅up⁆vwW⁅x⟦iᐦ⟧⁆yYzZ⟧𝕊 ⟶
    κλ  μ    πΨ     Πψ    ρ σΣτ  υ νωΩ   Ξχ  γΓζξ ⁆
⟧

¡lngeek ⟦⟨@letnum⟩⁅ᴍ⟨@greek⟩⁆⟧

¡dstruk q⟨@letnum⟩ ⟶ 𝔸𝔹ℂ𝔻𝔼𝔽𝔾ℍ𝕀𝕁𝕂𝕃𝕄ℕ𝕆ℙℚℝ𝕊𝕋𝕌𝕍𝕎𝕏𝕐ℤ𝕒𝕓𝕔𝕕𝕖𝕗𝕘𝕙𝕚𝕛𝕜𝕝𝕞𝕟𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡

w⟦
  ¡bold       b⟨@lngeek⟩ ⦑c⦑ff9dc6⦒⦒ 󰅁𝐚𝐛𝐜𝐝𝐞𝐟𝐠𝐡𝐢𝐣𝐤𝐥𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐭𝐮𝐯𝐰𝐱𝐲𝐳𝐀𝐁𝐂𝐃𝐄𝐅𝐆𝐇𝐈𝐉𝐊𝐋𝐌𝐍𝐎𝐏𝐐𝐑𝐒𝐓𝐔𝐕𝐖𝐗𝐘𝐙𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗𝞁𝝝𝝷𝞋𝝰𝝱𝝳𝝯𝞉𝝙𝝴𝝶𝞅𝝫𝞍𝝸𝝹𝝺𝝻𝝿𝞇𝝥𝝭𝞀𝞂𝝨𝞃𝞄𝝼𝞈𝝮𝝣𝞆𝝲𝝘𝝵𝝽 󰅂
  ¡ital       i⟨@lngeek⟩ ⦑c⦑f6b845⦒⦒ 󰅁𝑎𝑏𝑐𝑑𝑒𝑓𝑔ℎ𝑖𝑗𝑘𝑙𝑚𝑛𝑜𝑝𝑞𝑟𝑠𝑡𝑢𝑣𝑤𝑥𝑦𝑧𝐴𝐵𝐶𝐷𝐸𝐹𝐺𝐻𝐼𝐽𝐾𝐿𝑀𝑁𝑂𝑃𝑄𝑅𝑆𝑇𝑈𝑉𝑊𝑋𝑌𝑍◌◌◌◌◌◌◌◌◌◌𝝇𝜣𝜽𝝑𝜶𝜷𝜹𝜵𝝏𝜟𝜺𝜼𝝋𝜱𝝓𝜾𝜿𝝀𝝁𝝅𝝍𝜫𝜳𝝆𝝈𝜮𝝉𝝊𝝂𝝎𝜴𝜩𝝌𝜸𝜞𝜻𝝃 󰅂
  ¡math,bold  s⟨@letnum⟩ ⦑ ⦒ ⟶ 𝗮𝗯𝗰𝗱𝗲𝗳𝗴𝗵𝗶𝗷𝗸𝗹𝗺𝗻𝗼𝗽𝗾𝗿𝘀𝘁𝘂𝘃𝘄𝘅𝘆𝘇𝗔𝗕𝗖𝗗𝗘𝗙𝗚𝗛𝗜𝗝𝗞𝗟𝗠𝗡𝗢𝗣𝗤𝗥𝗦𝗧𝗨𝗩𝗪𝗫𝗬𝗭𝟬𝟭𝟮𝟯𝟰𝟱𝟲𝟳𝟴𝟵
  ¡frak       f⟨@letnum⟩ ⦑ ⦒ ⟶ 𝔞𝔟𝔠𝔡𝔢𝔣𝔤𝔥𝔦𝔧𝔨𝔩𝔪𝔫𝔬𝔭𝔮𝔯𝔰𝔱𝔲𝔳𝔴𝔵𝔶𝔷𝔄𝔅ℭ𝔇𝔈𝔉𝔊ℌℑ𝔍𝔎𝔏𝔐𝔑𝔒𝔓𝔔ℜ𝔖𝔗𝔘𝔙𝔚𝔛𝔜ℨ◌◌◌◌◌◌◌◌◌◌
  ¡frak,bold  F⟨@letnum⟩ ⦑ ⦒ ⟶ 𝖆𝖇𝖈𝖉𝖊𝖋𝖌𝖍𝖎𝖏𝖐𝖑𝖒𝖓𝖔𝖕𝖖𝖗𝖘𝖙𝖚𝖛𝖜𝖝𝖞𝖟𝕬𝕭𝕮𝕯𝕰𝕱𝕲𝕳𝕴𝕵𝕶𝕷𝕸𝕹𝕺𝕻𝕼𝕽𝕾𝕿𝖀𝖁𝖂𝖃𝖄𝖅◌◌◌◌◌◌◌◌◌◌
  ¡mathscript m⟨@letnum⟩ ⦑ ⦒ ⟶ 𝒶𝒷𝒸𝒹ℯ𝒻ℊ𝒽𝒾𝒿𝓀𝓁𝓂𝓃ℴ𝓅𝓆𝓇𝓈𝓉𝓊𝓋𝓌𝓍𝓎𝓏𝒜ℬ𝒞𝒟ℰℱ𝒢ℋℐ𝒥𝒦ℒℳ𝒩𝒪𝒫𝒬ℛ𝒮𝒯𝒰𝒱𝒲𝒳𝒴𝒵◌◌◌◌◌◌◌◌◌◌
  ¡para       p⟨@letnum⟩ ⦑N⦒ ⟶ ⒜⒝⒞⒟⒠⒡⒢⒣⒤⒥⒦⒧⒨⒩⒪⒫⒬⒭⒮⒯⒰⒱⒲⒳⒴⒵🄐🄑🄒🄓🄔🄕🄖🄗🄘🄙🄚🄛🄜🄝🄞🄟🄠🄡🄢🄣🄤🄥🄦🄧🄨🄩◌⑴⑵⑶⑷⑸⑹⑺⑻⑼
  ¡circle     c⟨@letnum⟩ ⦑N⦒ ⟶ ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ◌󰲡󰲣󰲥󰲧󰲩󰲫󰲭󰲯󰲱
  ¡circlen2   C⟨@number⟩ ⦑N⦒ ⟶                                                     ⓪①②③④⑤⑥⑦⑧⑨
⟧

⦑c⦑ff9dc6⦒⦒ ⦑N⦒ ⟦hi⟧ ⟶ AB

󰦥󰦥󰦥󰦥󰦥

⨡ string as 𝐒
⮌ peggle ⨡ Parser
🌈 = 󰋺∘␛🌈
󰋺(␛𝐍, ␛𝐍)


GRAM = ␛
󰦥󰦥󰦥󰦥󰦥
main = (󰆴W ∨ concat)*

atom = 󰆴w? ↷ (macadd ∨ macref ∨ results ∨ style ∨ p_looper ∨ p_concat ∨ lookup)

macadd = 󰆴'¡' (󰆴W? ↷ (󰆴',' ⯆ word)) concat
macref = 󰆴'⟨' 󰆴W? ↷ (
      (macref_tag  =(󰆴@ word))
    ∨ (macref_notag=(   word))
) 󰆴'⟩'

results = (
    (󰆴(W? '󰅁') (󰆴W ∨ str ∨ ~‹[^󰅂]›)* 󰆴'󰅂')
   ∨(󰆴⟶        (󰆴w ∨ str ∨ ~‹[^⟧⁆⟩\n\t ]›)*)
)

style = 󰆴'⦑' (󰆴W? ↷ (⠶tuple ∨ ✓)) 󰆴'⦒'
tuple = ((| (| ✓)*)? chain)+
pair  = ƨ(word) 󰆴W? ⦑ ⠶tuple? ⦒
chain = (pair ∨ word)+ 󰆴W?

concat = (⠶atom)+
p_looper = 󰆴'⟦' (󰆴W ∨ ⠶atom)* 󰆴'⟧'
p_concat = 󰆴'⁅' (󰆴W ∨ ⠶atom)* 󰆴'⁆'

lookup = str ∨ ƨ(chr ∨ '|' ∨ ',')
word   = ƨ(str ∨ chr+)
str    = ƨ(⠶esc ∨ (󰆴'"' ((esc ∨ ~‹[^"]›)*) 󰆴'"'))
esc    = 󰆴‹␛␛› ~‹.?›

chr = ¬bad ~‹.›
bad = ~‹["⟨⟩⟦⟧⁅⁆⦑⦒¡,|\t\n ]›

w = ~‹[ \t]+›
W = ~‹[ \t\n]+›

(⟦=󰆴(W?↷'⟦'))(⟧=󰆴(W?↷'⟧'))(⁅=󰆴(W?↷'⁅'))(⁆=󰆴(W?↷'⁆'))
(⦑=󰆴(W?↷'⦑'))(⦒=󰆴(W?↷'⦒'))(⟨=󰆴(W?↷'⟨'))(⟩=󰆴(W?↷'⟩'))
(󰅁=󰆴(W?↷'󰅁'))(󰅂=󰆴(W?↷'󰅂'))(⟶=󰆴(W?↷'⟶'))(¡=󰆴(W?↷'¡'))
(|=󰆴(W?↷'|'))(@=󰆴(W?↷'@'))(,=󰆴(W?↷','))
󰦥󰦥󰦥󰦥󰦥

symmap = {
        ␛(: "parenleft"  , ␛): "parenright"  ,
        ␛{: "braceleft"  , ␛}: "braceright"  ,
        ␛[: "bracketleft", ␛]: "bracketright",
        ␛<: "less"       , ␛>: "greater"     ,
        ␛+: "plus"       , ␛-: "minus"       ,
        ␛/: "slash"      , ␛\: "backslash"   ,
        ␛!: "exclam"     , ␛?: "question"    ,
        ␛@: "at"         ,
        ␛.: "period"     , ␛,: "comma"       ,
        ␛:: "colon"      , ␛;: "semicolon"   ,
        ␛&: "ampersand"  , ␛%: "percent"     ,
        ␛=: "equal"      , ␛*: "asterisk"    ,
        ␛_: "underscore" , ␛|: "bar"         ,
        ␛^: "asciicircum", ␛~: "asciitilde"  ,
        ␛#: "numbersign" , ␛$: "dollar"      ,
        ␛': "apostrophe" , ␛": "quotedbl"    ,
        ␛𝕊: "space"      , ␛ᴍ: "Multi_key"   ,
        ⠶𝑑(𝐒.ascii_letters+𝐒.digits ᴍ󰲡x⋄꜠) }

fargs = ƒ↦ƒ.__code__.co_varnames[:ƒ.__code__.co_argcount]
gen, gens = n↦ƒ↦gensₙ≔ƒ, {}
gen(␛c)←⥌x=□,y=□,z=□↦{ ⠶x∧{          "color": 🌈.h2hl←x}∨{},
                       ⠶y∧{"backgroundColor": 🌈.h2hl←y}∨{},
                       ⠶z∧{    "borderColor": 🌈.h2hl←z}∨{} }
gen(␛B)←⥌x,y=1,r=1↦ℵ(borderStyle  = ‹s solid d dashed›⍭⥉𝑑→ₓ,
                     borderWidth  = ‹⟦y⟧px›,
                     borderRadius = ‹⟦r⟧px›)
gen(␛b)←𝚲ℵ(fontStyle="bold")
gen(␛N)←𝚲ℵ(NO_SCALE=ⴳ)
gen(␛u)←⥌x=1↦ℵ(textDecoration=‹underline ⟦x⟧px›)
⊢ decor(n, multi=ⴴ):
    R = []
    ∀n∈n:
        r = {}
        ∀n∈n:
            t, v = nᵗ, nᶜ
            ¿t ≡ "word":
                r |= gens[v₀ᵗ]
            ⸘t ≡ "pair":
                t, c = v₀ᵗ, v₁ᶜ
                ə = c ᴍ󰲡□ ¿xᵗ≡␛✓¡ 𝘀.join(x.extract(󰲡¬xᶜ,Δ=✗)ᴍ󰲡xᵗ)
                ƒ = gensₜ
                r |= ƒ(⠶{k:v∀k,v∈fargs(ƒ)ζə¿k≇□})
        R += r⛶
    ↪ R¿multi¡R₀

⊢ supermcdoublerecursivecomposeoutputstyleparsemachine(
        n, pre=□, mac=□, res=□):
    
    mac, pre, res = {}¿mac≅□¡mac, []¿pre≅□¡pre, []¿res≅□¡res
    𝕤 = 𝚲supermcdoublerecursivecomposeoutputstyleparsemachine(⠤𝔸,mac=mac,res=res)
    ¿nᵗ≡"main":
        𝕤(n.copy(t="looper"),pre)
        ↪ mac, res
    ¿nᵗ≡"looper": ↪ nᴍ󰲡𝕤(x,pre)󰅂Σ[]
    ¿nᵗ≡"concat":
        seqs, L = [pre], nᴍ󰲡x
        ➰L:
            N = L.pop∘0
            nseqs = []
            ∀p∈seqs:
                nseqs += 𝕤(N, p)  [seq]
            seqs = nseqs
        ↪ seqs
    ¿nᵗ≡"style":  ↪ [[⠤pre, ("STYLE", n₀ᵗ)]]
    ¿nᵗ≡"lookup": ↪ [pre+(("LIT", n₀ ₀ᵗ)¿n₀ᵗ≡"str"¡n₀ᵗ)⛶]  󰤱 strs (󷹇 they special!)
    ¿nᵗ≡"results":
        C, ⠤nᶜ = n
        res.append((pre, (C₀¿C🃌¡C)ᵗ))
        ↪ [pre]
    ¿nᵗ≡"macadd":
        ⠤w, s = n
        seqs = 𝕤(s, pre +← wᴍ󰲡("TAG", x₀ᵗ))
        w ᴍ󰲡mac.setdefault(x₀ᵗ,[]).extend(seqs)
        ↪ seqs
    ¿nᵗ≡"macref":
        n = n₀
        val = mac[nam ≔ n₀ ₀ᵗ ֎󰤱􊽨֎]
        ¿nᵗ≡"macref_tag":
            □ pre += [("TAG", nam)]
        ¡:
            val ᴍ= 󰲡x 󰈳󰲡xᐹ𝑡∧x₀≡"TAG"
        ↪ val ᴍ󰲡pre+x

head_types = ‹R_S_C R_S_0 R_C_S R_C R_S_1›⍭
⊢ parse(dat, gram=Parser(GRAM), SCRIPT_EXIST=SCRIPT_EXIST):
    dat = 𝗻.join←dat.split(𝗻)󰈳󰲡x.lstrip().startswith←␛󰅂
    
    root = gram(dat🟑, DEBUG=✓, ONLY_NAMED=✓🟑)  ← most perf optmz herez
    root = root.child_killer(󰲡xᵗ∈𝑠←‹ℜ¡|␛⟦␛⟧⁅⁆⦑⦒⟨⟩⟶›)
    root = root.find_replace(󰲡✓, 󰲡(xᵗ∧(xᵗ,xᶜ)∨(xᶜ,[])))
    root = (rep≔󰲡𝐍(x)¿xᐹᔐ¡𝐍(x₀,⠤x₁ᴍrep))∘root
    root = root.ftrp("str word"⍭, 󰲡x.copy(xᵗ, c=[𝐍(xᴍ󰲡xᵗ󰅂Σᐦ)]))
    root = root.ftrp("style"⍭, 󰲡x.copy(c=[𝐍(decor(x))]))
    root = root.ftrp("p_looper"⍭, 󰲡x.copy("looper"), ✓)
    root = root.ftrp("p_concat"⍭, 󰲡x.copy("concat"), ✓)
    mac, lets = supermcdoublerecursivecomposeoutputstyleparsemachine(root)
    
    lets ꟿ= 󰲣x  󰲡xᐹ𝑡∧x₀∈(‹TAG STYLE›⍭)∧x₀󰅂 ⥉ ␛
               󰲡(x.pop(✗), (x ꟿⱽ󰲣 yᴍ 󰲡x₁󰅂))󰅂 ␛
             →+y⛶ᵀ
    
     letsꟿ𝚲𝘀.join←𝔸ᴍᔐ→☾
    
    res = {}
    ➰ lets:
        C = (S, 𝐭, c) = lets.pop∘0
        ns = ᐦ
        ∀s∈S:
            ¿s≡␛ᐦ: ↺
            ¿sᐹ𝑡:
                ⨳ s₀≡"LIT"
                ¿s₁∈res: ⇥
                ns += res[s₁]₀ ₀
            ⸘s∈symmap: ns += s
            ⸘s∈   res: ns += resₛ ₀ ₀
            ¡: ⇥
        ¡:
            res.setdefault(c,[]).append((ns,𝐭))
            ↺
        lets.append(C)
    
    ∀c∈res:
        seqs = resᴍ󰲡x₀
        styles, tags = {}, []
        ∀k,v∈(res ꟿ 󰲣y.items⥉𝑙󰅂 Σ[]):
            ¿k≡"STYLE": styles |= (v ſ |)
            ⸘k≡  "TAG":   tags += v
        res = ℵ(
            T="reg",
            out=c,
            seqs=seqs,
            sets=tags,
            style=styles)
    
    SCRIPT_EXIST = SCRIPT_EXIST.strip().split(𝗻) ᴍ ᔐ.strip ꟿ⁰ ζ´ ꟿ󰲥(x,y⋄z)󰅂 ⥉ 𝑑
    already_script = 󰲣j≔SCRIPT_EXIST.get(x,ⴴ)→∧(␛◌≠H≔j[y≡␛p] →∧H)
    
    ⊢ get_psuedo_seqs(c):
        ¿c∈symmap: ↪[c]
        ¿c∈res: ↪resˢᵉˢ
    
    ∀k ∈ (symmap 󰈳󰲡x∈"ᴍ𝕊"):
        ¿k∈res: ↺
        resₖ = ℵ(T="NC",
                 out=k,
                 seqs=get_psuedo_seqs(k),
                 sets=[],
                 style={})  sets/style?
    
     maybe add a thing that disallows base symmap keys from generating even if inside the compose so we can style em?
    
    ⊢ make_script_seq_pre(p, s, c):  ᵃ \a ; 󰁌 \\a𝕊 ; 􋑪 \𝕊
        ↪ p⋅(2-←c∈symmap)+(␛𝕊¿c≡p¡s)
    
    to_subs, to_sups = [], []
    ∀k,v∈res.items:
        ∀𝐩,⒨,g∈ζ´(‹/\›, ‹sub sup›⍭, to_subs⋄to_sups):
            g.append(ℵ(
                T=⒨,
                out = already_script(k, ⒨₋₁) ∨ □,
                seqs=vˢᵉˢ ᴍ󰲡make_script_seq_pre(𝐩,x,k),
                sets=vˢᵉᵗˢ + [⒨],
                style=vˢᵗʸˡᵉ))
    
     󰤱 Generate to_{subs,sups} ⓦ out≡□, set the out field, add to_{subs,sups} to res
    
     to_subs☾
     res☾

parse∘DAT

 󰤱 auto insert sub/sup versions
 󰤱 add section for composite characters
     󰤱 color default derived from first char
 󰤱 add section for "style ⟶ rgx"
 󰤱 the rest of it

🟑
non-pre: allow running process to continue until the proc terms or blcosk a resource
preemptive: may stop cur run proc and choose another proc to run.

upside down 1 for -1?
🟑