Â§ TODOs ------------------------------------

    ó°¤±  __setminus__, __crossprod__, __union__, __intersection__, __subset__ ; mutex
    ó°¤±  bootstrap everything
    ó°¤±  Web/phone-app maker
    ó°¤±  Way to detect imports implicitly
    ó°¤±  normalize binds/stuff for edits/cross-plat
        ó°¤± SCRIPT_MAP hardcoded in moonvert rn
    ó°¤±  regex but better
    ó°¤±  add the edge cases for the new compose ops
    ó°¤±  eval bar: ó·º„xó°„2ó°„3â, ó·º„xó°„â¬¤ó°„â¬¤â
    ó°¤±  Ponder shape â¥Š operator
    ó°¤±  Better â˜¾
    ó°¤±  proper cli for generating font
    ó°¤±ôŠ½¨ ï’¼ option to print progress
    ó°¤±ôŠ½¨ Make xâ­œyâ­z store vals
    ó°¤±ôŠ½¨ Star versions of: ó°ˆ²ó°ˆ³î®†ó°’¼ó°’½
    ó°¤±ôŠ½¨ Font generator slow
    ó°¤±  Documentation (lol)

Â§ CoolCharBankâ„¢ ------------------------------------

    ê›
    ó·¸Ÿó·¸ó·¸ ó·¸£ó·¸¤ó·¸¥ ó·¸ ó·¸¡ó·¸¢ ó·¸¦âœâ¥ó·¸§
    âŒ¾âœªğŸ…­âš†âŸâ¦¾â¦¿â£
    â§¿ ó°¹³ ï‚ â§Ÿ ó±—˜
    ó·¹¾ ó·º€ ó·¹½ ó·¹¿ ó·¹¥ ó·¹§ ó°‡˜ ó·¹¦ ó°˜£ ó°” ó°¡ ó°˜¡ ó·¹  ó°˜ ó·¹Ÿ ó°˜Ÿ ó·¹¡ ó°˜  ó°©€ ó°¨¾ ó°¨¿
    ó°…³âŒ˜â„¿â©‡âŒ¢âŒ£âœââ‰¬ğ„â¦â¦‚â¦‡â¦ˆâ¦‰â¦Šâ¨¾â©¤â©¥Ï¶â›¯
    ó±£¬ó°ˆ´ ï’Œîœ§î®«ó°¨‘ó±“ï¸ï· ó°‡™
    ó°•–î ‚î ƒî˜ ó°†ó°¸‡ó°‰‰ó°„·ó°„¶ó°ˆó°ˆ”ó°ˆ•ó°´œó°¢ó°ˆ‹ó°‹‹ó°ˆ¸ó°¥“
    ó°©¹ï‡¸ó°©ºï€”ï’îª ó°”›ó±«­ó±«Ÿó±« ó±«ó±«¤ó±«ó±«¦ ó±«Œ ó°”Ÿï‰”
    ó°£¡ó°£¢ó°££ó°£¤ó°£¥ó°£¦ó°£§ ó°«ƒó°«„ó°«…ó°«†ó°«‡ó°«ˆ ó°¯ó°¯‚ó°¯ƒ
    â¶â·â´âµâ–²â–¼â–¶â—€ğŸğŸƒğŸ€ğŸ‚â–´â–¾â—‚â–¸â–µâ–¿â—ƒâ–¹â—¢â—£â—¤â—¥â—¸â—¹â—ºâ—¿
    â”â¬¡
    ğ›¬ó°¦ó°©ó°¬ó°®ó°°ó°µó°¸ó°»ó°¾ó°£
    ó°…Šó°±—î¯Œïƒ…ó°†ïƒªï©ó°†’ó±‰¬ó±‰§ó°…‡ó°…Œó±“¥
    ó°…² ó°…ª ó°…© ó°…´ îªµîª¶ ï„„ï„… î‚³î‚± ï“ï” î­¯î­°
    ğ¼‹ â¥¾ ğ–£‚ ó°™¨ â¹” ó±—˜ ó±•› ï„£ ï“® îº¨ ïƒŠ
    á•»á“á“’á”¥á£› á”‡á”…á”‰á”Šá“ªá£—á•á”¾á–® á£œá£á“«á•‘á£á£Ÿá á—®áªó°‚…á“‘á£•á¡á¢ á¤áá á‘Šá˜á£”

Â§ OverPowered STUFF [f,â¬¤,g,âˆšğŸŠ] ------------------------------------
    
    â›a ó±–”âºô®¡ô‹„ô¯Â² â›b
    
    fâ—‹[1,2,0] = f(ğ”¸â‚,ğ”¸â‚‚,ğ”¸â‚€)
    fâ—‹[1,2,*,0] = f(ğ”¸â‚,ğ”¸â‚‚,â ¤ğ”¸â‚ƒï¹•,ğ”¸â‚€)
    
    SignaturesôŠ½¨:
        (    f    {ó°¬©,ó°¬«,ó±–š,ó±–˜,â¥,â—‹}ô‹€    g    )(â ¤ğ”¸ğŸƒŒ=m)
        (    f    {ó°¬©,ó°¬«,ó±–š,ó±–˜,â¥,â—‹}ô‹€[gâ‚€,gâ‚,â€¦])(â ¤ğ”¸ğŸƒŒ=m)
        ([fâ‚€,fâ‚,â€¦]{ó°¬©,ó°¬«,ó±–š,ó±–˜,â¥,â—‹}ô‹€    g    )(â ¤ğ”¸ğŸƒŒ=m)
        ([fâ‚€,fâ‚,â€¦]{ó°¬©,ó°¬«,ó±–š,ó±–˜,â¥,â—‹}ô‹€[gâ‚€,gâ‚,â€¦])(â ¤ğ”¸ğŸƒŒ=m)

    î¬¦ Â¿(<â‹…>)â¿ each g gets n args, where do the extra arguments go?
    î¬¦ á´OâŸ¦:_<>ADâŸ§ âŸ¶ â¥âœó°¬«ó°¬©ó±–šó±–˜
    î¬¦ ó°¬©ó°¬«ó±–šó±–˜â—‹âœâ¥âŠ™âš†âŒ¾âŸâŒ½âŠ¸âŸœï‚©ï‚¨ï„¸ï„·
    
    î¬¦ ó°¬«/ó°¬©:
        default is ğ—™(y)â­œs=2â­s=1
        î¬¦ g takes 2 arguments, as many times as possible (or once for each function in list), and puts excess to the right(ó°¬«)/left(ó°¬©)

        {ó°¬©,ó°¬«} = {ó°¬©,ó°¬«}âº,{ó°¬©,ó°¬«}â»: distribute

        f ó°¬«Â² g  (ğŸ˜,ğŸ™,ğŸš) = f(g(ğŸ˜,ğŸ™),ğŸš)
        f ó°¬«ô§± g  (ğŸ˜,ğŸ™,ğŸš) = f(g(ğŸ™,ğŸš),ğŸ˜)
        f ó°¬©Â² g  (ğŸ˜,ğŸ™,ğŸš) = f(ğŸ˜,g(ğŸ™,ğŸš))
        f ó°¬©ô§± g  (ğŸ˜,ğŸ™,ğŸš) = f(ğŸš,g(ğŸ˜,ğŸ™))

        f ó°¬«Â² [g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸ™),h(ğŸš,ğŸ›),ğŸœ)
        f ó°¬«ô§± [g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ™,ğŸš),h(ğŸ›,ğŸœ),ğŸ˜)
        f ó°¬©Â² [g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(ğŸ˜,g(ğŸ™,ğŸš),h(ğŸ›,ğŸœ))
        f ó°¬©ô§± [g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(ğŸœ,g(ğŸ˜,ğŸ™),h(ğŸš,ğŸ›))
        
        î¬¦ ó·¹‡ if it was just g instead of [g,h] it would just have all g's

        î¬¦ what about underflow? fill in as much as possible, keep empty args still.
        f ó°¬©â° g (ğŸ˜) = f(ğŸ˜, g())
        f ó°¬«â° g (ğŸ˜) = f(g(), ğŸ˜)
        f {ó°¬«,ó°¬©}ô‹€ô‹ôŠ½­Â¹ g  (ğŸ˜) = f(ğŸ˜)
        f {ó°¬©,ó°¬«}ôŠ½­Â¹   g  (ğŸ˜) = f(g(ğŸ˜))
        
        f ó°¬«â° [g,h] (ğŸ˜)   = f(g(),h(),ğŸ˜)
        f ó°¬©â° [g,h] (ğŸ˜)   = f(ğŸ˜,g(),h())
        
        f ó°¬«Â¹ [g,h] (ğŸ˜)   = f(g(ğŸ˜),h())
        f ó°¬«ô¨… [g,h] (ğŸ˜)   = f(g(),h(ğŸ˜))
        f ó°¬©Â¹ [g,h] (ğŸ˜)   = f(g(ğŸ˜),h())
        f ó°¬©ô¨… [g,h] (ğŸ˜)   = f(g(),h(ğŸ˜))
        
        f ó°¬«Â² [g,h] (ğŸ˜,ğŸ™)   = f(g(ğŸ˜,ğŸ™),h())
        f ó°¬«ô§± [g,h] (ğŸ˜,ğŸ™)   = f(g(),h(ğŸ˜,ğŸ™))
        f ó°¬©Â² [g,h] (ğŸ˜,ğŸ™)   = f(g(ğŸ˜,ğŸ™),h())
        f ó°¬©ô§± [g,h] (ğŸ˜,ğŸ™)   = f(g(),h(ğŸ˜,ğŸ™))
        f ó°¬«Â² [g,h] (ğŸ˜,ğŸ™,ğŸš) = f(g(ğŸ˜,ğŸ™),h(ğŸš))
        f ó°¬«ô§± [g,h] (ğŸ˜,ğŸ™,ğŸš) = f(g(ğŸ˜),h(ğŸ™,ğŸš))
        f ó°¬©Â² [g,h] (ğŸ˜,ğŸ™,ğŸš) = f(g(ğŸ˜,ğŸ™),h(ğŸš))
        f ó°¬©ô§± [g,h] (ğŸ˜,ğŸ™,ğŸš) = f(g(ğŸ˜),h(ğŸ™,ğŸš))
    
    î¬¦ â—‹/âœ
        ó·¹‡ concat = ğ‘–â—‹+Â´â—‹Â²á”
        
        f â—‹Â¹ g = f â—‹ g = f(g(â ¤ğ”¸))
        
        ó·¹‡ part_R is the one that may be small
        ó·¹‡ FT{L,R} = fill towards left/right
        f â—‹Â² g  (â ¤ğ”¸) = f(g(part_L       ),g(part_R    FTR))
        f â—‹ô§± g  (â ¤ğ”¸) = f(g(part_L       ),g(FTL    part_R))
        f âœÂ² g  (â ¤ğ”¸) = f(g(part_L    FTR),g(       part_R))
        f âœô§± g  (â ¤ğ”¸) = f(g(FTL    part_L),g(       part_R))
        
        f â—‹ô‹€ [g]   (â ¤ğ”¸)          = f(g(â ¤ğ”¸))
        f â—‹Â² [g]   (ğŸ˜,ğŸ™)         = f(g(ğŸ˜,ğŸ™))
        f â—‹Â¹ [g,h] (ğŸ˜,ğŸ™)         = f(g(ğŸ˜),h(ğŸ™))
        f â—‹Â² [g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ)   = f(g(ğŸ˜,ğŸ™,ğŸœ),h(ğŸš,ğŸ›,ğŸœ))
        f â—‹Â² [g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ) = f(g(ğŸ˜,ğŸ™,ğŸœ,ğŸ),h(ğŸš,ğŸ›,ğŸœ,ğŸ))
        
        
        
        f â—‹ô‹”› [g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ) = f(g(ğŸ˜,ğŸ™,ğŸœ,ğŸ),h(ğŸš,ğŸ›,ğŸœ,ğŸ))
        fâ—‹Â³[g,h]   (ğŸ˜,ğŸ™)     â‰Ÿ f(g(ğŸ˜,ğŸ˜,ğŸ˜),h(ğŸ™,ğŸ™,ğŸ™))
        fâ—‹Â³[g,h]   (ğŸ˜,ğŸ™,ğŸš,ğŸ›) â‰Ÿ f(g(ğŸ˜,ğŸ™,ğŸš),h(ğŸ›,ğŸ™,ğŸš))
        fâ—‹ô§Ÿ[g,h]   (ğŸ˜,ğŸ™,ğŸš,ğŸ›) â‰Ÿ f(g(ğŸ˜,ğŸ™,ğŸš),h(ğŸ˜,ğŸ™,ğŸ›))
        fâ—‹Â³[g,h,i] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) â‰Ÿ f(g(ğŸ˜,ğŸ™,ğŸš),h(ğŸ›,ğŸ™,ğŸš),i(ğŸ›,ğŸ™,ğŸš))
        
        fâ—‹Â¹g (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(ğŸ˜,ğŸ™,ğŸš,ğŸ›))
        
        fâ—‹Â³[g,h,i] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(ğŸ˜),h(ğŸ™),i(ğŸš))
        
        fâ—‹Â³[g,h,i] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(ğŸ˜,ğŸ™,ğŸš),h(ğŸ›),i())
        fó°¬«Â³[g,h,i] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(ğŸ˜,ğŸ™,ğŸš),h(ğŸ›),i())
        fâ—‹ô§Ÿ[g,h,i] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(),h(ğŸ˜),i(ğŸ™,ğŸš,ğŸ›))
        fó°¬©Â³[g,h,i] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(),h(ğŸ˜),i(ğŸ™,ğŸš,ğŸ›))
        fâ—‹ô‹”›[g,h,i] (â ¤ğ”¸)      = f(g(â ¤ğ”¸),h(),i())
        fâ—‹ô°“[g,h,i] (â ¤ğ”¸)      = f(g(),h(),i(â ¤ğ”¸))
        
        fâ—‹Â¹[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸš,ğŸ›,ğŸœ),h(ğŸ™,ğŸš,ğŸ›,ğŸœ))
        fâ—‹ô¨…[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸ™,ğŸš,ğŸ›),h(ğŸ˜,ğŸ™,ğŸš,ğŸœ))
        
        fâ—‹Â²[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸ™,ğŸœ),h(ğŸš,ğŸ›,ğŸœ))

        fó°¬«Â²[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸ™),h(ğŸš,ğŸ›),ğŸœ)
        fó°¬©Â²[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(ğŸœ,g(ğŸ˜,ğŸ™),h(ğŸš,ğŸ›))
        fó°¬©ô§±[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(ğŸ˜,g(ğŸ™,ğŸš),h(ğŸ›,ğŸœ))
        fâ—‹ô§±g     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) â‰Ÿ f(g(ğŸ˜,ğŸ™,ğŸš),g(ğŸ›,ğŸœ,ğŸš))
        fâ—‹ô§±g     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) â‰Ÿ f(g(ğŸ˜,ğŸ™,ğŸš),g(ğŸ˜,ğŸ›,ğŸœ))
        fâ—‹ô§±g     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) â‰Ÿ f(g(ğŸ™,ğŸš,ğŸ˜),g(ğŸ›,ğŸœ,ğŸ˜))
        fâ—‹ô§Ÿg     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) â‰Ÿ f(g(ğŸ˜,ğŸ™),g(ğŸš,ğŸ›),g(ğŸœ,ğŸ™))
        
        fâ—‹Â²g     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸ™,ğŸœ),g(ğŸš,ğŸ›,ğŸœ))
        fó°¬«Â²g     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸ™),g(ğŸš,ğŸ›),ğŸœ)
        fó°¬©Â²g     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(ğŸœ,g(ğŸ˜,ğŸ™),g(ğŸš,ğŸ›))
        fó°¬©ô§±g     (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(ğŸ˜,g(ğŸ™,ğŸš),g(ğŸ›,ğŸœ)) Â¿ maybe reverse Â±
        
        (f ? [g,h])(ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(ğŸ˜,ğŸ™),h(ğŸš,ğŸ›))
        (f ? [g,h])(ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ) = f(g(ğŸ˜,ğŸ™,ğŸš),h(ğŸ›,ğŸœ,ğŸ))
        
        fó°¬©Â²g = f(g(ğŸ˜, ğŸ™), ğŸš)
        fó°¬«Â²g = f(ğŸ˜, g(ğŸ™, ğŸš))

        fó°¬©Â²[g,h] (ğŸ˜,â€¦,ğŸœ) = f(g(ğŸ˜,ğŸ™), g(ğŸš,ğŸ›), ğŸœ)
        fó°¬«Â²[g,h] (ğŸ˜,â€¦,ğŸœ) = f(ğŸ˜, g(ğŸ™, ğŸš))

        (fâ—‹Â¹g) = f(g(â ¤ğ”¸))
        (fâ—‹ô‹”›g) = f(â ¤ğ”¸á´g)
        fâ—‹Â²gâ†(ğŸ˜)           = f(g(ğŸ˜    ), g(ğŸ˜    ))
        fâ—‹Â²gâ†(ğŸ˜,ğŸ™)         = f(g(ğŸ˜    ), g(ğŸ™    ))
        fâ—‹Â²gâ†(ğŸ˜,ğŸ™,ğŸš)       = f(g(ğŸ˜,ğŸš  ), g(ğŸ™,ğŸš  ))
        fâ—‹Â²gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›)     = f(g(ğŸ˜,ğŸ™  ), g(ğŸš,ğŸ›  ))
        fâ—‹Â²gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ)   = f(g(ğŸ˜,ğŸ™,ğŸœ), g(ğŸš,ğŸ›,ğŸœ))
        fâ—‹Â²gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ) = f(g(ğŸ˜,ğŸ™,ğŸš), g(ğŸ›,ğŸœ,ğŸ))

        fâ—‹Â³gâ†(ğŸ˜)             = f(g(ğŸ˜    ), g(ğŸ˜    ), g(ğŸ˜    ))
        fâ—‹Â³gâ†(ğŸ˜,ğŸ™)           = f(g(ğŸ˜,ğŸ™  ), g(ğŸ˜,ğŸ™  ), g(ğŸ˜,ğŸ™  ))
        fâ—‹Â³gâ†(ğŸ˜,ğŸ™,ğŸš)         = f(g(ğŸ˜    ), g(ğŸ™    ), g(ğŸš    ))
        fâ—‹Â³gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›)       = f(g(ğŸ˜,ğŸ›  ), g(ğŸ™,ğŸ›  ), g(ğŸš,ğŸ›  ))
        fâ—‹Â³gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ)     = f(g(ğŸ˜,ğŸ›,ğŸœ), g(ğŸ™,ğŸ›,ğŸœ), g(ğŸš,ğŸ›,ğŸœ))
        fâ—‹Â³gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ)   = f(g(ğŸ˜,ğŸ™  ), g(ğŸš,ğŸ›  ), g(ğŸœ,ğŸ  ))
        fâ—‹Â³gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ,ğŸ) = f(g(ğŸ˜,ğŸ™,ğŸ), g(ğŸš,ğŸ›,ğŸ), g(ğŸœ,ğŸ,ğŸ))

        fâ—‹â´gâ†(ğŸ˜)         = f(g(ğŸ˜    ), g(ğŸ˜    ), g(ğŸ˜    ), g(ğŸ˜    ))
        fâ—‹â´gâ†(ğŸ˜,ğŸ™)       = f(g(ğŸ˜,ğŸ™  ), g(ğŸ˜,ğŸ™  ), g(ğŸ˜,ğŸ™  ), g(ğŸ˜,ğŸ™  ))
        fâ—‹â´gâ†(ğŸ˜,ğŸ™,ğŸš)     = f(g(ğŸ˜,ğŸ™,ğŸš), g(ğŸ˜,ğŸ™,ğŸš), g(ğŸ˜,ğŸ™,ğŸš), g(ğŸ˜,ğŸ™,ğŸš))
        fâ—‹â´gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›)   = f(g(ğŸ˜    ), g(ğŸ™    ), g(ğŸš    ), g(ğŸ›    ))
        fâ—‹â´gâ†(ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ) = f(g(ğŸ˜,ğŸœ  ), g(ğŸ™,ğŸœ  ), g(ğŸš,ğŸœ  ), g(ğŸ›,ğŸœ  ))

        (fâ—‹Â¹g) = f(g(â ¤ğ”¸))
        (fâ—‹ô‹”›g) = f(â ¤ğ”¸á´g)

        fâ—‹Â¹gâ‹„h = f(g(h(â ¤ğ”¸)))
        fâ—‹ô‹”›gâ‹„h = f(â ¤ğ”¸á´gâ—‹h)
        fâ—‹Â²gâ‹„h = f(g(ğŸ˜),h(ğŸ™))
        fâ—‹Â³gâ‹„h = f(g(ğŸ˜,ğŸ™),h(ğŸ˜,ğŸ™))
        fâ—‹â´gâ‹„h = f(g(ğŸ˜,ğŸ™),h(ğŸš,ğŸ›))

    ó±–š/ó±–˜ (â™º):
        î¬¦ @OPWRAP_
        î¬¦ âŠ¢ opÂ´(x=â€, y=â€, s=1): î¬¦ by â™º
        î¬¦     î¬¦ where xâ«¢LHS, yâ«¢RHS, s=superscript
        î¬¦     â†ª result
        choices:
            start adding arguments from outside vs inside
            n describes num of args on all but inside vs outside
        fó±–˜â¿g (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(g(n_itms),n-1_itms),rest_itms)
        fó±–˜[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(ğŸ™,ğŸš,ğŸ›),ğŸ˜)
        fó±–˜[g,h] (ğŸ˜,ğŸ™,ğŸš,ğŸ›) = f(g(h(ğŸš,ğŸ›),ğŸ™),ğŸ˜)
        fó±–˜â¿[g,h  ] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ,ğŸ) = f(g(h(rest_itms),n_itms),n_itms)
        fó±–˜â¿[g,h,i] (ğŸ˜,ğŸ™,ğŸš,ğŸ›,ğŸœ,ğŸ,ğŸ) = f(g(h(i(rest_itms), n_itms), n_itms), n_itms)

        (ó±–˜Â¹ops)(l) ; lâ†¨ Å¿ ó°²£opsâ‚“ôŠ¬¤(xâ‚€,y)

        fó±–šg (ğŸ˜,ğŸ™,ğŸš) = f(g(ğŸ˜,ğŸ™),ğŸš)
        fó±–˜g (ğŸ˜,ğŸ™,ğŸš) = f(ğŸ˜,g(ğŸ™,ğŸš))

Â§ Regex STUFF ------------------------------------

    $ ^ ? | + * [^-] ( ) {,} \
        Â¿ âˆ¨ â¨ â¨€ â…âŒâ€¦â† âŸ¨ âŸ© âŸ®â€¦âŸ¯ â â® â† â†’ ğ˜€ ğ˜ ğ˜„ ğ—» ğ—ª

    We remove space/tabs/newlines automatically

    âŸ¨stuffâ­£ó°®ˆâŸ©       î¬¦ removes this match
    âŸ¨stuffâ­£Æ’âŸ©       î¬¦ applies Æ’ to this match
    âŸ¨stuffâ­£"aâŸ¨0âŸ©b"âŸ© î¬¦ applies replacement
    âŸ¨â›hâ­¡stuffâŸ©      î¬¦ match named â›h
    âŸ¨â­¡stuffâŸ©        î¬¦ match named 0 (increments every "âŸ¨â­¡â€¦âŸ©")
    âŸ¨â›hâ­¡stuffâ­£Æ’âŸ©    î¬¦ applies Æ’ to this match named â›h

    ğ”¯   @s does str match?
    ğ”¯   %s apply match-functions and repack into string
    ğ”¯   Ã·s â„µ: match_namesâ†¦ordered_matches
    ğ”¯   â‹…s match
    ğ”¯ôŠ¯›â‚• â‹…s list of matches named â›h
    ğ”¯â‚€ó°„â‚ƒâ‹…s zipmatch [[râ‚€ôŠ¬£,râ‚ƒôŠ¬£], [râ‚€ôŠ¬¤,râ‚ƒôŠ¬¤], â€¦]
    ğ”¯î ‰  â‹…s match (w/o nesting, i.e. [a,[b,c]] becomes [[a,b,c],[b,c]])

    ğ”¯ = âŸ¨ âŸ¨â›mâ­¡mul(âŸ¨â…0â€¦9â†â¨â­£ğ‘–âŸ©, âŸ¨â…0â€¦9â†â¨â­£ğ‘–âŸ©)âŸ© âˆ¨ do() âˆ¨ don't() âŸ©
    ğ”¯â‹…â€¹mul(5,2) do() mul(2,8) don't()â€º
    = [(â€¹mâ€º, [5, 2]), â€¹do()â€º, (â€¹mâ€º, [5, 2]), â€¹don't()â€º]

Â§ Better Syntax STUFF ------------------------------------

    xâ‡’âŸ¦ î¬¦ just find matching
        in_block
    in_block
    âŸ§ out_block

    î¬¦ Î”=ğ˜€â‹…4 happens here:
    Â¿x: in_block
        in_block
        j = â€¹some
        abc
        â€º î¬¦ j â‰¡ â€¹someğ—»abcğ—»â€º ; trick doesn't apply to magic ó°¦¥
        in_block
       out_block
       
    î¬¦ Î”=ğ˜€â‹…1 happens here:
    Â¿x:
     in_block
     in_block
     in_block
    out_block

    ğ‘“ = ó·º„xó°„yó°„zâ†¦w,[h,i],vâ†¦[w,x]â âŸ¦h+=1 ; h+=2 ; h âŸ§ Ö rets h Ö
    ğ‘“ = ó·º„xó°„yó°„zâ†¦w,[h,i],vâ†¦[w,x]â âŸ¦
        h+=1 ; h+2 âŸ§ Ö rets h+2 Ö
    ğ‘“ = ó·º„xó°„yó°„zâ†¦w,[h,i],vâ†¦[w,x]â
        h+=1
        h+2
    Ö rets h+2 Ö

Â§ What if â˜¾ was fast? ------------------------------------

    Actual AST tree
    Target llvm?
        exec/eval would be impossible/inefficent but that's ok
    
    Internal types:
        á”: [graphemes: ğ‘–]
        ğ‘–{1,2,4,8,16,32,64,128,256,âˆ}
        â„µ
        Æ’?
    
    Typing is implicit, regenerate functions/code snippets  
        Æ’ = xâ†¦xÂ²
        X = Æ’(5)
          = Æ’(5 â«¢ Â©,ğ‘–64)
            Æ’(ğ‘–64) = (ğ‘–64)â½ô‹‡–â¶â´â¾
                   = (ğ‘–64).__sup__(ğ‘–64)
                   = ğ‘–64
            âˆ´ Æ’:ğ‘–64â†’ğ‘–64
            (ğ‘–64).__sup__(ğ‘–64)
             Â¯Â¯Â¯â†–primitiveÂ¯Â¯Â¯â†–primitive
            âˆ´ llvm.powi.i64.i64
            5,2â«¢Â© âˆ´ llvm.powi.i64.i64(5,2)
                  âˆ´ llvm will auto reduce this for us
                  âˆ´ final expression would be like
                        SETLOCAL(id(X), 25â«¢ğ‘–64)
            
            
            
            (á¹x).__sup__(2) ó·¹‡ 2á¹ğ‘–
        Æ’ = xâ«¢ğ‘–64 â†¦ resolve((ğ‘–64).__sup__, (ğ‘–64))
                
        ó±€˜ ğ‘–:
            __sup__ = ó°²£POW_INT_INT 
            
        

Â§ Old stuff ------------------------------------------------

    âˆ§ ; and  ; xâ­œ   y   â­x     ; â©“
    âˆ¨ ; or   ; xâ­œ   x   â­y     ; â©”
    ó·º¤ ; xor  ; xâ­œ(yâ­œâœ—â­x)â­y     ; âˆ…
    ó·º¦ ; nxor ; xâ­œ(yâ­œyâ­âœ—)â­yâ­œâœ—â­âœ“ ; âˆ…
    ó·º’ ; nand ; xâ­œ(yâ­œâœ—â­x)â­yâ­œyâ­âœ“ ; ó·º¬
    ó·º¥ ; nor  ; xâ­œ   âœ—   â­yâ­œxâ­âœ“ ; ó·º«

    ó°®ˆ
    î¬¦ ó°›”
    î¬¦   (á”,á”): á”.replace
    î¬¦   (ğ’¾,ğ‘œ):   replace ; ó°›”Ê³

    [1,2,3] ğŒ‚ ğŒƒ

    [1,2,5,2,3] ğŒ‚â¿ ğ‘“
    î¬¦ 10â­¥ áµÂ²â¦š       âŸ¶   10â­¥á´Â¹ó°²¡xÂ²ó°…‚
    î¬¦   5 á‘€Â²â¦š       âŸ¶  (5,)á´â°ó°²¡xÂ²ó°…‚
    î¬¦   5 á‘€Â²+á‘… 6    âŸ¶ (5,6)êŸ¿â°ó°²£xÂ²+y
    î¬¦   5 á‘€Â²+âŸá‘…âŸ¤ 6  âŸ¶ (5,6)êŸ¿â°ó°²£xÂ²+y
    î¬¦   5 á‘€Â²+âŸ+á‘… 6  âŸ¶ (5,6)êŸ¿â°ó°²£xÂ²+y
    î¬¦ 10â­¥ áµÂ²+âŸÂ²â‹…á‘… 6 âŸ¶ 10â­¥á´Â¹â¥Œx,y=6â†¦xÂ²+yÂ²â‹…y
    î¬¦ á‘€áµâŸ âŸá‘ˆá‘…

    ó°²£xó·¸»yó°ˆ³âŸ¥á‘€%2á¸Î£0
    ó°²£xó·¸»yó°ˆ³âŸ¥á‘€%2á¸Î£0

    5 á‘€Â²+âŸ+á‘… 6   âŸ¶ 5Â²+6+6
    5 á‘€Â²+âŸá‘…â¦š 6   âŸ¶ 5Â²+6
    5 á‘€Â²â¦š +  6   âŸ¶ 5Â²+6
    (5 á‘€Â²+âŸâ¦š)(6) âŸ¶ 5Â²+6
    (á‘€Â²â¦š)(5)     âŸ¶ 5Â²
    (á‘€Â²+á‘…)(5,6)  âŸ¶ 5Â²+6

    î¬¦ https://ganer.xyz/s/fe9261c4a271da3a

    â¥Œa,b,câ†¦Â¯bÂ±âˆš(bÂ²-4aâ‹…c) áµ/2a
    ó°²¥Â¯yÂ±âˆš(yÂ²-4xâ‹…z)áµ/2x

    î¬¦ â¸ â¸¡â¸¾â¸½?

    x ó±–”ôŠ½º y

    î¬¦ â¥Œa,b,câ†¦Â¯bÂ±âˆšâ†bÂ²-4aâ‹…câ†’/2a
    î¬¦ â¥Œa,b,câ†¦Â¯bÂ±âˆšâ†bÂ²-4aâ‹…cá´ó°²¡x/2a

    conjugate?

    FIX FONT THIGN
    ó°‹º doesn't cache things so weird instance issues
    order arasol spray deodernt antiperaroas

    00 01 10 11
    0* *1 *0 1*
    âœ“ âœ—

    make replace operator support inserting lists in lists

    dynamic edit language grammar ğŸ‘
    activeparser.update(â„µ(
        oldrule=updatedrule,
        newrule=somenewrule,
        â€¦
    ))

    "Â¿ f(blah) â‡’ bruh"

    Â¿ | expr | call | expr | var | f
             | expr | var  | blah
      | expr | var  | bruh

    if_stmt = ó°†´"Â¿" expr ó°†´"â‡’" expr
    if_stmt(ó±•):
        if ó±•â‚€î®¦:
            return HIGH, ó±•â‚î®¦
        return LOW

    Bad spacing:
      Gal: "ã¿" galois group
      hom: "ê–¾" category hom morphisms
       re: "à¹‚" real part
       cx: "à¹ƒ" complex imaginary part

    op_maps á´â‘ xó°˜¬ğ˜€ á´â‘ xó°›”â›ğ¬â‹„ğ˜€

    dot = ğš²ğ”¸â‰á´Î Â´Î£

    # swag = â¥Œf,nâ†¦â‘ â‘¡â‘ â‘¡y(x)ó°…‚Å¿|[x]+fï¹•ï¹•â‚‹â‚ó°…‚(x)ó°…‚Å¿|[x]+[0]n

    # xÂ²â¡[âŠ£+2,âŠ£Â²]â¡âŠ£â¨¯2+âŠ¢â¬…âˆšy
    # xÂ²â¡([âŠ£+2,âŠ£Â²]â¡âŠ£â¨¯2+âŠ¢â¬…âˆšy)
    # xÂ²â¡([âŠ£+2,âŠ£Â²]â¡(âŠ£â¨¯2+âŠ¢â¬…âˆšy))
    # âŸ¨xÂ²âŸ©â¡ âŸ¨[âŠ£+2,âŠ£Â²]âŸ©â¡ (âŠ£â¨¯2+âŠ¢ â¬…âŸ¨âˆšyâŸ©))

    # fâ¡gâ¡ hğ â¬…k

    # fâ¡gâ¡hâ¡mâ¬…kâ¬…lâ¡p
    # (fâ¡gâ¡hâ¡ m â¬…kâ¬…l)â¡p
    # (fâ¡gâ¡hâ¡ m â¬…kâ¬…l)â¡p
    # dâ¬…fâ¡gâ¡hâ¡mâ¬…kâ¬…lâ¡p
    # (dâ¬…f)â¡gâ¡hâ¡((mâ¬…k)â¬…l)â¡p
    # ((((dâ¬…f)â¡g)â¡h)â¡((mâ¬…k)â¬…l))â¡p


    K = (â‘ [â˜¾(':',â ¤x,sep='\n'),x]â‚)
    # â‘ x-0â¤‰()
    gs = â‘¢1â€¦10âˆ–âˆª(zî “,(zâ‰)â‚“,â‰zî “â‚‹â‚ï¹•î “â‚Šâ‚‚ â‚“â‚‹â‚ï¹•â‚“â‚Šâ‚‚â‰Î£âˆ…)
    sr = â‘£(zî “ â‚“â‰”w)â–ºnx(z)
    nx = zâ†¦(K zÂ¿â–¡âˆ‰Î£(z))âˆ¨â…â…sr(x,y,K dcpğ‚â¨¯z,h)âˆ€hâˆˆgs(x,y,z)â†âˆ€x,yâˆˆ9â†•|â¨‰|9â†•Â¿Â¬zî “ â‚“â†
    nx([7â‹„8â‹„â–¡â‹„4â‹„â–¡â‹„â–¡â‹„1â‹„2â‹„â–¡,
        6â‹„â–¡â‹„â–¡â‹„â–¡â‹„7â‹„5â‹„â–¡â‹„â–¡â‹„9,
        â–¡â‹„â–¡â‹„â–¡â‹„6â‹„â–¡â‹„1â‹„â–¡â‹„7â‹„8,
        â–¡â‹„â–¡â‹„7â‹„â–¡â‹„4â‹„â–¡â‹„2â‹„6â‹„â–¡,
        â–¡â‹„â–¡â‹„1â‹„â–¡â‹„5â‹„â–¡â‹„9â‹„3â‹„â–¡,
        9â‹„â–¡â‹„4â‹„â–¡â‹„6â‹„â–¡â‹„â–¡â‹„â–¡â‹„5,
        â–¡â‹„7â‹„â–¡â‹„3â‹„â–¡â‹„â–¡â‹„â–¡â‹„1â‹„2,
        1â‹„2â‹„â–¡â‹„â–¡â‹„â–¡â‹„7â‹„4â‹„â–¡â‹„â–¡,
        â–¡â‹„4â‹„9â‹„2â‹„â–¡â‹„6â‹„â–¡â‹„â–¡â‹„7])


    1â‹„2 Î¶ 3â‹„4 Å¿ â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚
    ((1â‹„2) Î¶ (3â‹„4)) Å¿ (â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚)

    â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚ = â‘¡(xğŸƒŒ)âŒƒ(ğŸƒŒy)ó°…‚ = â‘¡(ğŸƒŒ(x))âŒƒ(ğŸƒŒ(y))ó°…‚
    â‘¡xğŸƒŒâ†’fâ†ğŸƒŒyó°…‚ = â‘¡f(xğŸƒŒ, ğŸƒŒy)ó°…‚ = â‘¡f(ğŸƒŒ(x), ğŸƒŒ(y))ó°…‚

    â€¹Aâ›â€ºCã€š2+2ã€›Dâ›â›Eâ›ğ—»Fğ—»â€º
    â›x ğ—» â›ğ—»
    Î±dasÎ²
    "ğ—»K\""+ğ—»+â›ğ—»
    ã€š([]âŸ¨âŸ©)Â²[[]â…â†]ã€›ã€š2ã€›
    "hi" \a\b

    (
        hi
    )

    â‘  xÂ²
    2
    â‘¡x+y
    ó°…‚+1
    ğ•‹ğ”½Î£among







    5|2+3â†’á´ğ‘¥
    5|(2+3)â†’á´ğ‘¥
    5|((2+3)â†’á´ğ‘¥)

    ğ‘¥á´â†2+5|2
    ğ‘¥á´â†(2+5)|2
    (ğ‘¥á´â†(2+5))|2



    def swag_arrow(n, arrow, layers):
        spl_ops = reduce(lambda x,y:x|y, layers[:arrow.o])
        Î±, Î² = partition(Ï(ğ•Š.get_op, layer=is_this_arrow))
        if arrow.d == 'r':
            n = partition(Î², Ï(ğ•Š.get_op, layer=spl_ops))
        if arrow.d == 'l':
            n = partition(Î±, Ï(ğ•Š.get_op, layer=spl_ops))

    ğœ¶ á´ ğ‘¥âˆ¨ğ‘¦+2 = ğœ¶ á´ ğ‘¥âˆ¨(ğ‘¦+2)
    ğœ¶ á´ ğ‘¥âˆ¨ğ‘¦â†’+2 = ğœ¶ á´ (ğ‘¥âˆ¨ğ‘¦)+2

    ğœ¶â‹…ğ‘¥âˆ¨ğ‘¦+2 = (ğœ¶â‹…ğ‘¥)âˆ¨ğ‘¦+2
    ğœ¶â‹…â†ğ‘¥âˆ¨ğ‘¦+2 = ğœ¶â‹…(ğ‘¥âˆ¨ğ‘¦+2)


    [f]â†’[g]â†’[h]â†’[m]â†[k]â†[l]â†’[p]
    (f)[g]â†’[h]â†’[m]â†[k]â†[l]â†’[p]
    ((f)(g))[h]â†’[m]â†[k]â†[l]â†’[p]





    # fâ¡gâ¡hâ¡mâ¬…kâ¬…lâ¡p
    # (((((((f)â¡g)â¡h)â¡m)â¬…k)â¬…l)â¡p)
    # ((((f)â¡g)â¡h)â¡m)â¬…(kâ¬…((l)â¡p))
    # (fâ¡gâ¡hâ¡ m â¬…kâ¬…l)â¡p

    [5|2â‹…3] â†’ [á´ğ‘¥|2] # Î±,Î²
    [5|2â‹…3] # Î±
        [[5]|[2â‹…3]] # spl Î± by op > 'â†’'ó°‚
        [[5]|] ; [2â‹…3] # *Î³,Î”
    Î³(Î”)Î²
    5|(2â‹…3)á´ğ‘¥|2

    [[5]|][[2+3] á´ğ‘¥] # Î± ((Î³) Î²)
    5 | ((2+3) á´ğ‘¥)


    5|2+3â†’á´ğ‘¥â†’Â²
    [5|2+3] â†’ [á´ğ‘¥â†’Â²]
    5 | ((2+3) [á´ğ‘¥â†’Â²])

    [á´[ğ‘¥]]
    [á´][ğ‘¥]
    [á´][[ğ‘¥]Â²]
    á´ ((ğ‘¥)Â²)

    5 | ((2+3) á´ ((ğ‘¥)Â²))

    1+2â‹…3-4

    1+2â‹…3-4
    1+[2â‹…3]-4

    1+2â‹…3-4

    a+bâŸ¶+c+d
    [a+b]âŸ¶[+c+d]
    ((a+b)âŸ¶+c)+d

    scan(n, l/r, f):
        

    1 â†’ [1] []
    +
        {2â‹…3-4}
        2
        â‹…
        3-4
        
        
    calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0

    ğŸŸ‘
    Â¿ x+2: yield y+2
    if x+2: yield y+2

    class Node:
        __slots__ = ('t', 'c')
        
        t = x Â¿ y > 2 Â¡ z
        
        âŠ¢ __init__(ğ•Š, t=á¦, c=á—œ):
            ğ•Š.t, ğ•Š.c = t, c or []
        
        âŠ¢ __eq__(ğ•Š, n):
            if á¹(n, á”):
                return ğ•Š.t == n
            assert n á¹ Node
            return ğ•Š.t == n.t and ğ•Š.c == n.c

    # whitespace stuff
    calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
    def p_indent_stack(S, n=0):
        r = []
        while S:
            indent, *exprs = S[0]
            if indent > n:
                r.append(p_indent_stack(S, indent))
            elif indent < n:
                break
            else:
                S.pop(0)
                r.extend(exprs)
        return Node("BLOCK", r)

    aÎ£b

    calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0
    âŠ¢ p_indent_stack(S, n=0):
        r = []
        â° S:
            indent, â ¤exprs = Sâ‚€
            Â¿ indent > n:
                r.append(p_indent_stack(S, indent))
            â¸˜ indent < n:
                break
            Â¡:
                S.pop(0)
                r.extend(exprs)
        â†ª Node("BLOCK", r)

    a
        b
            c
    d
        e
    f

    â‘¡xğŸƒŒâ†’+â†ğŸƒŒyâ†’â‹…2ó°…‚
    2+3

    2â‹…5 + (â‹…)

    Î³ = 2

    @cheese
    def hi():
        print(1)

    Î±Î£Î²

    # strings
    @generator("str_guts")
    def gen_str_guts     (n): return py_escape_string(n.txt)
    @generator("str_escape")
    def gen_str_escape   (n): return "'" + py_escape_string(n.txt[1:]) + "'"
    @generator("str_sub")
    def gen_str_sub      (n): return "{" + gen(n.C[1]) + "}"
    @generator("str_spec_char")
    def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
    @generator("special_str")
    def gen_special_str(n, *, r='"'):
        for c in n.c[1:-1]:
            match c.t:
                case "str_escape"   : r += py_escape_string(c.txt[1:])
                case "str_spec_char": r += py_special_mapper(c.txt)
                case _              : r += gen(c)
        return r + '"'


    hi [xd]
        2+2
        if 2:
            print
            â‘  xÂ² + 2


    if 1:
        print(2)
        asd
            egg
                    eg2
                eg3
    else:
        print(2)

    aî …
    aÊ¸

    if x
        print(1)
        asd
            asd
        ã€š print(1)
            2+x
        ã€›

    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

    aâ‹…b+câ‹…d

    2âˆª â† [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

    if x ã€š print(1) 
    asd ã€š asd ã€›
    ã€š print(1) ã€š 2x ã€› ã€› ã€›


    [+,-,/] Î¶ [1,2,3]
     Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1
    1 â†’ a

    â‘ (1)

    (0â€¦2]


    2 + â›
      5 + 2


    â€¹hiâ›ğ›â€º+â›ğ¬â‹„ğ˜€
    aÊ¸á¶» Ê¸zâ‚‚â‚ƒwâ‚‚
    â€¹really cheese ã€šxÂ²ã€›â€º
    1â†2â†3
    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚
    xâ‹…yâ†’+3
    1â†’2â†’3
    fâ†’gâ†’hâ†’mâ†kâ†lâ†’p

    1â†2â†3


    aâ¨‰bâˆ©câ¨‰d

    print(1)
    2+(5+2)
    2+3â†’â‹…2
    a âˆª ((b âˆª (c Î¶ d)) á´ (e âˆª f))
    1â€¦2âŒƒ3âŒƒ4âŒƒ5â€¦6

    5+2â†’âŸ¶âŸ¶+aâ‹…1âŸ¶+2

    if op.t in 'â†âŸ¶â†â†’ğŸ¡¸ğŸ¡º':
        j = ğ•Š.into_expr(collapse(res+[cur]))
        j.text = f"({j.text})"
        print("PARSING", [j] + stack)
        return ğ•Š.parse_exprs([j] + stack)

    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ âŸ¶ â˜¾ + 1

    2+3ó°…‚â‹…2
    (2+3)â‹…2
    (2+3)â‹…2

    ([+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚) âŸ¶ (â˜¾ + 1)

    aâŒƒbâŒƒ

    1 (â˜¾) 2


    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

    x("a").y

    op_maps á´â‘ xó°˜¬ğ˜€á´â‘ xó°›”â›ğ¬â‹„ğ˜€

    class Mapper_py(Mapper):
        def generate_gram_regexes(ğ•Š, op_names):
            rgx_keywords = rgx_or(py_kw.kwlist + py_kw.softkwlist)
            rgx_operator = rgx_or(flat([re.escape(c+'='), re.escape(c)] for c in op_names))
            rgx_specials = rgx_or([*"â„µğ•‹ğ”½Ã®Ï€Ï„â–¡âˆ…âˆá¦", "\\."*3])
            return {
                "OPERATORS": i_rgx_fmt(rgx_operator),
                "VAR_SPECIAL": i_rgx_fmt(rgx_specials),
                "KEYWORDS": i_rgx_fmt(f"({rgx_keywords})(\\Z|[^_a-zA-Z0-9])") }

    # actual operators
    # blocks
    # 

    # V,pr=0,lambda*a,**k:print(V*'#',*a,**k)
    # def A(*a,**k): global V ; V += 1 ; pr(*a,**k)
    # def B(*a,**k): global V ; pr(*a,**k) ; V -= 1

    (+)â‹„(-)â‹„(â‹…)

    class Mapper:
        SPECIALS = ...

    â˜¾Â´
    á´êœ áµœ

    Â¬1+1â‹…2/2!+1âŒƒ2âŒƒ3

    Â¿ 1>x>2:
        1+1â‹…2/2!+1âŒƒ2âŒƒ3
        â€¹hiâ›ğ›â€º
        x+(y+[] a b)*z

    class dasjiod:
        def asfmdiaf:
            daodasd

    class Mapper:
        SPECIALS = ...
        GRAM_FILE = ...
        OPERATOR_FILE = ...
        NODE_CLS = ...

    âŸ¥d
    ssssd

    ğš²1
    â‘ 1
    â‘¡1
    xâ†¦1
    â¥Œx,y,*aâ†¦2
    â¥Œx,y,*a,**kâ†¦2
    â¥Œx,y,*aâ†¦2
    â¥Œx,y,**kâ†¦2
    â¥Œaâ†¦2
    â¥Œ**,x,*â†¦2

    â¥Œ**k,x,yâ†¦2

    â˜¾Â´á´â†•10
    â˜¾á´â†•10

    Â¿ 1>x>2:
        1+1â‹…2/2!+1âŒƒ2âŒƒ3
        â€¹hiâ›ğ›â€ºÂ´
        x+(y+[] a b)*z

    os = "os" â¨¡
    os.system(â€¹echo ã€š2 5ã€›â€º)

    a b,c d

    î¬¦ asdijasd
    # dasd

    î¬¦ â­¥â¬â†¨

    5â†• Î¶ 5â†•á´™ á´ â‹…Â´ â†’ â˜¾
    fâ—‹f = f(f(â¬¤))
    10â­¥ á´ â˜¾Â´â—‹â›¶Â´
    fâˆ˜f = f(f)
    â¥ŒF,nâ†¦â‘ â‘¡â‘¡yâˆ˜xó°…‚ Å¿ xâ›¶+á´™Fó°…‚ Å¿ xâ›¶+0â›¶n
    0â€¦10 á´ â‘ xâŒƒ2ó°…‚ Î£ â†• ó°ˆ² â‘ x%2â‰¡1

    10â†• á´ â‹…êœ 
    î¬¦ normalize Â´
    î¬¦ duplicate input? êœ 
    î¬¦   Forces into binop
    î¬¦ swap? áµœ
    î¬¦ ? ê°âµ¯áµ”Ë†êœ›ğ´

    if ğ•‹:
        print(1)
    else dasd:
        dasd

    0â€¦10 á´ â‘ xâŒƒ2ó°…‚ Î£ â†• ó°ˆ² â‘ x%2â‰¡1
    0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚ â”‚Î£â”‚ â†• â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
    (0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†• â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
    ((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
    (((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1)
    ((((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£)â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1)







    ğŸŸ‘âŠ¢ parse(ğ·, ğ‘…, start_rule=â–¡):
        â„­, Ï‡ = ğ·ğŸƒŒ+1â†’â­¥á´ó°²¡{}, 0
        ğ“¢ = [(â–¡, ğ‘…ğŸƒŒ-1 Â¿start_ruleâ‰…â–¡Â¡ start_rule)]
        Ï‡ = 0
        â°ğ“¢:
            Î§, Î¹ = ğ“¢.pop(Â¯1)
            Â¿Î§â‰‡â–¡: Ï‡=Î§
            Î“ = Ï‡, Î¹
            Î³, â ¤ğ¶ = ğ‘…ó°ƒ¬
            ğ”  = â„­ó°ƒº
            match Î³:
                case â›á”:
                    Â¿ğ¶â‚€â‰¡ğ·ó°ƒºï¹•ôŠ¸´ôŠ®ó°ƒºâ‚ŠôŠ³µôŠ¬£ôŠ¹³: ğ” ó°ƒ¬ = âœ“, ğŒ
                    Â¡             : ğ” ó°ƒ¬ = âœ—, Ï‡
                case â›~:
                    Â¿mâ‰”ğ¶â‚€.match(ğ·, Ï‡):
                        ğ” ó°ƒ¬ = âœ“, Ï‡ + m.group(0)ğŸƒŒ, m
                    Â¡:  ğ” ó°ƒ¬ = âœ—, Ï‡
                case â›âˆ§:
                    n, ğŒ = ğ” ó°ƒ¬ Â¿Î¹âˆˆğ” Â¡ (0, Ï‡)
                    â°âœ“:
                        Â¿ğœ¾â‰”ğ¶â‚™ â†’âˆ‰â† ğ‘â‰”â„­ôŠ¸´:
                            ğ“¢.extend([Î“, (ğŒ, ğœ¾)])
                            ğ” ó°ƒ¬ = n, ğŒ ; â‡¥
                        ğ‘”, ğŒ = â„­ôŠ¸´ ôŠ¸§ ï¹•â‚‚
                        n += 1
                        Â¿    ğ‘”Â¬: ğ” ó°ƒ¬ = âœ—, Ï‡ ; â‡¥
                        Â¿n â‰¡ ğ¶ğŸƒŒ: ğ” ó°ƒ¬ = âœ“, ğŒ ; â‡¥
                case â›âˆ¨:
                    n = ğ” ó°ƒ¬ Â¿Î¹âˆˆğ” Â¡ 0
                    â°âœ“:
                        Â¿ğœ¾â‰”ğ¶â‚™ â†’âˆ‰â† ğ‘â‰”â„­ó°ƒº:
                            ğ“¢.extend([Î“, (Ï‡, ğœ¾)])
                            ğ” ó°ƒ¬ = n ; â‡¥
                        ğ‘”, ğŒ = â„­ó°ƒº ôŠ¸§ ï¹•â‚‚
                        Â¿    ğ‘” : ğ” ó°ƒ¬ = âœ“, ğŒ, n ; â‡¥
                        n += 1
                        Â¿n â‰¡ ğ¶ğŸƒŒ: ğ” ó°ƒ¬ = âœ—, Ï‡    ; â‡¥
                case â›*|â›+:
                    c = ğ” .setdefault(Î¹, [Ï‡])
                    ğœ¾, ğŒ = ğ¶â‚€, câ‚‹â‚
                    â°âœ“:
                        Â¿ğœ¾ â†’âˆ‰â† ğ‘â‰”â„­ôŠ¸´:
                            ğ“¢.extend([Î“, (ğŒ, ğœ¾)])
                            â‡¥
                        ğ‘”, Î§ = â„­ôŠ¸´ ôŠ¸§ ï¹•â‚‚
                        Â¿Â¬ğ‘”:
                            Â¿Î³â‰¡â›* âˆ¨ cğŸƒŒ>1:
                                ğ” ó°ƒ¬ = âœ“, ğŒ, cï¹•â‚‹â‚
                            Â¡:
                                ğ” ó°ƒ¬ = âœ—, Ï‡
                            â‡¥
                        c.append(ğŒâ‰”Î§)
                case â›âœ“: ğ” ó°ƒ¬ = âœ“, Ï‡
                case â›âœ—: âœ—â¨³â€¹Hit an âœ—â€º
                case â›â†:
                    Â¿ğ¶â‚âˆ‰ğ” :
                        ğ“¢.extend([Î“, (Ï‡, ğ¶â‚)])
                    Â¡:
                        ğ‘”, ğŒ = ğ” ôŠ³µôŠ¬¤ ï¹•â‚‚
                        ğ” ó°ƒ¬ = ğ‘”, ğŒ, ğ¶â‚
                case _:
                    Â¿ğ¶â‚€âˆ‰ğ” :
                        ğ“¢.extend([Î“, (Ï‡, ğ¶â‚€)])
                    Â¡:
                        ğ‘”, ğŒ = ğ” ôŠ³µôŠ¬£ ï¹•â‚‚
                        match Î³:
                            case â›â®: ğ” ó°ƒ¬ = ğ‘” , Ï‡
                            case â›Â¬: ğ” ó°ƒ¬ = ğ‘”Â¬, Ï‡
                            case â›â—: ğ” ó°ƒ¬ = ğ‘”â¨³, ğŒ
                            case â›?: ğ” ó°ƒ¬ = âœ“ , ğŒ, ğ‘”
                            case  _: ğ” ó°ƒ¬ = ğ‘” , ğŒ
        â†ª â„­ğŸŸ‘
