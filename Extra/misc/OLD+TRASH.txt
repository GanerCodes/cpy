
    ∧ ; and  ; x⭜   y   ⭝x     ; ⩓
    ∨ ; or   ; x⭜   x   ⭝y     ; ⩔
    󷺤 ; xor  ; x⭜(y⭜✗⭝x)⭝y     ; ∅
    󷺦 ; nxor ; x⭜(y⭜y⭝✗)⭝y⭜✗⭝✓ ; ∅
    󷺒 ; nand ; x⭜(y⭜✗⭝x)⭝y⭜y⭝✓ ; 󷺬
    󷺥 ; nor  ; x⭜   ✗   ⭝y⭜x⭝✓ ; 󷺫

    󰮈
     󰛔
       (ᔐ,ᔐ): ᔐ.replace
       (𝒾,𝑜):   replace ; 󰛔ʳ

    [1,2,3] 𝌂 𝌃

    [1,2,5,2,3] 𝌂ⁿ 𝑓
     10⭥ ᐵ²⦚       ⟶   10⭥ᴍ¹󰲡x²󰅂
       5 ᑀ²⦚       ⟶  (5,)ᴍ⁰󰲡x²󰅂
       5 ᑀ²+ᑅ 6    ⟶ (5,6)ꟿ⁰󰲣x²+y
       5 ᑀ²+⟞ᑅ⟤ 6  ⟶ (5,6)ꟿ⁰󰲣x²+y
       5 ᑀ²+⟞+ᑅ 6  ⟶ (5,6)ꟿ⁰󰲣x²+y
     10⭥ ᐵ²+⟝²⋅ᑅ 6 ⟶ 10⭥ᴍ¹⥌x,y=6↦x²+y²⋅y
     ᑀᐵ⟝ ⟞ᑈᑅ

    󰲣x󷸻y󰈳⟥ᑀ%2ᐸΣ0
    󰲣x󷸻y󰈳⟥ᑀ%2ᐸΣ0

    5 ᑀ²+⟞+ᑅ 6   ⟶ 5²+6+6
    5 ᑀ²+⟞ᑅ⦚ 6   ⟶ 5²+6
    5 ᑀ²⦚ +  6   ⟶ 5²+6
    (5 ᑀ²+⟝⦚)(6) ⟶ 5²+6
    (ᑀ²⦚)(5)     ⟶ 5²
    (ᑀ²+ᑅ)(5,6)  ⟶ 5²+6

     https://ganer.xyz/s/fe9261c4a271da3a

    ⥌a,b,c↦¯b±√(b²-4a⋅c) ᐵ/2a
    󰲥¯y±√(y²-4x⋅z)ᐵ/2x

     ⸠⸡⸾⸽?

    x 󱖔􊽺 y

     ⥌a,b,c↦¯b±√←b²-4a⋅c→/2a
     ⥌a,b,c↦¯b±√←b²-4a⋅cᴍ󰲡x/2a

    conjugate?

    FIX FONT THIGN
    󰋺 doesn't cache things so weird instance issues
    order arasol spray deodernt antiperaroas

    00 01 10 11
    0* *1 *0 1*
    ✓ ✗

    make replace operator support inserting lists in lists

    dynamic edit language grammar 👁
    activeparser.update(ℵ(
        oldrule=updatedrule,
        newrule=somenewrule,
        …
    ))

    "¿ f(blah) ⇒ bruh"

    ¿ | expr | call | expr | var | f
             | expr | var  | blah
      | expr | var  | bruh

    if_stmt = 󰆴"¿" expr 󰆴"⇒" expr
    if_stmt(󱁕):
        if 󱁕₀:
            return HIGH, 󱁕₁
        return LOW

    Bad spacing:
      Gal: "㏿" galois group
      hom: "ꖾ" category hom morphisms
       re: "โ" real part
       cx: "ใ" complex imaginary part

    op_maps ᴍ①x󰘬𝘀 ᴍ①x󰛔␛𝐬⋄𝘀

    dot = 𝚲𝔸⍉ᴍΠ´Σ

    # swag = ⥌f,n↦①②①②y(x)󰅂ſ|[x]+f﹕﹕₋₁󰅂(x)󰅂ſ|[x]+[0]n

    # x²➡[⊣+2,⊣²]➡⊣⨯2+⊢⬅√y
    # x²➡([⊣+2,⊣²]➡⊣⨯2+⊢⬅√y)
    # x²➡([⊣+2,⊣²]➡(⊣⨯2+⊢⬅√y))
    # ⟨x²⟩➡ ⟨[⊣+2,⊣²]⟩➡ (⊣⨯2+⊢ ⬅⟨√y⟩))

    # f➡g➡ h𐞁 ⬅k

    # f➡g➡h➡m⬅k⬅l➡p
    # (f➡g➡h➡ m ⬅k⬅l)➡p
    # (f➡g➡h➡ m ⬅k⬅l)➡p
    # d⬅f➡g➡h➡m⬅k⬅l➡p
    # (d⬅f)➡g➡h➡((m⬅k)⬅l)➡p
    # ((((d⬅f)➡g)➡h)➡((m⬅k)⬅l))➡p


    K = (①[☾(':',⠤x,sep='\n'),x]₁)
    # ①x-0⤉()
    gs = ③1…10∖∪(z,(z⍉)ₓ,⍉z₋₁﹕₊₂ ₓ₋₁﹕ₓ₊₂⍉Σ∅)
    sr = ④(z ₓ≔w)►nx(z)
    nx = z↦(K z¿□∉Σ(z))∨⁅⁅sr(x,y,K dcp𐞂⨯z,h)∀h∈gs(x,y,z)⁆∀x,y∈9↕|⨉|9↕¿¬z ₓ⁆
    nx([7⋄8⋄□⋄4⋄□⋄□⋄1⋄2⋄□,
        6⋄□⋄□⋄□⋄7⋄5⋄□⋄□⋄9,
        □⋄□⋄□⋄6⋄□⋄1⋄□⋄7⋄8,
        □⋄□⋄7⋄□⋄4⋄□⋄2⋄6⋄□,
        □⋄□⋄1⋄□⋄5⋄□⋄9⋄3⋄□,
        9⋄□⋄4⋄□⋄6⋄□⋄□⋄□⋄5,
        □⋄7⋄□⋄3⋄□⋄□⋄□⋄1⋄2,
        1⋄2⋄□⋄□⋄□⋄7⋄4⋄□⋄□,
        □⋄4⋄9⋄2⋄□⋄6⋄□⋄□⋄7])


    1⋄2 ζ 3⋄4 ſ ②x🃌→⌃←🃌y󰅂
    ((1⋄2) ζ (3⋄4)) ſ (②x🃌→⌃←🃌y󰅂)

    ②x🃌→⌃←🃌y󰅂 = ②(x🃌)⌃(🃌y)󰅂 = ②(🃌(x))⌃(🃌(y))󰅂
    ②x🃌→f←🃌y󰅂 = ②f(x🃌, 🃌y)󰅂 = ②f(🃌(x), 🃌(y))󰅂

    ‹A␛›C〚2+2〛D␛␛E␛𝗻F𝗻›
    ␛x 𝗻 ␛𝗻
    αdasβ
    "𝗻K\""+𝗻+␛𝗻
    〚([]⟨⟩)²[[]⁅⁆]〛〚2〛
    "hi" \a\b

    (
        hi
    )

    ① x²
    2
    ②x+y
    󰅂+1
    𝕋𝔽Σamong







    5|2+3→ᴍ𝑥
    5|(2+3)→ᴍ𝑥
    5|((2+3)→ᴍ𝑥)

    𝑥ᴍ←2+5|2
    𝑥ᴍ←(2+5)|2
    (𝑥ᴍ←(2+5))|2



    def swag_arrow(n, arrow, layers):
        spl_ops = reduce(lambda x,y:x|y, layers[:arrow.o])
        α, β = partition(ρ(𝕊.get_op, layer=is_this_arrow))
        if arrow.d == 'r':
            n = partition(β, ρ(𝕊.get_op, layer=spl_ops))
        if arrow.d == 'l':
            n = partition(α, ρ(𝕊.get_op, layer=spl_ops))

    𝜶 ᴍ 𝑥∨𝑦+2 = 𝜶 ᴍ 𝑥∨(𝑦+2)
    𝜶 ᴍ 𝑥∨𝑦→+2 = 𝜶 ᴍ (𝑥∨𝑦)+2

    𝜶⋅𝑥∨𝑦+2 = (𝜶⋅𝑥)∨𝑦+2
    𝜶⋅←𝑥∨𝑦+2 = 𝜶⋅(𝑥∨𝑦+2)


    [f]→[g]→[h]→[m]←[k]←[l]→[p]
    (f)[g]→[h]→[m]←[k]←[l]→[p]
    ((f)(g))[h]→[m]←[k]←[l]→[p]





    # f➡g➡h➡m⬅k⬅l➡p
    # (((((((f)➡g)➡h)➡m)⬅k)⬅l)➡p)
    # ((((f)➡g)➡h)➡m)⬅(k⬅((l)➡p))
    # (f➡g➡h➡ m ⬅k⬅l)➡p

    [5|2⋅3] → [ᴍ𝑥|2] # α,β
    [5|2⋅3] # α
        [[5]|[2⋅3]] # spl α by op > '→'󰂞
        [[5]|] ; [2⋅3] # *γ,Δ
    γ(Δ)β
    5|(2⋅3)ᴍ𝑥|2

    [[5]|][[2+3] ᴍ𝑥] # α ((γ) β)
    5 | ((2+3) ᴍ𝑥)


    5|2+3→ᴍ𝑥→²
    [5|2+3] → [ᴍ𝑥→²]
    5 | ((2+3) [ᴍ𝑥→²])

    [ᴍ[𝑥]]
    [ᴍ][𝑥]
    [ᴍ][[𝑥]²]
    ᴍ ((𝑥)²)

    5 | ((2+3) ᴍ ((𝑥)²))

    1+2⋅3-4

    1+2⋅3-4
    1+[2⋅3]-4

    1+2⋅3-4

    a+b⟶+c+d
    [a+b]⟶[+c+d]
    ((a+b)⟶+c)+d

    scan(n, l/r, f):
        

    1 → [1] []
    +
        {2⋅3-4}
        2
        ⋅
        3-4
        
        
    calc_indent = ⥌n ↦ nᵗ ≡ ␛W ∧ n.c.split('\n')₋₁.count(' ') // 4 ∨ 0

    🟑
    ¿ x+2: yield y+2
    if x+2: yield y+2

    class Node:
        __slots__ = ('t', 'c')
        
        t = x ¿ y > 2 ¡ z
        
        ⊢ __init__(𝕊, t=ᐦ, c=ᗜ):
            𝕊.t, 𝕊.c = t, c or []
        
        ⊢ __eq__(𝕊, n):
            if ᐹ(n, ᔐ):
                return 𝕊.t == n
            assert n ᐹ Node
            return 𝕊.t == n.t and 𝕊.c == n.c

    # whitespace stuff
    calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
    def p_indent_stack(S, n=0):
        r = []
        while S:
            indent, *exprs = S[0]
            if indent > n:
                r.append(p_indent_stack(S, indent))
            elif indent < n:
                break
            else:
                S.pop(0)
                r.extend(exprs)
        return Node("BLOCK", r)

    aΣb

    calc_indent = ⥌n ↦ nᵗ ≡ ␛W ∧ n.c.split('\n')₋₁.count(' ') // 4 ∨ 0
    ⊢ p_indent_stack(S, n=0):
        r = []
        ➰ S:
            indent, ⠤exprs = S₀
            ¿ indent > n:
                r.append(p_indent_stack(S, indent))
            ⸘ indent < n:
                break
            ¡:
                S.pop(0)
                r.extend(exprs)
        ↪ Node("BLOCK", r)

    a
        b
            c
    d
        e
    f

    ②x🃌→+←🃌y→⋅2󰅂
    2+3

    2⋅5 + (⋅)

    γ = 2

    @cheese
    def hi():
        print(1)

    αΣβ

    # strings
    @generator("str_guts")
    def gen_str_guts     (n): return py_escape_string(n.txt)
    @generator("str_escape")
    def gen_str_escape   (n): return "'" + py_escape_string(n.txt[1:]) + "'"
    @generator("str_sub")
    def gen_str_sub      (n): return "{" + gen(n.C[1]) + "}"
    @generator("str_spec_char")
    def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
    @generator("special_str")
    def gen_special_str(n, *, r='"'):
        for c in n.c[1:-1]:
            match c.t:
                case "str_escape"   : r += py_escape_string(c.txt[1:])
                case "str_spec_char": r += py_special_mapper(c.txt)
                case _              : r += gen(c)
        return r + '"'


    hi [xd]
        2+2
        if 2:
            print
            ① x² + 2


    if 1:
        print(2)
        asd
            egg
                    eg2
                eg3
    else:
        print(2)

    a
    aʸ

    if x
        print(1)
        asd
            asd
        〚 print(1)
            2+x
        〛

    [+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 → ☾ + 1

    a⋅b+c⋅d

    2∪ ← [+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 → ☾ + 1

    if x 〚 print(1) 
    asd 〚 asd 〛
    〚 print(1) 〚 2x 〛 〛 〛


    [+,-,/] ζ [1,2,3]
     ſ ②x(y)󰅂 → ☾ + 1
    1 → a

    ①(1)

    (0…2]


    2 + ␛
      5 + 2


    ‹hi␛𝐛›+␛𝐬⋄𝘀
    aʸᶻ ʸz₂₃w₂
    ‹really cheese 〚x²〛›
    1←2←3
    [+,-,/] ζ [1,2,3] ſ ②x(y)󰅂
    x⋅y→+3
    1→2→3
    f→g→h→m←k←l→p

    1←2←3


    a⨉b∩c⨉d

    print(1)
    2+(5+2)
    2+3→⋅2
    a ∪ ((b ∪ (c ζ d)) ᴍ (e ∪ f))
    1…2⌃3⌃4⌃5…6

    5+2→⟶⟶+a⋅1⟶+2

    if op.t in '←⟶←→🡸🡺':
        j = 𝕊.into_expr(collapse(res+[cur]))
        j.text = f"({j.text})"
        print("PARSING", [j] + stack)
        return 𝕊.parse_exprs([j] + stack)

    [+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 ⟶ ☾ + 1

    2+3󰅂⋅2
    (2+3)⋅2
    (2+3)⋅2

    ([+,-,/] ζ [1,2,3] ſ ②x(y)󰅂) ⟶ (☾ + 1)

    a⌃b⌃

    1 (☾) 2


    [+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 → ☾ + 1

    x("a").y

    op_maps ᴍ①x󰘬𝘀ᴍ①x󰛔␛𝐬⋄𝘀

    class Mapper_py(Mapper):
        def generate_gram_regexes(𝕊, op_names):
            rgx_keywords = rgx_or(py_kw.kwlist + py_kw.softkwlist)
            rgx_operator = rgx_or(flat([re.escape(c+'='), re.escape(c)] for c in op_names))
            rgx_specials = rgx_or([*"ℵ𝕋𝔽îπτ□∅∞ᐦ", "\\."*3])
            return {
                "OPERATORS": i_rgx_fmt(rgx_operator),
                "VAR_SPECIAL": i_rgx_fmt(rgx_specials),
                "KEYWORDS": i_rgx_fmt(f"({rgx_keywords})(\\Z|[^_a-zA-Z0-9])") }

    # actual operators
    # blocks
    # 

    # V,pr=0,lambda*a,**k:print(V*'#',*a,**k)
    # def A(*a,**k): global V ; V += 1 ; pr(*a,**k)
    # def B(*a,**k): global V ; pr(*a,**k) ; V -= 1

    (+)⋄(-)⋄(⋅)

    class Mapper:
        SPECIALS = ...

    ☾´
    ᴍ꜠ᵜ

    ¬1+1⋅2/2!+1⌃2⌃3

    ¿ 1>x>2:
        1+1⋅2/2!+1⌃2⌃3
        ‹hi␛𝐛›
        x+(y+[] a b)*z

    class dasjiod:
        def asfmdiaf:
            daodasd

    class Mapper:
        SPECIALS = ...
        GRAM_FILE = ...
        OPERATOR_FILE = ...
        NODE_CLS = ...

    ⟥d
    ssssd

    𝚲1
    ①1
    ②1
    x↦1
    ⥌x,y,*a↦2
    ⥌x,y,*a,**k↦2
    ⥌x,y,*a↦2
    ⥌x,y,**k↦2
    ⥌a↦2
    ⥌**,x,*↦2

    ⥌**k,x,y↦2

    ☾´ᴍ↕10
    ☾ᴍ↕10

    ¿ 1>x>2:
        1+1⋅2/2!+1⌃2⌃3
        ‹hi␛𝐛›´
        x+(y+[] a b)*z

    os = "os" ⨡
    os.system(‹echo 〚2 5〛›)

    a b,c d

     asdijasd
    # dasd

     ⭥⬍↨

    5↕ ζ 5↕ᴙ ᴍ ⋅´ → ☾
    f○f = f(f(⬤))
    10⭥ ᴍ ☾´○⛶´
    f∘f = f(f)
    ⥌F,n↦①②②y∘x󰅂 ſ x⛶+ᴙF󰅂 ſ x⛶+0⛶n
    0…10 ᴍ ①x⌃2󰅂 Σ ↕ 󰈲 ①x%2≡1

    10↕ ᴍ ⋅꜠
     normalize ´
     duplicate input? ꜠
       Forces into binop
     swap? ᵜ
     ? ꝰⵯᵔˆꜛ𐞴

    if 𝕋:
        print(1)
    else dasd:
        dasd

    0…10 ᴍ ①x⌃2󰅂 Σ ↕ 󰈲 ①x%2≡1
    0…10 │ᴍ│ ①x⌃2󰅂 │Σ│ ↕ │󰈲│ ①x%2≡1
    (0…10 │ᴍ│ ①x⌃2󰅂) │Σ│ ↕ │󰈲│ ①x%2≡1
    ((0…10 │ᴍ│ ①x⌃2󰅂) │Σ│ ↕) │󰈲│ ①x%2≡1
    (((0…10 │ᴍ│ ①x⌃2󰅂) │Σ│ ↕) │󰈲│ ①x%2≡1)
    ((((0…10 │ᴍ│ ①x⌃2󰅂) │Σ)│ ↕) │󰈲│ ①x%2≡1)







    🟑⊢ parse(𝐷, 𝑅, start_rule=□):
        ℭ, χ = 𝐷🃌+1→⭥ᴍ󰲡{}, 0
        𝓢 = [(□, 𝑅🃌-1 ¿start_rule≅□¡ start_rule)]
        χ = 0
        ➰𝓢:
            Χ, ι = 𝓢.pop(¯1)
            ¿Χ≇□: χ=Χ
            Γ = χ, ι
            γ, ⠤𝐶 = 𝑅󰃬
            𝔠 = ℭ󰃺
            match γ:
                case ␛ᔐ:
                    ¿𝐶₀≡𝐷󰃺﹕􊸴􊮝󰃺₊􊳵􊬣􊹳: 𝔠󰃬 = ✓, 𝝌
                    ¡             : 𝔠󰃬 = ✗, χ
                case ␛~:
                    ¿m≔𝐶₀.match(𝐷, χ):
                        𝔠󰃬 = ✓, χ + m.group(0)🃌, m
                    ¡:  𝔠󰃬 = ✗, χ
                case ␛∧:
                    n, 𝝌 = 𝔠󰃬 ¿ι∈𝔠¡ (0, χ)
                    ➰✓:
                        ¿𝜾≔𝐶ₙ →∉← 𝑐≔ℭ􊸴:
                            𝓢.extend([Γ, (𝝌, 𝜾)])
                            𝔠󰃬 = n, 𝝌 ; ⇥
                        𝑔, 𝝌 = ℭ􊸴 􊸧 ﹕₂
                        n += 1
                        ¿    𝑔¬: 𝔠󰃬 = ✗, χ ; ⇥
                        ¿n ≡ 𝐶🃌: 𝔠󰃬 = ✓, 𝝌 ; ⇥
                case ␛∨:
                    n = 𝔠󰃬 ¿ι∈𝔠¡ 0
                    ➰✓:
                        ¿𝜾≔𝐶ₙ →∉← 𝑐≔ℭ󰃺:
                            𝓢.extend([Γ, (χ, 𝜾)])
                            𝔠󰃬 = n ; ⇥
                        𝑔, 𝝌 = ℭ󰃺 􊸧 ﹕₂
                        ¿    𝑔 : 𝔠󰃬 = ✓, 𝝌, n ; ⇥
                        n += 1
                        ¿n ≡ 𝐶🃌: 𝔠󰃬 = ✗, χ    ; ⇥
                case ␛*|␛+:
                    c = 𝔠.setdefault(ι, [χ])
                    𝜾, 𝝌 = 𝐶₀, c₋₁
                    ➰✓:
                        ¿𝜾 →∉← 𝑐≔ℭ􊸴:
                            𝓢.extend([Γ, (𝝌, 𝜾)])
                            ⇥
                        𝑔, Χ = ℭ􊸴 􊸧 ﹕₂
                        ¿¬𝑔:
                            ¿γ≡␛* ∨ c🃌>1:
                                𝔠󰃬 = ✓, 𝝌, c﹕₋₁
                            ¡:
                                𝔠󰃬 = ✗, χ
                            ⇥
                        c.append(𝝌≔Χ)
                case ␛✓: 𝔠󰃬 = ✓, χ
                case ␛✗: ✗⨳‹Hit an ✗›
                case ␛←:
                    ¿𝐶₁∉𝔠:
                        𝓢.extend([Γ, (χ, 𝐶₁)])
                    ¡:
                        𝑔, 𝝌 = 𝔠􊳵􊬤 ﹕₂
                        𝔠󰃬 = 𝑔, 𝝌, 𝐶₁
                case _:
                    ¿𝐶₀∉𝔠:
                        𝓢.extend([Γ, (χ, 𝐶₀)])
                    ¡:
                        𝑔, 𝝌 = 𝔠􊳵􊬣 ﹕₂
                        match γ:
                            case ␛⮞: 𝔠󰃬 = 𝑔 , χ
                            case ␛¬: 𝔠󰃬 = 𝑔¬, χ
                            case ␛❗: 𝔠󰃬 = 𝑔⨳, 𝝌
                            case ␛?: 𝔠󰃬 = ✓ , 𝝌, 𝑔
                            case  _: 𝔠󰃬 = 𝑔 , 𝝌
        ↪ ℭ🟑
