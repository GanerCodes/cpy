
    âˆ§ ; and  ; xâ­œ   y   â­x     ; â©“
    âˆ¨ ; or   ; xâ­œ   x   â­y     ; â©”
    ó·º¤ ; xor  ; xâ­œ(yâ­œâœ—â­x)â­y     ; âˆ…
    ó·º¦ ; nxor ; xâ­œ(yâ­œyâ­âœ—)â­yâ­œâœ—â­âœ“ ; âˆ…
    ó·º’ ; nand ; xâ­œ(yâ­œâœ—â­x)â­yâ­œyâ­âœ“ ; ó·º¬
    ó·º¥ ; nor  ; xâ­œ   âœ—   â­yâ­œxâ­âœ“ ; ó·º«

    ó°®ˆ
    î¬¦ ó°›”
    î¬¦   (á”,á”): á”.replace
    î¬¦   (ğ’¾,ğ‘œ):   replace ; ó°›”Ê³

    [1,2,3] ğŒ‚ ğŒƒ

    [1,2,5,2,3] ğŒ‚â¿ ğ‘“
    î¬¦ 10â­¥ áµÂ²â¦š       âŸ¶   10â­¥á´Â¹ó°²¡xÂ²ó°…‚
    î¬¦   5 á‘€Â²â¦š       âŸ¶  (5,)á´â°ó°²¡xÂ²ó°…‚
    î¬¦   5 á‘€Â²+á‘… 6    âŸ¶ (5,6)êŸ¿â°ó°²£xÂ²+y
    î¬¦   5 á‘€Â²+âŸá‘…âŸ¤ 6  âŸ¶ (5,6)êŸ¿â°ó°²£xÂ²+y
    î¬¦   5 á‘€Â²+âŸ+á‘… 6  âŸ¶ (5,6)êŸ¿â°ó°²£xÂ²+y
    î¬¦ 10â­¥ áµÂ²+âŸÂ²â‹…á‘… 6 âŸ¶ 10â­¥á´Â¹â¥Œx,y=6â†¦xÂ²+yÂ²â‹…y
    î¬¦ á‘€áµâŸ âŸá‘ˆá‘…

    ó°²£xó·¸»yó°ˆ³âŸ¥á‘€%2á¸Î£0
    ó°²£xó·¸»yó°ˆ³âŸ¥á‘€%2á¸Î£0

    5 á‘€Â²+âŸ+á‘… 6   âŸ¶ 5Â²+6+6
    5 á‘€Â²+âŸá‘…â¦š 6   âŸ¶ 5Â²+6
    5 á‘€Â²â¦š +  6   âŸ¶ 5Â²+6
    (5 á‘€Â²+âŸâ¦š)(6) âŸ¶ 5Â²+6
    (á‘€Â²â¦š)(5)     âŸ¶ 5Â²
    (á‘€Â²+á‘…)(5,6)  âŸ¶ 5Â²+6

    î¬¦ https://ganer.xyz/s/fe9261c4a271da3a

    â¥Œa,b,câ†¦Â¯bÂ±âˆš(bÂ²-4aâ‹…c) áµ/2a
    ó°²¥Â¯yÂ±âˆš(yÂ²-4xâ‹…z)áµ/2x

    î¬¦ â¸ â¸¡â¸¾â¸½?

    x ó±–”ôŠ½º y

    î¬¦ â¥Œa,b,câ†¦Â¯bÂ±âˆšâ†bÂ²-4aâ‹…câ†’/2a
    î¬¦ â¥Œa,b,câ†¦Â¯bÂ±âˆšâ†bÂ²-4aâ‹…cá´ó°²¡x/2a

    conjugate?

    FIX FONT THIGN
    ó°‹º doesn't cache things so weird instance issues
    order arasol spray deodernt antiperaroas

    00 01 10 11
    0* *1 *0 1*
    âœ“ âœ—

    make replace operator support inserting lists in lists

    dynamic edit language grammar ğŸ‘
    activeparser.update(â„µ(
        oldrule=updatedrule,
        newrule=somenewrule,
        â€¦
    ))

    "Â¿ f(blah) â‡’ bruh"

    Â¿ | expr | call | expr | var | f
             | expr | var  | blah
      | expr | var  | bruh

    if_stmt = ó°†´"Â¿" expr ó°†´"â‡’" expr
    if_stmt(ó±•):
        if ó±•â‚€î®¦:
            return HIGH, ó±•â‚î®¦
        return LOW

    Bad spacing:
      Gal: "ã¿" galois group
      hom: "ê–¾" category hom morphisms
       re: "à¹‚" real part
       cx: "à¹ƒ" complex imaginary part

    op_maps á´â‘ xó°˜¬ğ˜€ á´â‘ xó°›”â›ğ¬â‹„ğ˜€

    dot = ğš²ğ”¸â‰á´Î Â´Î£

    # swag = â¥Œf,nâ†¦â‘ â‘¡â‘ â‘¡y(x)ó°…‚Å¿|[x]+fï¹•ï¹•â‚‹â‚ó°…‚(x)ó°…‚Å¿|[x]+[0]n

    # xÂ²â¡[âŠ£+2,âŠ£Â²]â¡âŠ£â¨¯2+âŠ¢â¬…âˆšy
    # xÂ²â¡([âŠ£+2,âŠ£Â²]â¡âŠ£â¨¯2+âŠ¢â¬…âˆšy)
    # xÂ²â¡([âŠ£+2,âŠ£Â²]â¡(âŠ£â¨¯2+âŠ¢â¬…âˆšy))
    # âŸ¨xÂ²âŸ©â¡ âŸ¨[âŠ£+2,âŠ£Â²]âŸ©â¡ (âŠ£â¨¯2+âŠ¢ â¬…âŸ¨âˆšyâŸ©))

    # fâ¡gâ¡ hğ â¬…k

    # fâ¡gâ¡hâ¡mâ¬…kâ¬…lâ¡p
    # (fâ¡gâ¡hâ¡ m â¬…kâ¬…l)â¡p
    # (fâ¡gâ¡hâ¡ m â¬…kâ¬…l)â¡p
    # dâ¬…fâ¡gâ¡hâ¡mâ¬…kâ¬…lâ¡p
    # (dâ¬…f)â¡gâ¡hâ¡((mâ¬…k)â¬…l)â¡p
    # ((((dâ¬…f)â¡g)â¡h)â¡((mâ¬…k)â¬…l))â¡p


    K = (â‘ [â˜¾(':',â ¤x,sep='\n'),x]â‚)
    # â‘ x-0â¤‰()
    gs = â‘¢1â€¦10âˆ–âˆª(zî “,(zâ‰)â‚“,â‰zî “â‚‹â‚ï¹•î “â‚Šâ‚‚ â‚“â‚‹â‚ï¹•â‚“â‚Šâ‚‚â‰Î£âˆ…)
    sr = â‘£(zî “ â‚“â‰”w)â–ºnx(z)
    nx = zâ†¦(K zÂ¿â–¡âˆ‰Î£(z))âˆ¨â…â…sr(x,y,K dcpğ‚â¨¯z,h)âˆ€hâˆˆgs(x,y,z)â†âˆ€x,yâˆˆ9â†•|â¨‰|9â†•Â¿Â¬zî “ â‚“â†
    nx([7â‹„8â‹„â–¡â‹„4â‹„â–¡â‹„â–¡â‹„1â‹„2â‹„â–¡,
        6â‹„â–¡â‹„â–¡â‹„â–¡â‹„7â‹„5â‹„â–¡â‹„â–¡â‹„9,
        â–¡â‹„â–¡â‹„â–¡â‹„6â‹„â–¡â‹„1â‹„â–¡â‹„7â‹„8,
        â–¡â‹„â–¡â‹„7â‹„â–¡â‹„4â‹„â–¡â‹„2â‹„6â‹„â–¡,
        â–¡â‹„â–¡â‹„1â‹„â–¡â‹„5â‹„â–¡â‹„9â‹„3â‹„â–¡,
        9â‹„â–¡â‹„4â‹„â–¡â‹„6â‹„â–¡â‹„â–¡â‹„â–¡â‹„5,
        â–¡â‹„7â‹„â–¡â‹„3â‹„â–¡â‹„â–¡â‹„â–¡â‹„1â‹„2,
        1â‹„2â‹„â–¡â‹„â–¡â‹„â–¡â‹„7â‹„4â‹„â–¡â‹„â–¡,
        â–¡â‹„4â‹„9â‹„2â‹„â–¡â‹„6â‹„â–¡â‹„â–¡â‹„7])


    1â‹„2 Î¶ 3â‹„4 Å¿ â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚
    ((1â‹„2) Î¶ (3â‹„4)) Å¿ (â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚)

    â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚ = â‘¡(xğŸƒŒ)âŒƒ(ğŸƒŒy)ó°…‚ = â‘¡(ğŸƒŒ(x))âŒƒ(ğŸƒŒ(y))ó°…‚
    â‘¡xğŸƒŒâ†’fâ†ğŸƒŒyó°…‚ = â‘¡f(xğŸƒŒ, ğŸƒŒy)ó°…‚ = â‘¡f(ğŸƒŒ(x), ğŸƒŒ(y))ó°…‚

    â€¹Aâ›â€ºCã€š2+2ã€›Dâ›â›Eâ›ğ—»Fğ—»â€º
    â›x ğ—» â›ğ—»
    Î±dasÎ²
    "ğ—»K\""+ğ—»+â›ğ—»
    ã€š([]âŸ¨âŸ©)Â²[[]â…â†]ã€›ã€š2ã€›
    "hi" \a\b

    (
        hi
    )

    â‘  xÂ²
    2
    â‘¡x+y
    ó°…‚+1
    ğ•‹ğ”½Î£among







    5|2+3â†’á´ğ‘¥
    5|(2+3)â†’á´ğ‘¥
    5|((2+3)â†’á´ğ‘¥)

    ğ‘¥á´â†2+5|2
    ğ‘¥á´â†(2+5)|2
    (ğ‘¥á´â†(2+5))|2



    def swag_arrow(n, arrow, layers):
        spl_ops = reduce(lambda x,y:x|y, layers[:arrow.o])
        Î±, Î² = partition(Ï(ğ•Š.get_op, layer=is_this_arrow))
        if arrow.d == 'r':
            n = partition(Î², Ï(ğ•Š.get_op, layer=spl_ops))
        if arrow.d == 'l':
            n = partition(Î±, Ï(ğ•Š.get_op, layer=spl_ops))

    ğœ¶ á´ ğ‘¥âˆ¨ğ‘¦+2 = ğœ¶ á´ ğ‘¥âˆ¨(ğ‘¦+2)
    ğœ¶ á´ ğ‘¥âˆ¨ğ‘¦â†’+2 = ğœ¶ á´ (ğ‘¥âˆ¨ğ‘¦)+2

    ğœ¶â‹…ğ‘¥âˆ¨ğ‘¦+2 = (ğœ¶â‹…ğ‘¥)âˆ¨ğ‘¦+2
    ğœ¶â‹…â†ğ‘¥âˆ¨ğ‘¦+2 = ğœ¶â‹…(ğ‘¥âˆ¨ğ‘¦+2)


    [f]â†’[g]â†’[h]â†’[m]â†[k]â†[l]â†’[p]
    (f)[g]â†’[h]â†’[m]â†[k]â†[l]â†’[p]
    ((f)(g))[h]â†’[m]â†[k]â†[l]â†’[p]





    # fâ¡gâ¡hâ¡mâ¬…kâ¬…lâ¡p
    # (((((((f)â¡g)â¡h)â¡m)â¬…k)â¬…l)â¡p)
    # ((((f)â¡g)â¡h)â¡m)â¬…(kâ¬…((l)â¡p))
    # (fâ¡gâ¡hâ¡ m â¬…kâ¬…l)â¡p

    [5|2â‹…3] â†’ [á´ğ‘¥|2] # Î±,Î²
    [5|2â‹…3] # Î±
        [[5]|[2â‹…3]] # spl Î± by op > 'â†’'ó°‚
        [[5]|] ; [2â‹…3] # *Î³,Î”
    Î³(Î”)Î²
    5|(2â‹…3)á´ğ‘¥|2

    [[5]|][[2+3] á´ğ‘¥] # Î± ((Î³) Î²)
    5 | ((2+3) á´ğ‘¥)


    5|2+3â†’á´ğ‘¥â†’Â²
    [5|2+3] â†’ [á´ğ‘¥â†’Â²]
    5 | ((2+3) [á´ğ‘¥â†’Â²])

    [á´[ğ‘¥]]
    [á´][ğ‘¥]
    [á´][[ğ‘¥]Â²]
    á´ ((ğ‘¥)Â²)

    5 | ((2+3) á´ ((ğ‘¥)Â²))

    1+2â‹…3-4

    1+2â‹…3-4
    1+[2â‹…3]-4

    1+2â‹…3-4

    a+bâŸ¶+c+d
    [a+b]âŸ¶[+c+d]
    ((a+b)âŸ¶+c)+d

    scan(n, l/r, f):
        

    1 â†’ [1] []
    +
        {2â‹…3-4}
        2
        â‹…
        3-4
        
        
    calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0

    ğŸŸ‘
    Â¿ x+2: yield y+2
    if x+2: yield y+2

    class Node:
        __slots__ = ('t', 'c')
        
        t = x Â¿ y > 2 Â¡ z
        
        âŠ¢ __init__(ğ•Š, t=á¦, c=á—œ):
            ğ•Š.t, ğ•Š.c = t, c or []
        
        âŠ¢ __eq__(ğ•Š, n):
            if á¹(n, á”):
                return ğ•Š.t == n
            assert n á¹ Node
            return ğ•Š.t == n.t and ğ•Š.c == n.c

    # whitespace stuff
    calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
    def p_indent_stack(S, n=0):
        r = []
        while S:
            indent, *exprs = S[0]
            if indent > n:
                r.append(p_indent_stack(S, indent))
            elif indent < n:
                break
            else:
                S.pop(0)
                r.extend(exprs)
        return Node("BLOCK", r)

    aÎ£b

    calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0
    âŠ¢ p_indent_stack(S, n=0):
        r = []
        â° S:
            indent, â ¤exprs = Sâ‚€
            Â¿ indent > n:
                r.append(p_indent_stack(S, indent))
            â¸˜ indent < n:
                break
            Â¡:
                S.pop(0)
                r.extend(exprs)
        â†ª Node("BLOCK", r)

    a
        b
            c
    d
        e
    f

    â‘¡xğŸƒŒâ†’+â†ğŸƒŒyâ†’â‹…2ó°…‚
    2+3

    2â‹…5 + (â‹…)

    Î³ = 2

    @cheese
    def hi():
        print(1)

    Î±Î£Î²

    # strings
    @generator("str_guts")
    def gen_str_guts     (n): return py_escape_string(n.txt)
    @generator("str_escape")
    def gen_str_escape   (n): return "'" + py_escape_string(n.txt[1:]) + "'"
    @generator("str_sub")
    def gen_str_sub      (n): return "{" + gen(n.C[1]) + "}"
    @generator("str_spec_char")
    def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
    @generator("special_str")
    def gen_special_str(n, *, r='"'):
        for c in n.c[1:-1]:
            match c.t:
                case "str_escape"   : r += py_escape_string(c.txt[1:])
                case "str_spec_char": r += py_special_mapper(c.txt)
                case _              : r += gen(c)
        return r + '"'


    hi [xd]
        2+2
        if 2:
            print
            â‘  xÂ² + 2


    if 1:
        print(2)
        asd
            egg
                    eg2
                eg3
    else:
        print(2)

    aî …
    aÊ¸

    if x
        print(1)
        asd
            asd
        ã€š print(1)
            2+x
        ã€›

    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

    aâ‹…b+câ‹…d

    2âˆª â† [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

    if x ã€š print(1) 
    asd ã€š asd ã€›
    ã€š print(1) ã€š 2x ã€› ã€› ã€›


    [+,-,/] Î¶ [1,2,3]
     Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1
    1 â†’ a

    â‘ (1)

    (0â€¦2]


    2 + â›
      5 + 2


    â€¹hiâ›ğ›â€º+â›ğ¬â‹„ğ˜€
    aÊ¸á¶» Ê¸zâ‚‚â‚ƒwâ‚‚
    â€¹really cheese ã€šxÂ²ã€›â€º
    1â†2â†3
    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚
    xâ‹…yâ†’+3
    1â†’2â†’3
    fâ†’gâ†’hâ†’mâ†kâ†lâ†’p

    1â†2â†3


    aâ¨‰bâˆ©câ¨‰d

    print(1)
    2+(5+2)
    2+3â†’â‹…2
    a âˆª ((b âˆª (c Î¶ d)) á´ (e âˆª f))
    1â€¦2âŒƒ3âŒƒ4âŒƒ5â€¦6

    5+2â†’âŸ¶âŸ¶+aâ‹…1âŸ¶+2

    if op.t in 'â†âŸ¶â†â†’ğŸ¡¸ğŸ¡º':
        j = ğ•Š.into_expr(collapse(res+[cur]))
        j.text = f"({j.text})"
        print("PARSING", [j] + stack)
        return ğ•Š.parse_exprs([j] + stack)

    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ âŸ¶ â˜¾ + 1

    2+3ó°…‚â‹…2
    (2+3)â‹…2
    (2+3)â‹…2

    ([+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚) âŸ¶ (â˜¾ + 1)

    aâŒƒbâŒƒ

    1 (â˜¾) 2


    [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

    x("a").y

    op_maps á´â‘ xó°˜¬ğ˜€á´â‘ xó°›”â›ğ¬â‹„ğ˜€

    class Mapper_py(Mapper):
        def generate_gram_regexes(ğ•Š, op_names):
            rgx_keywords = rgx_or(py_kw.kwlist + py_kw.softkwlist)
            rgx_operator = rgx_or(flat([re.escape(c+'='), re.escape(c)] for c in op_names))
            rgx_specials = rgx_or([*"â„µğ•‹ğ”½Ã®Ï€Ï„â–¡âˆ…âˆá¦", "\\."*3])
            return {
                "OPERATORS": i_rgx_fmt(rgx_operator),
                "VAR_SPECIAL": i_rgx_fmt(rgx_specials),
                "KEYWORDS": i_rgx_fmt(f"({rgx_keywords})(\\Z|[^_a-zA-Z0-9])") }

    # actual operators
    # blocks
    # 

    # V,pr=0,lambda*a,**k:print(V*'#',*a,**k)
    # def A(*a,**k): global V ; V += 1 ; pr(*a,**k)
    # def B(*a,**k): global V ; pr(*a,**k) ; V -= 1

    (+)â‹„(-)â‹„(â‹…)

    class Mapper:
        SPECIALS = ...

    â˜¾Â´
    á´êœ áµœ

    Â¬1+1â‹…2/2!+1âŒƒ2âŒƒ3

    Â¿ 1>x>2:
        1+1â‹…2/2!+1âŒƒ2âŒƒ3
        â€¹hiâ›ğ›â€º
        x+(y+[] a b)*z

    class dasjiod:
        def asfmdiaf:
            daodasd

    class Mapper:
        SPECIALS = ...
        GRAM_FILE = ...
        OPERATOR_FILE = ...
        NODE_CLS = ...

    âŸ¥d
    ssssd

    ğš²1
    â‘ 1
    â‘¡1
    xâ†¦1
    â¥Œx,y,*aâ†¦2
    â¥Œx,y,*a,**kâ†¦2
    â¥Œx,y,*aâ†¦2
    â¥Œx,y,**kâ†¦2
    â¥Œaâ†¦2
    â¥Œ**,x,*â†¦2

    â¥Œ**k,x,yâ†¦2

    â˜¾Â´á´â†•10
    â˜¾á´â†•10

    Â¿ 1>x>2:
        1+1â‹…2/2!+1âŒƒ2âŒƒ3
        â€¹hiâ›ğ›â€ºÂ´
        x+(y+[] a b)*z

    os = "os" â¨¡
    os.system(â€¹echo ã€š2 5ã€›â€º)

    a b,c d

    î¬¦ asdijasd
    # dasd

    î¬¦ â­¥â¬â†¨

    5â†• Î¶ 5â†•á´™ á´ â‹…Â´ â†’ â˜¾
    fâ—‹f = f(f(â¬¤))
    10â­¥ á´ â˜¾Â´â—‹â›¶Â´
    fâˆ˜f = f(f)
    â¥ŒF,nâ†¦â‘ â‘¡â‘¡yâˆ˜xó°…‚ Å¿ xâ›¶+á´™Fó°…‚ Å¿ xâ›¶+0â›¶n
    0â€¦10 á´ â‘ xâŒƒ2ó°…‚ Î£ â†• ó°ˆ² â‘ x%2â‰¡1

    10â†• á´ â‹…êœ 
    î¬¦ normalize Â´
    î¬¦ duplicate input? êœ 
    î¬¦   Forces into binop
    î¬¦ swap? áµœ
    î¬¦ ? ê°âµ¯áµ”Ë†êœ›ğ´

    if ğ•‹:
        print(1)
    else dasd:
        dasd

    0â€¦10 á´ â‘ xâŒƒ2ó°…‚ Î£ â†• ó°ˆ² â‘ x%2â‰¡1
    0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚ â”‚Î£â”‚ â†• â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
    (0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†• â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
    ((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
    (((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1)
    ((((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£)â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1)







    ğŸŸ‘âŠ¢ parse(ğ·, ğ‘…, start_rule=â–¡):
        â„­, Ï‡ = ğ·ğŸƒŒ+1â†’â­¥á´ó°²¡{}, 0
        ğ“¢ = [(â–¡, ğ‘…ğŸƒŒ-1 Â¿start_ruleâ‰…â–¡Â¡ start_rule)]
        Ï‡ = 0
        â°ğ“¢:
            Î§, Î¹ = ğ“¢.pop(Â¯1)
            Â¿Î§â‰‡â–¡: Ï‡=Î§
            Î“ = Ï‡, Î¹
            Î³, â ¤ğ¶ = ğ‘…ó°ƒ¬
            ğ”  = â„­ó°ƒº
            match Î³:
                case â›á”:
                    Â¿ğ¶â‚€â‰¡ğ·ó°ƒºï¹•ôŠ¸´ôŠ®ó°ƒºâ‚ŠôŠ³µôŠ¬£ôŠ¹³: ğ” ó°ƒ¬ = âœ“, ğŒ
                    Â¡             : ğ” ó°ƒ¬ = âœ—, Ï‡
                case â›~:
                    Â¿mâ‰”ğ¶â‚€.match(ğ·, Ï‡):
                        ğ” ó°ƒ¬ = âœ“, Ï‡ + m.group(0)ğŸƒŒ, m
                    Â¡:  ğ” ó°ƒ¬ = âœ—, Ï‡
                case â›âˆ§:
                    n, ğŒ = ğ” ó°ƒ¬ Â¿Î¹âˆˆğ” Â¡ (0, Ï‡)
                    â°âœ“:
                        Â¿ğœ¾â‰”ğ¶â‚™ â†’âˆ‰â† ğ‘â‰”â„­ôŠ¸´:
                            ğ“¢.extend([Î“, (ğŒ, ğœ¾)])
                            ğ” ó°ƒ¬ = n, ğŒ ; â‡¥
                        ğ‘”, ğŒ = â„­ôŠ¸´ ôŠ¸§ ï¹•â‚‚
                        n += 1
                        Â¿    ğ‘”Â¬: ğ” ó°ƒ¬ = âœ—, Ï‡ ; â‡¥
                        Â¿n â‰¡ ğ¶ğŸƒŒ: ğ” ó°ƒ¬ = âœ“, ğŒ ; â‡¥
                case â›âˆ¨:
                    n = ğ” ó°ƒ¬ Â¿Î¹âˆˆğ” Â¡ 0
                    â°âœ“:
                        Â¿ğœ¾â‰”ğ¶â‚™ â†’âˆ‰â† ğ‘â‰”â„­ó°ƒº:
                            ğ“¢.extend([Î“, (Ï‡, ğœ¾)])
                            ğ” ó°ƒ¬ = n ; â‡¥
                        ğ‘”, ğŒ = â„­ó°ƒº ôŠ¸§ ï¹•â‚‚
                        Â¿    ğ‘” : ğ” ó°ƒ¬ = âœ“, ğŒ, n ; â‡¥
                        n += 1
                        Â¿n â‰¡ ğ¶ğŸƒŒ: ğ” ó°ƒ¬ = âœ—, Ï‡    ; â‡¥
                case â›*|â›+:
                    c = ğ” .setdefault(Î¹, [Ï‡])
                    ğœ¾, ğŒ = ğ¶â‚€, câ‚‹â‚
                    â°âœ“:
                        Â¿ğœ¾ â†’âˆ‰â† ğ‘â‰”â„­ôŠ¸´:
                            ğ“¢.extend([Î“, (ğŒ, ğœ¾)])
                            â‡¥
                        ğ‘”, Î§ = â„­ôŠ¸´ ôŠ¸§ ï¹•â‚‚
                        Â¿Â¬ğ‘”:
                            Â¿Î³â‰¡â›* âˆ¨ cğŸƒŒ>1:
                                ğ” ó°ƒ¬ = âœ“, ğŒ, cï¹•â‚‹â‚
                            Â¡:
                                ğ” ó°ƒ¬ = âœ—, Ï‡
                            â‡¥
                        c.append(ğŒâ‰”Î§)
                case â›âœ“: ğ” ó°ƒ¬ = âœ“, Ï‡
                case â›âœ—: âœ—â¨³â€¹Hit an âœ—â€º
                case â›â†:
                    Â¿ğ¶â‚âˆ‰ğ” :
                        ğ“¢.extend([Î“, (Ï‡, ğ¶â‚)])
                    Â¡:
                        ğ‘”, ğŒ = ğ” ôŠ³µôŠ¬¤ ï¹•â‚‚
                        ğ” ó°ƒ¬ = ğ‘”, ğŒ, ğ¶â‚
                case _:
                    Â¿ğ¶â‚€âˆ‰ğ” :
                        ğ“¢.extend([Î“, (Ï‡, ğ¶â‚€)])
                    Â¡:
                        ğ‘”, ğŒ = ğ” ôŠ³µôŠ¬£ ï¹•â‚‚
                        match Î³:
                            case â›â®: ğ” ó°ƒ¬ = ğ‘” , Ï‡
                            case â›Â¬: ğ” ó°ƒ¬ = ğ‘”Â¬, Ï‡
                            case â›â—: ğ” ó°ƒ¬ = ğ‘”â¨³, ğŒ
                            case â›?: ğ” ó°ƒ¬ = âœ“ , ğŒ, ğ‘”
                            case  _: ğ” ó°ƒ¬ = ğ‘” , ğŒ
        â†ª â„­ğŸŸ‘
