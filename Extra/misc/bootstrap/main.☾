GRAM = ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥
parser_main = exprs
parser_comment = (â ¶str âˆ¨ ó°†´comment âˆ¨ ~â€¹.|\nâ€º)*

exprs = ğ—ª? (â ¶expr ğ—ª?)*
expr = (
    (kw_pfx_colon_expr =  â ¶vkw_pfx_colon ó°†´Ã†? (expr_not_colon? ó°†´Ã†? ó°†´':') M:âœ“ ó°†´E? expr?)
        âˆ¨ (kw_pfx_expr =  â ¶vkw_pfx ó°†´E? expr?)
          âˆ¨ (norm_expr = (â ¶norm_expr_atom)+))

expr_not_colon = (Â¬':' â ¶norm_expr_atom)+
expr_not_comma = (Â¬',' â ¶norm_expr_atom)+

vkw_pfx_colon = â®kw_spec kw_pfx_colon âˆ¨ kw_pfx_colon â®text_breaker
vkw_pfx       = â®kw_spec kw_pfx       âˆ¨ kw_pfx       â®text_breaker
vkw           = â®kw_spec kw           âˆ¨ kw           â®text_breaker

norm_expr_atom = (â ¶lambs âˆ¨ â ¶gen_expr_atom) ó°†´E?
gen_expr_atom = group âˆ¨ â ¶str âˆ¨ var_spec âˆ¨ number âˆ¨ oper âˆ¨ â ¶vkw âˆ¨ â ¶script âˆ¨ var
number = pos_num âˆ¨ neg_num
pos_num = Æ¨(~â€¹0([bB][01]+|[oO][0-7]+|[xX][0-9a-fA-F]+)|([0-9]+(\.[0-9]*)?|[0-9]*\.[0-9]+)(e[+\-]?[0-9]+)?â€º)
neg_num = Æ¨(~â€¹ó·°½([ó·±ˆó·±][ó·°½ó·°¾]+|[ó·±ó·±•][ó·°½-ó·±„]+|[ó·±ó·±–][ó·°½-ó·±†ó·±‡-ó·±Œó·±-ó·±”]+)|([ó·°½-ó·±†]+(\.[ó·°½-ó·±†]*)?|[ó·°½-ó·±†]*\.[ó·°½-ó·±†]+)(ó·±‹[+\-]?[ó·°½-ó·±†]+)?â€º)

var = Æ¨(Â¬ğ—ª Â¬oper Â¬var_spec Â¬script ~â€¹ó°¦¥{5}â€º ~â€¹[^á³á‘€á’áµá–á¸á‘…á˜á‘ˆá›á—’á—ŒâŸ¥â¦šâŸ¤á—á—•ğ—®-ğ˜‡ğš²â¥Œâ†¦ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«ó°…‚$"'\[\](){}â…â†âŸ¦âŸ§âŸ¨âŸ©â­¡â­£â€¹ â›â›â›â€º]â€º)+

group = ~â€¹[\[({â…âŸ¦]â€º (ğ—ª? â†· exprs) ~â€¹[\])}â†âŸ§]â€º

script = ((supscript = Æ¨(SUPSCRIPT)) âˆ¨ (subscript = Æ¨(SUBSCRIPT)))

oper = (
    (oper_mod_l = ~â€¹[âŸ¥â‰º]*â€º)
     oper_lit
    (oper_mod_r = Æ¨((~â€¹[Â´êœ áµœğ‘âŸ¤]+â€º âˆ¨ supscript)*)))

lambs = lamb_tacit âˆ¨ lamb
lamb = (
    (   (lamb_h_py = ó°†´"lambda" â®text_breaker ó°†´Ã† â ¶expr_not_colon ó°†´':')
      âˆ¨ (lamb_h_normal = (
            ó°†´('â¥Œ' Ã†?)
            ((Â¬lamb_h_implicit lamb) âˆ¨ â ¶gen_expr_atom ó°†´Ã†?)*
            ó°†´'â†¦' ))
      âˆ¨ (lamb_h_preset = ~"[ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«]")
      âˆ¨ (lamb_h_implicit = var ó°†´(Ã†? 'â†¦'))) ó°†´Ã†?
    (lamb_b = ((exprs ó°†´'ó°…‚') âˆ¨ expr_not_comma)))
lamb_tacit = (
      (â ¶LTL exprs â ¶LTR)
    âˆ¨ (â ¶LTL expr_not_comma âœ“ âœ“))
LTL = (â€¹âŸ¥â€ºâˆ¨âœ“) ~â€¹[á³á‘€á’áµá–]â€º ó°†´Ã†?
LTR = ~â€¹[á¸á‘…á˜á‘ˆá›]â€º (â€¹âŸ¤â€ºâˆ¨âœ“)

str = str_star âˆ¨ Æ¦section âˆ¨ str_cpy âˆ¨ str_$ âˆ¨ str_py âˆ¨ str_escape âˆ¨ str_spec_char
str_$ = ó°†´('$' ğ˜„?) (Æ¨(supscript) âˆ¨ âœ“) ó°†´ğ˜„? (â ¶str_cpy_inner âˆ¨ 'â€º')* ó°†´(ğ˜„? 'ó·¹¹')
str_star = (ó°†´~â€¹ó°¦¥{5}â€º) ~â€¹((?!(ó°¦¥{5}))(.|\n))*â€º ó°†´(~â€¹ó°¦¥{5}â€º âˆ¨ âœ“)
str_cpy = ó°†´'â€¹' (â ¶str_cpy_inner âˆ¨ 'ó·¹¹')* ó°†´'â€º'
str_cpy_inner = (str_escape âˆ¨ str_sub âˆ¨ str_spec_char âˆ¨ str_guts)
str_sub = ó°†´'âŸ¦' exprs ó°†´'âŸ§'
str_spec_char = ~â€¹[ğ—®-ğ˜‡]â€º
str_guts = ~"[^ğ—®-ğ˜‡âŸ¦â›â›â€ºó·¹¹]+"
str_escape = ó°†´"â›â›" ~â€¹.â€º
str_py = ((â€¹"â€º (str_py_sub âˆ¨ ~â€¹[^"\\]+â€º)* â€¹"â€º)
       âˆ¨  (â€¹'â€º (str_py_sub âˆ¨ ~â€¹[^'\\]+â€º)* â€¹'â€º))

str_py_sub = ~â€¹\\.â€º

Æ¦expr = (â ¶Æ¦atom âˆ¨ Æ¦op âˆ¨ ó°†´ğ—ª)*
Æ¦atom = Æ¦section âˆ¨ Æ¦range âˆ¨ Æ¦ESC âˆ¨ Æ¦CHR

Æ¦range   = ó°†´(â€¹â…â€º ğ—ª?) (Æ¦charset âˆ¨ Æ¦rchar)+ ó°†´(ğ—ª? â€¹â†â€º)
Æ¦section = ó°†´(â€¹âŸ¨â€º ğ—ª?) Æ¦mat_name (ó°†´ğ—ª? â†· Æ¦mat_body) Æ¦mat_func ó°†´(ğ—ª? â€¹âŸ©â€º)

Æ¦mat_name = Æ¨((ó°†´ğ—ª âˆ¨ Æ¦ESC âˆ¨ Æ¦CHR)*) ó°†´â€¹â­¡â€º âˆ¨ âœ“
Æ¦mat_body = Æ¦expr
Æ¦mat_func = ó°†´â€¹â­£â€º exprs âˆ¨ âœ“

Æ¦charset = â ¶Æ¦rchar â†· ó°†´(ğ—ª? â†· "â€¦")
Æ¦rchar = â ¶Æ¦ESC âˆ¨ ~â€¹[^â€¦â†]â€º

Æ¦op = Æ¦rrepeat âˆ¨ ~â€¹[â†’Â¿âŒâ¨â¨€âˆ¨]â€º
Æ¦rrepeat = (  ó°†´(â€¹âŸ®â€º ğ—ª?) (
                ((Æ¦INTâˆ¨âœ“) â†· ó°†´(ğ—ª? â†· â€¹,â€º))
                âˆ¨ Æ¦INT
           ) ó°†´(ğ—ª? â€¹âŸ¯â€º) )

Æ¦ESC = ó°†´"â" ~â€¹.â€º
Æ¦INT = ~â€¹[0-9]+â€º
Æ¦CHR = ~â€¹[^ \n\tâ­£â­¡â…â†âŸ¨âŸ©âŸ®âŸ¯âˆ¨â†’âŒÂ¿â¨â¨€]â€º

ğ˜„ = ~â€¹([ \t]*â›â›\n[ \t]*)+|[ \t]+â€º
ğ—ª = ~â€¹[ \t\n]+â€º
text_breaker = â®(E âˆ¨ kw_spec âˆ¨ var_spec âˆ¨ Â¬var)
E = ğ˜„ âˆ¨ ~â€¹â›â›\nâ€º
Ã† = ğ—ª âˆ¨ ~â€¹â›â›\nâ€º

comment = ~â€¹((î¬¦|#)[^\n]*(?=\n|\Z))|(ğŸŸ‘[^ğŸŸ‘]*(ğŸŸ‘|\Z))|(Ö[^Ö]*(Ö|\Z))â€º
ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥

â®Œ whitespace_tools â¨¡ whitespace_parser, whitespace_unparser, add_spaces
â®Œ py_naming_tools â¨¡ py_special_mapper, py_escape_string, py_escape_var
â®Œ string â¨¡ ascii_uppercase
â¨¡ regex as re

ó°‹º(â›ğ, *) ; ó°‹º("peggle2", *)

ó±€˜ Transpiler:
    âŠ¢ __init__(ğ•Š, gram, charsets):
        Â¿gramá¹á”: gram = peggle2(gram)
        gram |= charsetsêŸ¿â±½ó°²£(â›~,
            ğ•Š.to_or_rgx(y) á£†Ë£ô©…ô‹…±ô‹¤ô‹•©ô‹•Ÿá´¾ô‹•© ó°²¡â€¹(âŸ¦xâŸ§)+â€ºó°…‚ â¥‰ re.compile)
        ğ•Š.gram = gram
    âŠ¢ to_or_rgx(ğ•Š, s):
        sâ˜¾
        ğ•¤,ğ• = sáš¤â†’ó°’¼ğŸƒŒâ†’î®†á´®âŸ¥á‘€ğŸƒŒ>1
        ğ•¤ = â€¹[âŸ¦â€¹\â€‰]â€ºâ­â†’ó°›”ô‹‰¥ôŒ¿‘â†â€¹\\â€‰\]â€ºâ­âŸ§]â€º î¬¦ ó°¤± ranges
        ğ• = ğ• á´ re.escape
        â†ª ğ•¤+ğ•âŸ•â°â›|
    âŠ¢ __call__(ğ•Š, c):
        â†ª ğ•Š.gram(c)

ğš = Transpiler(GRAM, â„µ(
        ZZZZZz  ="+â€‰+=â€‰*â€‰Î¶"â­,
        ZZZZZz_P="+â€‰+=â€‰*â€‰Î¶"â­
))
ğš.gram.print_rulesî®¦
exitî®¦

py_escape_var = py_escape_varï(â¬¤,âœ“)

rmk = ó°²£{k:v âˆ€k,vâˆˆx.items() Â¿kâˆ‰y}

mkexp  = ğš²Åƒ("expr", â ¤ğ”¸)
mkstr  = ó°²¡Åƒ("str", â›", x, â›")
mkvar  = ó°²¡Node("var", x)
mkgrp  = â¥Œâ ¤ğ”¸,b="()"â†¦Åƒ("group", bâ‚€, ğ”¸ğŸƒŒâ‰¡1â­œğ”¸â‚€â­ğ”¸, bâ‚)
mkexp_ = ğš²Node("expr_", ğ”¸â¥‰ğ‘™)
fcall_ = â¥Œf,â ¤ğ”¸,E=â–¡â†¦mkexp_(f, mkgxp_(ğ”¸ â¨ COMMA), â ¤Eâˆ¨[])
mkgxp  = mkgrp â—‹ mkexp
mkgxp_ = mkgrp â—‹ mkexp_
mknex_ = ó°²£mkexp_(x, EQCLN, y)

NUM_M2, NUM_M1, NUM_P0, NUM_P1 = ó·°¿ó·¸»1 á–Node("number", âŸâ¥‰á”)
COMMA, COLON, EQCLN =      â€¹,â€‰:â€‰:=â€ºâ­ á–Node("oper_lit", âŸ)
ARG_A = mkexp(("oper_lit", â›â ¤), mkvar(â›ğ”¸))
ARG_K = mkexp(("oper_lit", â›â ¶), mkvar(â›ğ•‚))
TAC_L, TAC_R, TRUE, FALSE, Ã¾PSH, Ã¾POP, Ã¾Ã¾ = "âŸâ€‰âŸâ€‰Trueâ€‰Falseâ€‰Ã¾PSHâ€‰Ã¾POPâ€‰Ã¾Ã¾"â­á´mkvar
Ã¾POP_M2, Ã¾POP_M1 = NUM_M2â‹„NUM_M1 á–fcall_(Ã¾POP, âŸ)
Ã¾POPNR = "Ã¾POPNR" â¥‰ mkvar â¥‰ fcall_

OPS_BUILTIN = â„µ(
    S=â­â€¹â€º,
    N=â­â€¹;â€‰:â€‰,â€‰ifâ€‰elifâ€‰elseâ€‰forâ€º,
    P=â­â€¹+â€‰-â€‰*â€‰~â€‰**â€‰notâ€‰yieldâ€º,
    B=â­â€¹+â€‰-â€‰*â€‰@â€‰**â€‰//â€‰<â€‰>â€‰%â€‰.â€‰&â€‰^â€‰|â€‰/â€‰!=â€‰==â€‰<<â€‰>>â€‰>=â€‰<=â€‰inâ€‰not inâ€‰isâ€‰is notâ€‰orâ€‰andâ€º)
OPS_BUILTINôŠ¯›ó°‚“ = OPS_BUILTIN.values() Å¿ âˆª
OPS_COMP = lang.op_orders êŸ¿â±½ ó°²£yó°ˆ²âŸ¥á’â›Î»âˆˆlang.opsâ‚›ó°…‚ ó°ˆ²

SWAP_TABLE = â„µ((â­â—‹â†ğ—»ó°›”â›âŸ)(â€¹
Â¯â€‰-âŸÃ·â€‰/âŸâ‹…â€‰*âŸâ ¤â€‰*
â¹â€‰//âŸâ‰ â€‰!=âŸâ‰”â€‰:=âŸâ‰¡â€‰==âŸâ‰¤â€‰<=âŸâ‰¥â€‰>=âŸâŒƒâ€‰**âŸâª¢â€‰>>âŸâ ¶â€‰**âŸÂ¿â€‰ifâŸâˆˆâ€‰inâŸâˆ¨â€‰orâŸâ‰…â€‰isâŸâª¡â€‰<<
âˆ€â€‰forâŸÂ¬â€‰notâŸâˆ§â€‰andâŸâŠ¢â€‰defâŸó°†´â€‰del
â€CATâ€‰*âŸÂ¡â€‰elseâŸâ¸˜â€‰elifâŸâ®Œâ€‰from
â°â€‰whileâŸâ‡¥â€‰breakâŸâ®‚â€‰yieldâŸÎ©â€‰classâŸó±€˜â€‰class
â‰‡â€‰is notâŸâ¨¡â€‰importâŸâ†ªâ€‰returnâŸâˆ‰â€‰not in
â†ºâ€‰continueâ€ºâ‚ï¹•))
KEYWORDS_TO_CPY=rmk(SWAP_TABLE á´á´° á´™, â€¹*â€‰**â€ºâ­)

stmerge = á‘€âˆª â† SWAP_TABLE ó°ˆ² ï€…ó°²£yâˆˆâŸó°…‚ áµâ‚€

kw_pfx_colon   = stmerge(â­â€¹ifâ€‰elifâ€‰elseâ€‰forâ€‰whileâ€‰tryâ€‰exceptâ€‰finallyâ€‰classâ€‰matchâ€‰caseâ€‰defâ€‰withâ€º)
kw_neverswouce = stmerge(â­â€¹ifâ€‰elifâ€‰elseâ€‰forâ€‰yieldâ€º)
kw_inline      = stmerge(â­â€¹inâ€‰isâ€‰is notâ€‰not inâ€‰orâ€‰andâ€‰notâ€º) âˆª kw_neverswouce
kw_pfx         = stmerge(â­â€¹returnâ€‰continueâ€‰breakâ€‰passâ€‰importâ€‰globalâ€‰nonlocalâ€‰raiseâ€‰assertâ€‰delâ€‰asyncâ€º)
kw                = kw_pfx_colon âˆª kw_pfx âˆª kw_inline
kw_spec           = kw ó°ˆ³ ó°²¡x.isalpha() âˆ¨ x.isdigit()ó°…‚ â¥‰ ğ‘ 
var_spec          = â€¹â´³â´´âœ“âœ—â–¡âˆ…ó°®ˆâ¬¤âˆÃ®â„‡Ï„Ï€ó·ºó·±¯ó·±ªó·±«ó·±¬ó·±­ó·±®á¦â†‰Â½â…“Â¼â…•â…™â…â…›â…‘â…’â…”â…–Â¾â…—â…œâ…˜â…šâ…â…â€º â¥‰ ğ‘  # forced to be one char, will not act as object or attr-getter when superscript
escaped_var_specs = var_spec á´ py_escape_var â¥‰ ğ‘ 

â„µ(kw=kw,
  kw_pfx=kw_pfx,
  kw_spec=kw_spec,
  kw_pfx_colon=kw_pfx_colon,
  var_spec=var_spec)

ğŸŸ‘

IG = {â›.}
sel = [(váµ—+â›=, v) âˆ€vâˆˆlang.ops.values() Â¿vá´® âˆ§ â›Î´âˆ‰v] + [(":=", lang.opsôŠ¯›ôŠ®), (â›â‰”, lang.ops.pop(â›â‰”))]
new_ops = {}
âˆ€k,vâˆˆsel:
    new_opsâ‚– = OP(k, "B=", IG, lang.opsô‹•¨ôœó°‚“ó°‚¥ó°‚™ó°‚ ô‹•ó°‚Ÿó°‚¤ó°‚ô‹•ó°‚¤ô‹•¨á´¿, vá¶ )
lang.ops âˆª= new_ops
âˆ€k,vâˆˆlang.ops.items():
    Â¿kâˆˆIG: â†º
    vá´¿ âˆª= ğ‘ (new_ops)
lang.ops[â›â‰•] = OP(k, "B=", lang.opsô‹•¨ôœó°‚“ó°‚¥ó°‚™ó°‚ ô‹•ó°‚Ÿó°‚¤ó°‚ô‹•ó°‚ô‹•¨.L, IG, vá¶ )

# janky? we need test cases broooo
lang.ops[â›â¬…].R âˆª= ğ‘ ("â†’â­¢")
lang.ops[â›â†].R âˆª= ğ‘ ("â­¢")

RED, REP = reduction, replacement

KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

ğ”— = ó°²¡x.as_txt()

âŠ¢ Ïƒ_00():
    @(â®‚ REP("lamb_tacit", rec=â›A, n="Reform tacit exprs"))
    âŠ¢ _(ó±•):
        bl, l, Î», r, br = ó±•
        bl, l,    r, br = ğ”—(bl), ğ”—(l), ğ”—(r), ğ”—(br)
        Â¿Î»áµ—âˆˆ{"exprs", "expr", "expr_norm"}:
            Î±, Î² = Î»â‚€á¶œ, Î»ô¨„á¶œ
        Â¡:  Î± = Î² = Î»á¶œ
        
        l, r = l âˆ¨ (râ­œâ›á³â­â›á‘€), r âˆ¨ â›á¸
        
        args, targs = [], [NUM_M1, NUM_M1]
        OP_NAME = "â€TACIT"
        Â¿l âˆ§ lâˆˆ"á‘€áµá’á–":
            Â¿Â¬bl: OP_NAME += â›L
            Â¿lâˆˆ"á‘€áµ": Î±.insert(0, TAC_L)
            targsâ‚€ = lâˆˆ"áµá–" â­œNUM_P1â­ NUM_P0
            args.append(TAC_L)
        Â¿r âˆ§ râˆˆ"á‘…á‘ˆá˜á›":
            Â¿Â¬br: OP_NAME += â›R
            Â¿râˆˆ"á‘…á‘ˆ": Î².append(   TAC_R)
            targsâ‚ = râˆˆ"á‘ˆá›" â­œNUM_P1â­ NUM_P0
            args.append(TAC_R)
        
        COM = OP.TND(â›,)
        args, targs = args â¨ COM, targs âŸ• COM
        
        Â¿args: args.append(COM)
        args.extend([OP.TND(â›â ¤), mkvar(â›ğ“), COM, OP.TND(â›â ¶), mkvar(â›ğ“š)])
        
        â†ª Åƒ("oper", ("oper_mod_l", á¦),
                    ("oper_lit", OP_NAME),
                    ("oper_mod_r", mkgxp(
                        ("lamb", ("lamb_h_normal", â ¤args),
                                 ("lamb_b", ("norm_expr", Î»))),
                        â ¤targs)))

âŠ¢ Ïƒ_03():
    @(â®‚ REP(â ¤KEYWORD_NODE_NAMES, n="Lang keywords â†’ cpy keywords"))
    âŠ¢ _(ó±•):
        txt = ğ”—(ó±•)
        î¬¦ keyword that are just ops:
        Â¿txtâˆˆkw_inline: â†ª OP.TND(KEYWORDS_TO_CPY.get(txt, txt))
        â†ª ó±•.copy(c=KEYWORDS_TO_CPY.get(txt, txt))
    
    @(â®‚ RED("supscript", n="Swap Superscripts"))
    âŠ¢ _(ó±•):
        t = gram(SCRIPT.nrm(ğ”—(ó±•)), "exprs")
        T = lang(txtâ‰•ğ”—(t).strip())
        Â¿Â¬T.isidentifier() âˆ¨ Tâˆˆescaped_var_specs:
            â†ª [OP.TND(â›âŒƒ), mkgxp_(Node(c=lang(txt)))]
        â†ª [OP.TND(â›.), t]
    
    ((â®‚ REP("subscript", rec=â›A, n="Subscripts to brackets"))
    (ó±•â†¦mkgrp(tree_transform(gram(SCRIPT.nrm(ó±•á¶œ), "exprs"), 3+1), b="[]")))
    
    ((â®‚ REP("norm_expr", "expr_not_colon", "expr_not_comma", rec=â›B,
                    n="Normalize expression types"))
    (ó±•â†¦ó±•.copy("expr")))
    
    ((â®‚ REP("W", n="Trim whitespace"))
    (ó±•â†¦ó±•.copy(c=Å„âˆˆó±•á¶œ â­œÅ„+âµ‰(ó±•á¶œ,Å„)ô¨„â­ ó±•á¶œ)))

âŠ¢ Ïƒ_05():
    op_chk = â¥Œó±•,oâ†¦ó±•áµ—â‰¡"oper" âˆ§ ğ”—(ó±•)â‰¡o
    hs_op  = â¥ŒC,oâ†¦any(op_chk(c,o) âˆ€câˆˆC)

    @(â®‚ REP("expr", rec=â›A, n="Detect for_expr"))
    âŠ¢ _(ó±•):
        Â¿Â¬hs_op(Câ‰”ó±•ó°€‚, â›âˆ€): â†ªó±•
        
        Î±, Î² = C ó·¹â° Ï(op_chk, o=â›âˆ€)
        Î², Î³ = Î² ó·¹â° Ï(op_chk, o=â›âˆˆ)
        Â¿hs_op(Î³, â›Â¿):
            Î³, Ïƒ = Î³ ó·¹â° Ï(op_chk, o=â›Â¿)
        Â¡:  Ïƒ = None
        
        cc = [Node("expr", Î±), Node("expr", Î²), Node("expr", Î³)]
        Â¿Ïƒ: cc.append(Node("expr", Ïƒ, e="cond"))
        â†ª ó±•.copy("for_expr", c=cc)
    
    @(â®‚ REP("kw_pfx_colon_expr", rec=â›A, n="Detect for_stmt"))
    âŠ¢ _(ó±•):
        Â¿Â¬op_chk(ó±•ó°€‚â‚€, â›âˆ€): â†ªó±•
        Î±, Î² = ó±•ó°€‚â‚ó°€‚ ó·¹â° Ï(op_chk, o=â›âˆˆ)
        â†ª ó±•.copy("for_stmt", c=[Node("expr", Î±), Node("expr", Î²), â ¤Nó°€‚â‚‚ï¹•])

âŠ¢ Ïƒ_10():
    ((â®‚ REP("parser_main", rec=â›A, n="Build whitespace blocks"))
    (whitespace_parser))

âŠ¢ Ïƒ_15():
    ((â®‚ REP("lamb_h_preset"))
    (ó±•â†¦Åƒ("lamb_h", â ¤"xyzwvutsr"[:ó±•â¥‰ğ”— â¥‰ "ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«ó°²­ó°²¯ó°²±".index] á´ mkexpâ—‹mkvar),
        ARG_A, ARG_K))
    
    ((â®‚ REP("lamb_h_implicit"))
    (ó±•â†¦Åƒ("lamb_h", ó±•ó°€‚â‚€ â¥‰ mkexp, ARG_A, ARG_K)))
    
    @(â®‚ REP("lamb_h_normal", "lamb_h_py"))
    âŠ¢ _(ó±•):
        C = ó±•ó°€‚ó·¹ó°²¡OP.is_op(x)âˆ§(kâ‰”op_manâ‚“)áµ—â‰¡â›,ó°…‚ êŸ¿ mkexp á´ Node.strip
        has_a = has_k = âœ—
        
        C ó°ˆ²= ğ”— î¬¦ âˆµ "â¥Œâ†¦" has empty an expr
        âˆ€câˆˆC:
            Â¿Â¬có°€‚ âˆ¨ (oâ‰”có°€‚â‚€)â‰ "oper": â†º
            k = oó°€‚â‚á¶œ
            Â¿k âˆˆ {  â›*, â›â ¤}: has_a = âœ“
            â¸˜k âˆˆ {"**", â›â ¶}: has_k = âœ“
            Â¡              : â†º
            Â¿cğŸƒŒâ‰¡1: có°€‚â‚€ = Åƒ("expr_", â›*â‹…(1+â†kâˆˆ{"**", â›â ¶}))
        Â¿Â¬has_a: C.append(ARG_A)
        Â¿Â¬has_k: C.append(ARG_K)
        â†ª Åƒ("lamb_h", â ¤C)
    
    ((â®‚ REP("lamb_b", rec=â›A))
    (ó±•â†¦ó±•.copy(t="expr")))

âŠ¢ Ïƒ_18():
    @(â®‚ REP("expr", rec=â›B, n="Implicit Multiplication"))
    âŠ¢ _(ó±•):
        Â¿Â¬ó±•ó°€‚: â†ªó±•
        cc, s = [], peekable(ó±•ó°€‚)
        â°âœ“:
            Î± = next(s)
            Â¿Â¬s: â‡¥
            Î² = s.peek()
            cc.append(Î±)
            
            S = { "number"  : {"var", "group", "var_spec", "number"},
                  "var_spec": {"number", "var", "var_spec"} }
            î¬¦ ó°¤± condition for 2âˆš2
            Â¿   Î±áµ—âˆˆS âˆ§ Î²áµ—âˆˆSó°ƒ¤ôŠ«¼ â›
              âˆ¨ Î²áµ—âˆˆS âˆ§ Î±áµ—âˆˆSó°ƒ¥ôŠ«¼ â›
              âˆ¨ Î±áµ—â‰¡"group" âˆ§ Î²áµ—â‰¡"var_spec": î¬¦ ó°¤± this is weird
                   cc.append(OP.TND("â€CAT"))
        cc.append(Î±)
        â†ª ó±•.copy(c=cc)

âŠ¢ Ïƒ_20():
    ((â®‚ REP("expr", rec=â›B, n="Parse expressions"))
    (ó±•â†¦ó±•.copy(c=into_expr(parse_expr(ó±•ó°€‚))á¶œ)))

âŠ¢ Ïƒ_21():
    âŠ¢ split_target(l):
        l, t = l.copy(), []
        â°l:
            Î± = l.pop()
            Â¿Î±â‰¡â›.         : â†ª â›., l, tâ‚€
            Â¿Î±.tâ‰¡"op_call":
                â¨³ ğ”—(Î±ó°€‚â‚)â‰¡â›.
                l += [â ¤Î±ó°€‚â‚€, â›., â ¤Î±ó°€‚â‚‚]
                â†º
            Â¿Î±.tâ‰¡"group" âˆ§ ğ”—(Î±ó°€‚â‚€)â‰¡â›[ âˆ§ ğ”—(Î±ó°€‚â‚‚)â‰¡â›]:
                â†ª â›l, l, Î±ó°€‚â‚
            t.insert(0, Î±)
        â¨³ tğŸƒŒâ‰¡1
        â†ª á¦, á—œ, tâ‚€

    âŠ¢ mk_inline_asgn(Î±, Î£, Î²): î¬¦ optimization: pull out some constant nodes
        Ï„, Îº, Ï‡ = split_target(Î±ó°€‚)
        
        Â¿Ï„â‰¡á¦: â†ª mkgrp(mknex_(Ï‡, mkgxp(Î£á¹Node â­œ("op_call", mkexp(Ï‡), Î£, Î²)â­ Î²)))
        
        Ï = Ï„â‰¡â›. â­œ"ATTR"â­ "ITEM"
        Îº = mkgxp(â ¤((iâ‰¡â›. â­œNode("expr_", â›.)â­ i) âˆ€iâˆˆÎº))
        Ï‡ = mkgxp(Ïâ‰¡"ATTR" â­œ("str_", â€¹"âŸ¦Ï‡ â¥‰ ğ”— â¥‰ py_escape_varâŸ§"â€º)â­ Ï‡)
        
        ST, GT = mkvar("SET"+Ï), mkvar("GET"+Ï)
        Â¿Î£â‰¡â›â‰”: â†ª fcall_(ST, Îº, Ï‡, Î², NUM_P0)
        Â¿Î£â‰¡â›â‰•: â†ª fcall_(ST, Î², Îº, Ï‡, NUM_P1)
        
        â†ª fcall_(ST,
            fcall_(Ã¾PSH, Îº),
            fcall_(Ã¾PSH, Ï‡),
            Node("op_call", [
                fcall_(GT, Ã¾POP_M2, Ã¾POP_M1), Î£, Î²]),
            NUM_P0)
    
    @(â®‚ REP("op_call", rec=â›A, n="Refactor assignment infix opertators"))
    âŠ¢ _(ó±•):
        Î±, Î£, Î² = ó±•ó°€‚
        Â¿ğ”—(Î£ó°€‚â‚€) âˆ¨ ğ”—(Î£ó°€‚â‚‚): â†ªó±•
        txt = ğ”—(Î£)
        Â¿txtâ‰¡â›â‰” âˆ¨ txtâ‰¡":=": â†ª mk_inline_asgn(Î±, â›â‰”, Î²)
        Â¿txtâ‰¡â›â‰•           : â†ª mk_inline_asgn(Î², â›â‰•, Î±)
        Â¿â›=âˆ‰lang.opsâ‚œâ‚“â‚œ   : â†ª ó±•
        â†ª mk_inline_asgn(Î±, OP.TND(txtï¹•ô¨„), Î²)

âŠ¢ Ïƒ_25():
    ((â®‚ RED("op_call", rec=â›B, n="Flatten cmp ops"))(
        ó±•â†¦â›Î»âˆˆop_manô‹‘ºôŠ»ôŠ¬¤ âˆ§ ó±•ó°€‚â‚€â‰ NULLâ‰ ó±•ó°€‚â‚‚ â­œ [â ¤ó±•ó°€‚â‚€ó°€‚, ó±•ó°€‚â‚, â ¤ó±•ó°€‚â‚‚ó°€‚] â­ [ó±•]))

âŠ¢ Ïƒ_30():
    âŠ¢ make_cmp_chain(ó±•, layers=á—œ):
        layers = layers âˆ¨ OPS_COMP
        layer, â ¤layers = layers
        
        rec       = ó±•â†¦layers â­œmake_cmp_chain(ó±•, layers=layers)â­ ó±•
        mkexp_rec = ó±•â†¦rec(mkexp(â ¤ó±•))
        
        C = ó±•ó°€‚ ğŒ‚ ó°²¡OP.is_op(x) âˆ§ (kâ‰”op_manâ‚“)áµ—âˆˆlayer âˆ§ ká´® â¥‰ğ‘
        Â¿CğŸƒŒ < 3: â†ªrec(ó±•)
        r = âœ—
        
        âˆ€H,T,(a,(b,),c) âˆˆ mark_ends(windowed(C, 3, step=2)):
            c = mkexp_rec(c)
            v = mkexp(("op_call",
                H âˆ§ mkexp_rec(a) âˆ¨ Ã¾Ã¾,
                b,
                T âˆ§ c âˆ¨ mknex_(Ã¾Ã¾, c)))
            r = r â­œmkexp(("op_call", r, OP.TND(â›âˆ§), v))â­ v
        â†ª ó±•.copy(c=[r])
    ((â®‚ REP("expr", rec=â›B, n="Generate comparison chains"))
    (make_cmp_chain))

demodp = oâ†¦(ğ”—(oó°‚•ôŠ¬£), oó°€‚â‚, oó°€‚â‚‚ó°€’ â­œğ”—(oó°€‚â‚‚)â­ oó°€‚â‚‚)
âŠ¢ mkbltnop(op_l): î¬¦ format builtins Â¿ needed
    t = SWAP_TABLE.get(t â‰” ğ”—(op_l), t)
    Â¿tâˆ‰OPS_BUILTINôŠ¯›ó°‚“: â†ª op_l
    â†ª mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
âŠ¢ transform_oper(op_): î¬¦ apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    î¬¦ Â¿op_lâˆˆ"Â¿Â¡â­œâ­": î¬¦ ó°¤±
    Â¿m_l ó·º¥ m_r: â†ª op_l
    op_n = mkbltnop(op_l)
    mkmod = â¥Œop,xâ†¦mkexp(mkvar(â€¹OP_âŸ¦xâŸ§â€º), mkgrp(op))
    
    Â¿â›â‰ºâˆˆm_l: op_n = mkmod(op_n, "BSTAR")
    Â¿â›âŸ¥âˆˆm_l: op_n = mkmod(op_n, "LNULL")
    
    Â¿m_rá¹Node: â†ª mkexp(op_n, mkgxp(m_r, b="[]"))
    rmods = á¦
    âˆ€mâˆˆm_r:
        Â¿mâˆˆ"âŸ¤áµœêœ Â´":
            Â¿mâ‰¡â›âŸ¤: op_n = mkmod(op_n, "RNULL")
            â¸˜mâ‰¡â›áµœ: op_n = mkmod(op_n, "SWAPA")
            â¸˜mâ‰¡â›êœ : op_n = mkmod(op_n, "DUPER")
        Â¡        : rmods += m
    Â¿Â¬rmods: â†ªop_n
    o = â›Ï‡âˆˆop_man[op_] â­œğ‘ ()â­ ascii_uppercase
    rmods = ((FS(x)âŠ‚o â­œâ€¹"âŸ¦xâŸ§"â€ºâ­ lang(x)) âˆ€xâˆˆSCRIPT.nrm(rmods)ó·¹â›ğ‘)â¨â›,
    â†ª mkexp(op_n, Node("expr_", â€¹[âŸ¦rmodsâŸ§]â€º))

âŠ¢ Ïƒ_35():
    hnul = ó°²¡xâ‰¡"NULL"â­œx.copy("NULL_")â­x
    
    âŠ¢ try_builtin(m, op_l, L, m_l, t, m_r, R): î¬¦ see Â¿ op + arg matches can make a builtin
        Â¿m_l âˆ¨ m_r âˆ¨ SWAP_TABLE.get(t, t) âˆ‰ OPS_BUILTINâ‚˜: â†ª
        â†ª mkgxp(â ¤Îµ(L), op_l, â ¤Îµ(R))

    âŠ¢ make_if(t, l, r, m_l, m_r):
        â†ª Åƒ(t, l, r, m_l, m_r)
    âŠ¢ make_el(t, l, r, m_l, m_r):
        â¨³ lâ‚€áµ—âˆˆâ›â­œâ›Â¿
        Â¿tâ‰¡â›â­: â†ªmkgxp(lâ‚€ â‚, OP.TND(â›Â¿), lâ‚€ â‚€, OP.TND(â›Â¡), r)
        Â¿tâ‰¡â›Â¡: â†ªmkgxp(lâ‚€ â‚€, OP.TND(â›Â¿), lâ‚€ â‚, OP.TND(â›Â¡), r)

    @(â®‚ REP("op_call", rec=â›B, n="Refactor op calls"))
    âŠ¢ _(ó±•):
        l, op_, r = ó±•ó°€‚
        op = op_manó°‚¼â‚šô‹•
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = lâ‰ NULL âˆ§ mkgrp(l), râ‰ NULL âˆ§ mkgrp(r)
        
        Â¿m_l ó·º¥ m_r:
            Â¿â›Î²âˆˆop âˆ§  Lâˆ§R: â†ª mkgxp(L, op_l, R)
            Â¿â›Ïƒâˆˆop âˆ§ Â¬Lâˆ§R: â†ª mkexp(op_l, r)
            Â¿â›Î¹âˆˆop: â†ª mkexp(hnul(l), op_l, hnul(r))
            Â¿â›Ïâˆˆop:
                Â¿tâˆˆ"â¡â†’â­¢"    : â†ª L
                Â¿tâˆˆ"â¬…â†â­ "    : â†ª R
                Â¿tâ‰¡â›â¥‰       : â†ª mkgxp(R, L)
                Â¿tâ‰¡â›â‰”       : â†ª mkgxp(l, op_l, R)
                Â¿tâ‰¡â›â‰•       : â†ª mkgxp(l, op_l, R)
                Â¿tâ‰¡â›Â¬ âˆ§â† Lâˆ¨R: â†ª mkgxp(op_l, L âˆ¨ R)
        Â¿tâˆˆâ›â­œâ›Â¿: â†ª make_if(t, l, r, m_l, m_r)
        Â¿tâˆˆâ›â­â›Â¡: â†ª make_el(t, l, r, m_l, m_r)
        Â¿tâ‰¡â›ó·º¥: â†ª mkgxp( î¬¦ xâ­œâœ—â­yâ­œxâ­âœ“
                    FALSE, OP.TND(â›Â¿), fcall_(Ã¾PSH, ğ“›), OP.TND(â›Â¡), mkgxp(
                        Ã¾POP_M1, OP.TND(â›Â¿), ğ“¡, OP.TND(â›Â¡), mkgxp(
                            Ã¾POPNR, Åƒ("oper_lit", â›âˆ¨), TRUE)))
        Â¿tâ‰¡â›ó·º’: â†ª mkgxp( î¬¦ xâ­œ(yâ­œâœ—â­x)â­âœ“
                    mkgxp(
                        mkgxp(Ã¾POPNR, Åƒ("oper_lit", â›âˆ¨), FALSE),
                            OP.TND(â›Â¿), ğ“¡, OP.TND(â›Â¡), Ã¾POP_M1),
                    OP.TND(â›Â¿), fcall_(Ã¾PSH, ğ“›), OP.TND(â›Â¡), TRUE)
        
        A = (transform_oper(op_), L, m_l, t, m_r, R)
        tb, mblo = try_builtin, mkbltnop
        Â¿opó°€’âˆ§L  âˆ§Â¬opá´®: â†ª tb(â›S, â ¤A) âˆ¨ mkexp(mblo(op_), L)
        Â¿opá´¾  âˆ§Râˆ§Â¬opá´®: â†ª tb(â›P, â ¤A) âˆ¨ mkexp(mblo(op_), R)
        Â¿opá´®âˆ§Lâˆ§R     : â†ª tb(â›B, â ¤A) âˆ¨ mkexp(mblo(op_), mkgxp(   l, COMMA,    r))
        Â¿opó°€’âˆ§L       : â†ª tb(â›S, â ¤A) âˆ¨ mkexp(mblo(op_), mkgxp(   l, COMMA, NULL))
        Â¿opá´¾  âˆ§R     : â†ª tb(â›P, â ¤A) âˆ¨ mkexp(mblo(op_), mkgxp(NULL, COMMA,    r))
        Â¿opá´ºâˆ§â›Î½ âˆˆ op : â†ª mkexp(mblo(op_), mkgxp())
        â†ª mkbltnop(op_)

âŠ¢ Ïƒ_36():
    ((â®‚ REP(â›â­œ, rec=â›B, n="Refactor â­-less â­œ"))(
        ó±•â†¦mkgxp(ó±•â‚, OP.TND(â›Â¿), nâ‚€, OP.TND(â›Â¡), mkvar("None"))))

âŠ¢ Ïƒ_40():
    @(â®‚ REP("oper", rec=â›A, n="Refactor sitting ops"))
    âŠ¢ _(ó±•):
        Â¿ğ”—(ó±•ó°€‚â‚) âˆˆ kw_neverswouce: â†ªó±•
        Â¿ğ”—(ó±•ó°€‚â‚‚) ó·º¥ ğ”—(ó±•ó°€‚â‚€): ó±• = ó±•.copy(c=[ó±•ó°€‚â‚€, ó±•ó°€‚â‚, ó±•ó°€‚â‚‚.copy(c=â›Â´)])
        â†ªtransform_oper(ó±•)
    
    ((â®‚ REP(â ¤KEYWORD_NODE_NAMES, "oper_lit", n="Lang keywords â† cpy keywords"))
    (ó±•â†¦ó±•.copy(c=py_escape_var(SWAP_TABLE.get(txtâ‰”ğ”—(ó±•), txt)))))
    
    ((â®‚ REP("lamb", rec=â›B, n="Format lambda"))
    (ó±•â†¦mkgxp(ó±•ó°€‚â‚€, mkgrp(ó±•ó°€‚â‚))))
    
    ((â®‚ REP("lamb_h", rec=â›B, n="Format lambda header"))
    (ó±•â†¦Åƒ("lamb_h", ("kw", "lambda"), â ¤JÌ(ó±•ó°€‚, COMMA), ("oper_lit", â›:))))

âŠ¢ Ïƒ_45():
    ((â®‚ REP("parser_main", rec=â›A, n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((â®‚ RED("BLOCK", rec=â›B, n="Flatten blocks"))
    (ó±•â†¦ó±•ó°€‚))

âŠ¢ Ïƒ_48():
    ((â®‚ REP("for_expr", rec=â›B, n="Build for exprs"))
    (ó±•â†¦Åƒ("expr",
         ó±•ó°€‚â‚€, ("kw", "for"), ó±•ó°€‚â‚, ("kw", "in"), ó±•ó°€‚â‚‚,
         â ¤(ó±•ô‹•¨î ó°‚¼â‚™î ô‹•¨ â­œ [("kw", â›Â¿), ó±•ó°€‚â‚ƒ] â­ []))))
    
    ((â®‚ REP("for_stmt", rec=â›B, n="Build for stmt"))
    (ó±•â†¦Åƒ("kw_pfx_colon_expr",
            ("kw_pfx_colon", "for"),
            ("expr", ó±•ó°€‚â‚€, ("kw", "in"), ó±•ó°€‚â‚),
            â ¤ó±•ó°€‚â‚‚ï¹•)))

âŠ¢ Ïƒ_50():
    ((â®‚ REP("kw_pfx_colon_expr", rec=â›B, n="Add colons"))
    (ó±•â†¦ó±•.insert_after_marker(â›M, COLON)))
    
    ((â®‚ REP("parser_main", rec=â›B, n="Insert spaces"))
    (Ï(add_spaces, ignore_nodes=("str_cpy", "str_py", "str_star", "str_$"))))

î¬¦ Â§Â§Â§ node transpilers Â§Â§Â§
generator(â ¤KEYWORD_NODE_NAMES, â ¤â€¹oper_litâ€‰varâ€‰var_specâ€ºâ­)(py_escape_varâ—‹ğ”—)
generator("NULL")(ó°»¾ô‹•©á´ºáµá´¸á´¸ô‹•©)

generator("group")(ğ”—(ó±•ó°€‚â‚€) + (ó±•ó°€‚â‚ï¹•ô¨„ á´ gen)â¨á¦ + ğ”—(ó±•ó°€‚ô¨„))

generator("str_guts"              )(ó±• â†¦      py_escape_string (ó±•â¥‰ğ”—)     )
generator("str_escape", "str_star")(ó±• â†¦ â›' + py_escape_string (ó±•â¥‰ğ”—) + â›')
generator("str_sub"               )(ó±• â†¦ â›{ + gen(ó±•ó°€‚â‚€)                + â›})
generator("str_spec_char"         )(ó±• â†¦ â›' + py_special_mapper(ó±•â¥‰ğ”—) + â›')

âŠ¢ make_str_cpy(ó±•):
    r=â€¹""f"â€º
    âˆ€câˆˆó±•á¶œ:
        Â¿cáµ—â‰¡"str_escape"   : r += py_escape_string (câ¥‰ğ”—)
        â¸˜cáµ—â‰¡"str_spec_char": r += py_special_mapper(câ¥‰ğ”—)
        Â¡                  : r += gen(c)
    â†ª r + â›"

generator("neg_num")(ó±•â†¦â€¹(-âŸ¦ó±•â¥‰ğ”— â¥‰ UPSIDEDOWNSYNDROME.flipâŸ§)â€º)
generator("str_cpy")(make_str_cpy)

@generator("str_$")
âŠ¢ make_str_money(ó±•):
    s, â ¤C = ó±•á¶œ
    â†ª â€¹SUBPROCA(âŸ¦ó±•.copy(c=C)â¥‰make_str_cpyâŸ§,"âŸ¦sâ¥‰ğ”— â¥‰ SCRIPT.nrm â¥‰ py_escape_stringâŸ§")â€º