OPERATORS = 󰦥󰦥󰦥󰦥󰦥
⨡ᴺᴾ󰁔
;ᴺᴾ󰁔 ,ᴺᴾ󰁔
=ᴺᴾ󰁔 ⮂ᴺᴾ󰁔 ↪ᴺᴾ󰁔 ⮌ᴺᴾ󰁔 ↺ᴺ󰁔 ⇥ᴺ󰁔 ➰ᴺᴾ󰁔 ∀ ␛
    ⠤ᴾ󰁔󰁞 ⠶ᴾ󰁔󰁞 :ᴮᴾᴺ󰁏󰁔
␀ARW_1ᴵᴮ
⭝ᴺᴮᴵ󰁜 ␉ ⭜ᴮᴵ󰁜
␀ARW_2ᴵᴮ
¡ᴮᴵ󰁜 ␉ ⸘ᴺᴾ󰁔 ¿ᴺᴮᴵ󰁜
␀ASGN_MRK_Lᴮ ≔ᴮ󰁜 ␀ASGN_MRK_Rᴮ ≕ᴮ󰁜
␀ARW_3ᴵᴮ
⨳ᴮᴾ󰀒ᴺ
∨ᴮᴺ ⩔ᴮᴺ 󷺥ᴮᴺ 󷺫ᴮᴺ 󷺤ᴮᴺ 󷺦ᴮᴺ
∧ᴮᴺ ⩓ᴮᴺ 󷺒ᴮᴺ 󷺬ᴮᴺ
≡ᴮᴺ󰁖󰁍 ==ᴮᴺ󰁖󰁍 !=ᴮᴺ󰁖󰁍 ≠ᴮᴺ󰁖󰁍 ∣ᴮᴺ󰁖  ∤ᴮᴺ󰁖 ␛
      <=ᴮᴺ󰁖󰁍  ≤ᴮᴺ󰁖󰁍 <ᴮᴺ󰁖󰁏 >ᴮᴺ󰁖󰁏 ≥ᴮᴺ󰁖󰁍 >=ᴮᴺ󰁖󰁍 ␛
       ⊄ᴮᴺ󰁖   ⊊ᴮᴺ󰁖  ⊂ᴮᴺ󰁖  ⊃ᴮᴺ󰁖  ⊋ᴮᴺ󰁖   ⊅ᴮᴺ󰁖 ␛
       ∉ᴮᴺ󰁖   ∈ᴮᴺ󰁖  ∋ᴮᴺ󰁖  ∌ᴮᴺ󰁖
␀TACᴮ
ꟿᴮᴺ ᴍᴮᴺ   ſᴮᴺ   Ϝᴮᴺ   Σᴮᴾ󰀒ᴺ Πᴮᴾ󰀒ᴺ ⨀ᴮᴾ󰀒ᴺ ⨁ᴮᴾ󰀒ᴺ ␛
    󰈲ᴮᴾ󰀒ᴺ 󰈳ᴮᴾ󰀒ᴺ 󰒼ᴮᴾ󰀒ᴺ 󰒽ᴮᴾ󰀒ᴺ ᙎᴮ󰀒ᴺ  ᙡᴮ󰀒ᴺ  ᗢᴮ󰀒ᴺ  ␛
    ᙧᴮ󰀒ᴺ  ᴮᴾ󰀒ᴺ
ᐹᴮᴾ󰀒ᴺ󰁖 ᐴᴮᴾ󰀒ᴺ󰁖 󷹵ᴮᴺ󰁖 󷹴ᴮᴺ󰁖 ζᴮᴾ󰀒ᴺ 󱑼ᴮᴾ󰀒ᴺ ᴮᴾ󰀒ᴺ󰁘 󱅏ᴮᴾ󰀒ᴺ󰁘 ᴮᴾ󰀒ᴺ󰁘
|ᴮᴺ ␉ ^ᴮᴺ ␉ &ᴮᴺ
<<ᴮᴺ >>ᴮᴺ ⪡ᴮᴺ ⪢ᴮᴺ
∓ᴾᴮᴺ ±ᴾᴮᴺ +ᴾᴮᴺ -ᴾᴮᴺ
∘ᴮᴺ ○ᴮᴺ   󰀒ᴺ   ᴮᴾ󰀒ᴺ 󰔶ᴮᴾ󰀒ᴺ ᴮᴾ󰀒ᴺ ␛
    ᣆᴮᴾ󰀒ᴺ ⊚ᴮᴾ󰀒ᴺ ⊜ᴮᴾ󰀒ᴺ 🟕ᴮᴾ󰀒ᴺ 🟖ᴮᴾ󰀒ᴺ
◄ᴮᴺ󰁏 ►ᴮᴺ󰁏
⋄ᴮᴺ
∪ᴮᴺ ␉ ∩ᴮᴺ ␉ ⨉ᴾ󰀒ᴮᴺ ⊞ᴾ󰀒ᴮᴺ ∖ᴮᴺ
//ᴮᴺ /ᴮᴺ   *ᴮᴺᴾ󰁞 ␛
     ≅ᴮᴺ󰁍  ≇ᴮᴺ󰁍   ⋅ᴮᴺ    ÷ᴮᴺ   ⹏ᴮᴺ   %ᴮᴺ  ␛
     ⋀ᴾ󰀒ᴺ  ⋁ᴾ󰀒ᴺ   ⫰ᴾ󰀒ᴺ   ⫯ᴾ󰀒ᴺ  @ᴮᴾᴺ󰁞 √ᴾᴺ  ␛
     ⟕ᴮᴾ󰀒ᴺ ⨝ᴮᴾ󰀒ᴺ  ⟗ᴮᴾ󰀒ᴺ  ⟖ᴮᴾ󰀒ᴺ !󰁏󰀒ᴺ  ☾ᴾ󰀒ᴺ ␛
     󷸹ᴮᴾ󰀒ᴺ 󷸸ᴮᴾ󰀒ᴺ  󷸻ᴮᴾ󰀒ᴺ  󷸺ᴮᴾ󰀒ᴺ ⍭ᴾ󰀒ᴺ  ⍉ᴾ󰀒ᴺ ␛
     󷹓ᴮᴺ󰀒  󰑅ᴮᴺ󰀒   󷹔ᴮᴺ󰀒   󷹕ᴮᴺ󰀒  󷹖ᴮᴺ󰀒  ⛶ᴾ󰀒ᴺ ␛
     ⬓ᴾ󰀒ᴺ  ▢ᴮᴾ󰀒ᴺ  ⬒ᴾ󰀒ᴺ   󰸵ᴮᴺ   󰸷ᴮᴺ   🃌ᴾ󰀒ᴺ ␛
     ⤈ᴮᴾ󰀒ᴺ 󷹄ᴮᴾ󰀒ᴺ󰁢 ⤉ᴮᴾ󰀒ᴺ  ↨ᴾ󰀒ᴺ  ⭥ᴾ󰀒ᴺ  ⴵᴾ󰀒ᴺ ␛
     󷹌ᴮᴾ󰀒ᴺ 󷹍ᴮᴾ󰀒ᴺ  󷹎ᴮᴾ󰀒ᴺ  𝌂ᴮᴾ󰀒ᴺ ᴙᴾ󰀒ᴺ  ᚤᴮᴾ󰀒ᴺ␛
     ⬄ᴮᴾ󰀒ᴺ 󰌷ᴮᴾ󰀒ᴺ  󰛔ᴮᴾ󰀒ᴺ󰁢
¬ᴾ󰀒ᴺ󰁜 ¯ᴾᴺ
␀CATᴮᴺ
**ᴵᴮᴾ󰁞 …ᴮᴺ ⌃ᴵᴮᴺ
ᴵᴾᴺ ᴺ󰀒
󰻾ᴺ ℵᴺ ℶᴺ
.ᴮ󰁏󰁔
...ᴺ

      ｜␀TACIT  ᴺ󰀒  󰁏󰁜｜
␀TAC  ｜␀TACITL ᴺ󰀒  󰁏󰁜｜
      ｜␀TACITR ᴺᴾ  󰁏󰁜｜␀TAC
␀TAC  ｜␀TACITLRᴺᴾ󰀒ᴮ󰁏󰁜｜␀TAC
      ｜          ⬅ᴾ󰁏󰁜｜␀ARW_1
␀ARW_1｜          ➡󰀒󰁏󰁜｜
      ｜          ←ᴾ󰁏󰁜｜␀ARW_2
␀ARW_2｜          ⥉ᴮ󰁏󰁜｜␀ARW_2
␀ARW_2｜          →󰀒󰁏󰁜｜
      ｜          ⭠ᴾ󰁏󰁜｜␀ARW_3
␀ARW_3｜          ⭢󰀒󰁏󰁜｜
󰦥󰦥󰦥󰦥󰦥

⮌ util ⨡ SCRIPT
α,β = OPERATORS.strip 󷹎 𝗻𝗻
𝒻 = ᑀ₀⋄SCRIPT.nrm(⟞₁)
𝓈 = 𝒻○⟥ᑀ𝌂¹⟥ᑀ∈SCRIPT.CHAR_SUPᐸ󰸷􊾖2
ops = α⥉(␛␛𝗻⋄␛␉→󰛔←𝘀⋄𝗻)→󷹎𝗻ᐵ󷹎𝘀ᴍ𝓈
ops_spec = β󷹎𝗻 ᴍ𝘀󰛔ᐦ ᐵ󷹍(ᑀ≡␛｜⭜󰮈)ᴍ⨝→ꟿ⁰󰲥x⋄(𝓈∘y)⋄z

⊢ make_op_call(op, l, r, op_):
    ch = n↦nᐹ𝑙 ⭜(n≅□ ⭜NULL⭝ into_expr(n))⭝ n
    ↪ Ń("op_call", [ch(l), op_, ch(r)])

⊢ create_precedences(tiers, specials, ƒ=󰻾):
    𝐎 = {}
    ∀tier ∈ tiersᴙ:
        𝐶 = 𝑠←𝐎.keys
        T = 𝑠←tierᐵ₀
        ∀𝓽,𝓶 ∈ tier:
            𝐶 = 𝐶.copy
            ¿␛I∈𝓶: 𝐶 ∪= tier
            
            𝐾 = {}
            ¿𝓶∩"BS": 𝐾􊯛󰂞 = 𝐶.copy()
            ¿𝓶∩"BP": 𝐾􊯛󰂤 = 𝐶.copy()
            op = OP(𝓽, 𝓶, f=make_op_call(op), ⠶𝐾)
            𝐎􋚾 = op
    
    new = {}
    ∀L,(𝓽,𝓶),R ∈ specials:
        L_c = L ⭜𝐎󰂞ᴸ∪𝐎󰂞ᴿ⭝ {}
        R_c = R ⭜𝐎󰂤ᴸ∪𝐎󰂤ᴿ⭝ {}
        ∀c∈𝐎:
            ¿c∉L_c ∧ (O≔𝐎)ᴾᴮ: Oᴿ ∪= {𝓽}
            ¿c∉R_c ∧ (O≔𝐎)ᴾᴮ: Oᴸ ∪= {𝓽}
        
        𝐾 = {}
        ¿L: 𝐾􊯛󰂞 = 𝐎.keys∖𝐎󰂞ᴸ ∪ {L}
        ¿R: 𝐾􊯛󰂤 = 𝐎󰂤ᴿ
        op = OP(𝓽, 𝓶, f=make_op_call(op), ⠶𝐾)
        new􋚾 = op
    𝐎 |= new
    
    ↪ ƒ∘𝐎

ops☾
ᐦ☾
ops_spec☾

⊢ ƒ(𝐎):
    IG = {␛.}
    𝐎.valuesᐵᴮ∧␛δ∉v⭜(vᵗ+␛=,v)⭝󰮈ᐸ →󰌷← (":=",ops􊯛􊮝)⋄(␛≔, 𝐎.pop(␛≔))
    new_ops = {}
    ∀k,v∈sel:
        new_opsₖ = OP(k, "B=", IG, ops􋕨􍍜󰂓󰂥󰂙󰂠􋕞󰂟󰂤󰂝􋕞󰂤􋕨ᴿ, vᶠ)
    𝐎 ∪= new_ops
    ∀k,v∈𝐎.items():
        ¿k∈IG: ↺
        vᴿ ∪= 𝑠(new_ops)

    ops􊯛􍪪 = OP(k, "B=", ops􋕨􍍜󰂓󰂥󰂙󰂠􋕞󰂟󰂤󰂝􋕞󰂞􋕨ᴸ, IG, vᶠ)
    ops􊯛􊱼ᴿ ∪= 𝑠("→⭢")
    ops􊯛􊭨ᴿ ∪= 𝑠("⭢")
    ↪ 𝐎

exit

GRAM = 󰦥󰦥󰦥󰦥󰦥
parser_main = exprs
parser_comment = (⠶str ∨ 󰆴comment ∨ ~‹.|\n›)*

exprs = 𝗪? (⠶expr 𝗪?)*
expr = (
    (kw_pfx_colon_expr =  ⠶vkw_pfx_colon 󰆴Æ? (expr_not_colon? 󰆴Æ? 󰆴':') M:✓ 󰆴E? expr?)
        ∨ (kw_pfx_expr =  ⠶vkw_pfx 󰆴E? expr?)
          ∨ (norm_expr = (⠶norm_expr_atom)+))

expr_not_colon = (¬':' ⠶norm_expr_atom)+
expr_not_comma = (¬',' ⠶norm_expr_atom)+

vkw_pfx_colon = ⮞kw_spec kw_pfx_colon ∨ kw_pfx_colon ⮞text_breaker
vkw_pfx       = ⮞kw_spec kw_pfx       ∨ kw_pfx       ⮞text_breaker
vkw           = ⮞kw_spec kw           ∨ kw           ⮞text_breaker

norm_expr_atom = (⠶lambs ∨ ⠶gen_expr_atom) 󰆴E?
gen_expr_atom = group ∨ ⠶str ∨ var_spec ∨ number ∨ oper ∨ ⠶vkw ∨ ⠶script ∨ var
number = pos_num ∨ neg_num
pos_num = ƨ(~‹0([bB][01]+|[oO][0-7]+|[xX][0-9a-fA-F]+)|([0-9]+(\.[0-9]*)?|[0-9]*\.[0-9]+)(e[+\-]?[0-9]+)?›)
neg_num = ƨ(~‹󷰽([󷱈󷱐][󷰽󷰾]+|[󷱍󷱕][󷰽-󷱄]+|[󷱎󷱖][󷰽-󷱆󷱇-󷱌󷱏-󷱔]+)|([󷰽-󷱆]+(\.[󷰽-󷱆]*)?|[󷰽-󷱆]*\.[󷰽-󷱆]+)(󷱋[+\-]?[󷰽-󷱆]+)?›)

var = ƨ(¬𝗪 ¬oper ¬var_spec ¬script ~‹󰦥{5}› ~‹[^ᐳᑀᐒᐵᐖᐸᑅᐘᑈᐛᗒᗌ⟥⦚⟤ᗏᗕ𝗮-𝘇𝚲⥌↦󰲡󰲣󰲥󰲧󰲩󰲫󰅂$"'\[\](){}⁅⁆⟦⟧⟨⟩⭡⭣‹ ␛␛␛›]›)+

group = ~‹[\[({⁅⟦]› (𝗪? ↷ exprs) ~‹[\])}⁆⟧]›

script = ((supscript = ƨ(SUPSCRIPT)) ∨ (subscript = ƨ(SUBSCRIPT)))

oper = (
    (oper_mod_l = ~‹[⟥≺]*›)
     oper_lit
    (oper_mod_r = ƨ((~‹[´꜠ᵜ𐞑⟤]+› ∨ supscript)*)))

lambs = lamb_tacit ∨ lamb
lamb = (
    (   (lamb_h_py = 󰆴"lambda" ⮞text_breaker 󰆴Æ ⠶expr_not_colon 󰆴':')
      ∨ (lamb_h_normal = (
            󰆴('⥌' Æ?)
            ((¬lamb_h_implicit lamb) ∨ ⠶gen_expr_atom 󰆴Æ?)*
            󰆴'↦' ))
      ∨ (lamb_h_preset = ~"[𝚲󰲡󰲣󰲥󰲧󰲩󰲫]")
      ∨ (lamb_h_implicit = var 󰆴(Æ? '↦'))) 󰆴Æ?
    (lamb_b = ((exprs 󰆴'󰅂') ∨ expr_not_comma)))
lamb_tacit = (
      (⠶LTL exprs ⠶LTR)
    ∨ (⠶LTL expr_not_comma ✓ ✓))
LTL = (‹⟥›∨✓) ~‹[ᐳᑀᐒᐵᐖ]› 󰆴Æ?
LTR = ~‹[ᐸᑅᐘᑈᐛ]› (‹⟤›∨✓)

str = str_star ∨ Ʀsection ∨ str_cpy ∨ str_$ ∨ str_py ∨ str_escape ∨ str_spec_char
str_$ = 󰆴('$' 𝘄?) (ƨ(supscript) ∨ ✓) 󰆴𝘄? (⠶str_cpy_inner ∨ '›')* 󰆴(𝘄? '󷹹')
str_star = (󰆴~‹󰦥{5}›) ~‹((?!(󰦥{5}))(.|\n))*› 󰆴(~‹󰦥{5}› ∨ ✓)
str_cpy = 󰆴'‹' (⠶str_cpy_inner ∨ '󷹹')* 󰆴'›'
str_cpy_inner = (str_escape ∨ str_sub ∨ str_spec_char ∨ str_guts)
str_sub = 󰆴'⟦' exprs 󰆴'⟧'
str_spec_char = ~‹[𝗮-𝘇]›
str_guts = ~"[^𝗮-𝘇⟦␛␛›󷹹]+"
str_escape = 󰆴"␛␛" ~‹.›
str_py = ((‹"› (str_py_sub ∨ ~‹[^"\\]+›)* ‹"›)
       ∨  (‹'› (str_py_sub ∨ ~‹[^'\\]+›)* ‹'›))

str_py_sub = ~‹\\.›

Ʀexpr = (⠶Ʀatom ∨ Ʀop ∨ 󰆴𝗪)*
Ʀatom = Ʀsection ∨ Ʀrange ∨ ƦESC ∨ ƦCHR

Ʀrange   = 󰆴(‹⁅› 𝗪?) (Ʀcharset ∨ Ʀrchar)+ 󰆴(𝗪? ‹⁆›)
Ʀsection = 󰆴(‹⟨› 𝗪?) Ʀmat_name (󰆴𝗪? ↷ Ʀmat_body) Ʀmat_func 󰆴(𝗪? ‹⟩›)

Ʀmat_name = ƨ((󰆴𝗪 ∨ ƦESC ∨ ƦCHR)*) 󰆴‹⭡› ∨ ✓
Ʀmat_body = Ʀexpr
Ʀmat_func = 󰆴‹⭣› exprs ∨ ✓

Ʀcharset = ⠶Ʀrchar ↷ 󰆴(𝗪? ↷ "…")
Ʀrchar = ⠶ƦESC ∨ ~‹[^…⁆]›

Ʀop = Ʀrrepeat ∨ ~‹[→¿⌐⨁⨀∨]›
Ʀrrepeat = (  󰆴(‹⟮› 𝗪?) (
                ((ƦINT∨✓) ↷ 󰆴(𝗪? ↷ ‹,›))
                ∨ ƦINT
           ) 󰆴(𝗪? ‹⟯›) )

ƦESC = 󰆴"␐" ~‹.›
ƦINT = ~‹[0-9]+›
ƦCHR = ~‹[^ \n\t⭣⭡⁅⁆⟨⟩⟮⟯∨→⌐¿⨁⨀]›

𝘄 = ~‹([ \t]*␛␛\n[ \t]*)+|[ \t]+›
𝗪 = ~‹[ \t\n]+›
text_breaker = ⮞(E ∨ kw_spec ∨ var_spec ∨ ¬var)
E = 𝘄 ∨ ~‹␛␛\n›
Æ = 𝗪 ∨ ~‹␛␛\n›

comment = ~‹((|#)[^\n]*(?=\n|\Z))|(🟑[^🟑]*(🟑|\Z))|(֎[^֎]*(֎|\Z))›
󰦥󰦥󰦥󰦥󰦥

⮌ whitespace_tools ⨡ whitespace_parser, whitespace_unparser, add_spaces
⮌ py_naming_tools ⨡ py_special_mapper, py_escape_string, py_escape_var
⮌ string ⨡ ascii_uppercase
⨡ regex as re

󰋺(␛𝐍, *) ; 󰋺("peggle2", *)

󱀘 Transpiler:
    ⊢ __init__(𝕊, gram, charsets):
        ¿gramᐹᔐ: gram = peggle2(gram)
        gram |= charsetsꟿⱽ󰲣(␛~,
            𝕊.to_or_rgx(y) ᣆˣ􍩅􋅱􋁤􋕩􋕟ᴾ􋕩 󰲡‹(⟦x⟧)+›󰅂 ⥉ re.compile)
        𝕊.gram = gram
    ⊢ to_or_rgx(𝕊, s):
        s☾
        𝕤,𝕞 = sᚤ→󰒼🃌→ᴮ⟥ᑀ🃌>1
        𝕤 = ‹[⟦‹\ ]›⍭→󰛔􋉥􌿑←‹\\ \]›⍭⟧]›  󰤱 ranges
        𝕞 = 𝕞 ᴍ re.escape
        ↪ 𝕤+𝕞⟕⁰␛|
    ⊢ __call__(𝕊, c):
        ↪ 𝕊.gram(c)

𝚝 = Transpiler(GRAM, ℵ(
        ZZZZZz  ="+ += * ζ"⍭,
        ZZZZZz_P="+ += * ζ"⍭
))
𝚝.gram.print_rules

OPS_BUILTIN = ℵ(
    S=⍭‹›,
    N=⍭‹; : , if elif else for›,
    P=⍭‹+ - * ~ ** not yield›,
    B=⍭‹+ - * @ ** // < > % . & ^ | / != == << >> >= <= in not in is is not or and›)
SWAP_TABLE     = ⍭‹¯ - ÷ / ⋅ * ⠤ * ⹏ // ≠ != ≔ := ≡ == ≤ <= ≥ >= ⌃ ** ⪢ >> ⠶ ** ¿ if ∈ in ∨ or ≅ is ⪡ << ∀ for ¬ not ∧ and ⊢ def 󰆴 del ␀CAT * ¡ else ⸘ elif ⮌ from ➰ while ⇥ break ⮂ yield Ω class 󱀘 class ≇ is not ⨡ import ↪ return ∉ not in ↺ continue›
kw_pfx_colon   = ⍭‹if elif else for while try except finally class match case def with›
kw_neverswouce = ⍭‹if elif else for yield›
kw_inline      = ⍭‹in is is not not in or and not›
kw_pfx         = ⍭‹return continue break pass import global nonlocal raise assert del async›
var_spec       = 𝑠∘‹ⴳⴴ✓✗□∅󰮈⬤∞îℇτπ󷺍󷱯󷱪󷱫󷱬󷱭󷱮ᐦ↉½⅓¼⅕⅙⅐⅛⅑⅒⅔⅖¾⅗⅜⅘⅚⅝⅞›

add_swaps = ᑀ∪ ← SWAP_TABLE 󰈲 󰲣y∈⟞󰅂 ᐵ₀
rmk = 󰲣{k:v ∀k,v∈x.items() ¿k∉y}

SWAP_TABLE = ℵ(SWAP_TABLE)
kw_pfx_colon   = add_swaps(kw_pfx_colon)
kw_neverswouce = add_swaps(kw_neverswouce)
kw_inline      = add_swaps(kw_inline) ∪ kw_neverswouce
kw_pfx         = add_swaps(kw_pfx)
KEYWORDS_TO_CPY=rmk(SWAP_TABLE ᴍᴰ ᴙ, ‹* **›⍭)

exit

py_escape_var = py_escape_var(⬤,✓)

𝚃      = 󰲡Ń(x,e=ℵ(T=✓))
mkexp  = 𝚲Ń("expr", ⠤𝔸)
mkstr  = 󰲡Ń("str", 𝚃(␛"), 𝚃(x), 𝚃(␛"))
mkvar  = 󰲡Ń("var", 𝚃(x))
mkgrp  = ⥌⠤𝔸,b="()"↦Ń("group", 𝚃(b₀), 𝔸🃌≡1⭜𝔸₀⭝𝔸, 𝚃(b₁))
mkexp_ = 𝚲Node("expr_", 𝔸⥉𝑙)
fcall_ = ⥌f,⠤𝔸,E=□↦mkexp_(f, mkgxp_(𝔸 ⨝ COMMA), ⠤E∨[])
mkgxp  = mkgrp ○ mkexp
mkgxp_ = mkgrp ○ mkexp_
mknex_ = 󰲣mkexp_(x, EQCLN, y)

NUM_M2, NUM_M1, NUM_P0, NUM_P1 = 󷰿󷸻1 ᐖŃ("number", 𝚃(⟞⥉ᔐ))
COMMA, COLON, EQCLN =      ‹, : :=›⍭ ᐖŃ("oper_lit", 𝚃(⟞))
ARG_A = mkexp(("oper_lit", ␛⠤), mkvar(␛𝔸))
ARG_K = mkexp(("oper_lit", ␛⠶), mkvar(␛𝕂))
TAC_L, TAC_R, TRUE, FALSE, þPSH, þPOP, þþ = "⟞ ⟝ True False þPSH þPOP þþ"⍭ᴍmkvar
þPOP_M2, þPOP_M1 = NUM_M2⋄NUM_M1 ᐖfcall_(þPOP, ⟞)
þPOPNR = "þPOPNR" ⥉ mkvar ⥉ fcall_

kw                = kw_pfx_colon ∪ kw_pfx ∪ kw_inline
kw_spec           = kw 󰈳 󰲡x.isalpha() ∨ x.isdigit()󰅂 ⥉ 𝑠
OPS_BUILTIN􊯛󰂓 = OPS_BUILTIN.values() ſ ∪
OPS_COMP = lang.op_orders ꟿⱽ 󰲣y󰈲⟥ᐒ␛λ∈lang.opsₛ󰅂 󰈲

 forced to be one char, will not act as object or attr-getter when superscript
escaped_var_specs = var_spec ᴍ py_escape_var ⥉ 𝑠

ℵ(kw=kw,
  kw_pfx=kw_pfx,
  kw_spec=kw_spec,
  kw_pfx_colon=kw_pfx_colon,
  var_spec=var_spec)

🟑

RED, REP = reduction, replacement

KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

𝔗 = 󰲡x.as_txt()

⊢ σ_00():
    @(⮂ REP("lamb_tacit", rec=␛A, n="Reform tacit exprs"))
    ⊢ _(󱁕):
        bl, l, λ, r, br = 󱁕
        bl, l,    r, br = 𝔗(bl), 𝔗(l), 𝔗(r), 𝔗(br)
        ¿λᵗ∈{"exprs", "expr", "expr_norm"}:
            α, β = λ₀ᶜ, λ􍨄ᶜ
        ¡:  α = β = λᶜ
        
        l, r = l ∨ (r⭜␛ᐳ⭝␛ᑀ), r ∨ ␛ᐸ
        
        args, targs = [], [NUM_M1, NUM_M1]
        OP_NAME = "␀TACIT"
        ¿l ∧ l∈"ᑀᐵᐒᐖ":
            ¿¬bl: OP_NAME += ␛L
            ¿l∈"ᑀᐵ": α.insert(0, TAC_L)
            targs₀ = l∈"ᐵᐖ" ⭜NUM_P1⭝ NUM_P0
            args.append(TAC_L)
        ¿r ∧ r∈"ᑅᑈᐘᐛ":
            ¿¬br: OP_NAME += ␛R
            ¿r∈"ᑅᑈ": β.append(   TAC_R)
            targs₁ = r∈"ᑈᐛ" ⭜NUM_P1⭝ NUM_P0
            args.append(TAC_R)
        
        COM = OP.TND(␛,)
        args, targs = args ⨝ COM, targs ⟕ COM
        
        ¿args: args.append(COM)
        args.extend([OP.TND(␛⠤), mkvar(␛𝓐), COM, OP.TND(␛⠶), mkvar(␛𝓚)])
        
        ↪ Ń("oper", ("oper_mod_l", ᐦ),
                    ("oper_lit", OP_NAME),
                    ("oper_mod_r", mkgxp(
                        ("lamb", ("lamb_h_normal", ⠤args),
                                 ("lamb_b", ("norm_expr", λ))),
                        ⠤targs)))

⊢ σ_03():
    @(⮂ REP(⠤KEYWORD_NODE_NAMES, n="Lang keywords → cpy keywords"))
    ⊢ _(󱁕):
        txt = 𝔗(󱁕)
         keyword that are just ops:
        ¿txt∈kw_inline: ↪ OP.TND(KEYWORDS_TO_CPY.get(txt, txt))
        ↪ 󱁕.copy(c=KEYWORDS_TO_CPY.get(txt, txt))
    
    @(⮂ RED("supscript", n="Swap Superscripts"))
    ⊢ _(󱁕):
        t = gram(SCRIPT.nrm(𝔗(󱁕)), "exprs")
        T = lang(txt≕𝔗(t).strip())
        ¿¬T.isidentifier() ∨ T∈escaped_var_specs:
            ↪ [OP.TND(␛⌃), mkgxp_(Node(c=lang(txt)))]
        ↪ [OP.TND(␛.), t]
    
    ((⮂ REP("subscript", rec=␛A, n="Subscripts to brackets"))
    (󱁕↦mkgrp(tree_transform(gram(SCRIPT.nrm(󱁕ᶜ), "exprs"), 3+1), b="[]")))
    
    ((⮂ REP("norm_expr", "expr_not_colon", "expr_not_comma", rec=␛B,
                    n="Normalize expression types"))
    (󱁕↦󱁕.copy("expr")))
    
    ((⮂ REP("W", n="Trim whitespace"))
    (󱁕↦󱁕.copy(c=ń∈󱁕ᶜ ⭜ń+ⵉ(󱁕ᶜ,ń)􍨄⭝ 󱁕ᶜ)))

⊢ σ_05():
    op_chk = ⥌󱁕,o↦󱁕ᵗ≡"oper" ∧ 𝔗(󱁕)≡o
    hs_op  = ⥌C,o↦any(op_chk(c,o) ∀c∈C)

    @(⮂ REP("expr", rec=␛A, n="Detect for_expr"))
    ⊢ _(󱁕):
        ¿¬hs_op(C≔󱁕󰀂, ␛∀): ↪󱁕
        
        α, β = C 󷹎⁰ ρ(op_chk, o=␛∀)
        β, γ = β 󷹎⁰ ρ(op_chk, o=␛∈)
        ¿hs_op(γ, ␛¿):
            γ, σ = γ 󷹎⁰ ρ(op_chk, o=␛¿)
        ¡:  σ = None
        
        cc = [Node("expr", α), Node("expr", β), Node("expr", γ)]
        ¿σ: cc.append(Node("expr", σ, e="cond"))
        ↪ 󱁕.copy("for_expr", c=cc)
    
    @(⮂ REP("kw_pfx_colon_expr", rec=␛A, n="Detect for_stmt"))
    ⊢ _(󱁕):
        ¿¬op_chk(󱁕󰀂₀, ␛∀): ↪󱁕
        α, β = 󱁕󰀂₁󰀂 󷹎⁰ ρ(op_chk, o=␛∈)
        ↪ 󱁕.copy("for_stmt", c=[Node("expr", α), Node("expr", β), ⠤N󰀂₂﹕])

⊢ σ_10():
    ((⮂ REP("parser_main", rec=␛A, n="Build whitespace blocks"))
    (whitespace_parser))

⊢ σ_15():
    ((⮂ REP("lamb_h_preset"))
    (󱁕↦Ń("lamb_h", ⠤"xyzwvutsr"[:󱁕⥉𝔗 ⥉ "𝚲󰲡󰲣󰲥󰲧󰲩󰲫󰲭󰲯󰲱".index] ᴍ mkexp○mkvar),
        ARG_A, ARG_K))
    
    ((⮂ REP("lamb_h_implicit"))
    (󱁕↦Ń("lamb_h", 󱁕󰀂₀ ⥉ mkexp, ARG_A, ARG_K)))
    
    @(⮂ REP("lamb_h_normal", "lamb_h_py"))
    ⊢ _(󱁕):
        C = 󱁕󰀂󷹎󰲡OP.is_op(x)∧(k≔op_manₓ)ᵗ≡␛,󰅂 ꟿ mkexp ᴍ Node.strip
        has_a = has_k = ✗
        
        C 󰈲= 𝔗  ∵ "⥌↦" has empty an expr
        ∀c∈C:
            ¿¬c󰀂 ∨ (o≔c󰀂₀)≠"oper": ↺
            k = o󰀂₁ᶜ
            ¿k ∈ {  ␛*, ␛⠤}: has_a = ✓
            ⸘k ∈ {"**", ␛⠶}: has_k = ✓
            ¡              : ↺
            ¿c🃌≡1: c󰀂₀ = Ń("expr_", ␛*⋅(1+←k∈{"**", ␛⠶}))
        ¿¬has_a: C.append(ARG_A)
        ¿¬has_k: C.append(ARG_K)
        ↪ Ń("lamb_h", ⠤C)
    
    ((⮂ REP("lamb_b", rec=␛A))
    (󱁕↦󱁕.copy(t="expr")))

⊢ σ_18():
    @(⮂ REP("expr", rec=␛B, n="Implicit Multiplication"))
    ⊢ _(󱁕):
        ¿¬󱁕󰀂: ↪󱁕
        cc, s = [], peekable(󱁕󰀂)
        ➰✓:
            α = next(s)
            ¿¬s: ⇥
            β = s.peek()
            cc.append(α)
            
            S = { "number"  : {"var", "group", "var_spec", "number"},
                  "var_spec": {"number", "var", "var_spec"} }
             󰤱 condition for 2√2
            ¿   αᵗ∈S ∧ βᵗ∈S󰃤􊫼 ␛
              ∨ βᵗ∈S ∧ αᵗ∈S󰃥􊫼 ␛
              ∨ αᵗ≡"group" ∧ βᵗ≡"var_spec":  󰤱 this is weird
                   cc.append(OP.TND("␀CAT"))
        cc.append(α)
        ↪ 󱁕.copy(c=cc)

⊢ σ_20():
    ((⮂ REP("expr", rec=␛B, n="Parse expressions"))
    (󱁕↦󱁕.copy(c=into_expr(parse_expr(󱁕󰀂))ᶜ)))

⊢ σ_21():
    ⊢ split_target(l):
        l, t = l.copy(), []
        ➰l:
            α = l.pop()
            ¿α≡␛.         : ↪ ␛., l, t₀
            ¿α.t≡"op_call":
                ⨳ 𝔗(α󰀂₁)≡␛.
                l += [⠤α󰀂₀, ␛., ⠤α󰀂₂]
                ↺
            ¿α.t≡"group" ∧ 𝔗(α󰀂₀)≡␛[ ∧ 𝔗(α󰀂₂)≡␛]:
                ↪ ␛l, l, α󰀂₁
            t.insert(0, α)
        ⨳ t🃌≡1
        ↪ ᐦ, ᗜ, t₀

    ⊢ mk_inline_asgn(α, Σ, β):  optimization: pull out some constant nodes
        τ, κ, χ = split_target(α󰀂)
        
        ¿τ≡ᐦ: ↪ mkgrp(mknex_(χ, mkgxp(ΣᐹNode ⭜("op_call", mkexp(χ), Σ, β)⭝ β)))
        
        ρ = τ≡␛. ⭜"ATTR"⭝ "ITEM"
        κ = mkgxp(⠤((i≡␛. ⭜Node("expr_", ␛.)⭝ i) ∀i∈κ))
        χ = mkgxp(ρ≡"ATTR" ⭜("str_", ‹"⟦χ ⥉ 𝔗 ⥉ py_escape_var⟧"›)⭝ χ)
        
        ST, GT = mkvar("SET"+ρ), mkvar("GET"+ρ)
        ¿Σ≡␛≔: ↪ fcall_(ST, κ, χ, β, NUM_P0)
        ¿Σ≡␛≕: ↪ fcall_(ST, β, κ, χ, NUM_P1)
        
        ↪ fcall_(ST,
            fcall_(þPSH, κ),
            fcall_(þPSH, χ),
            Node("op_call", [
                fcall_(GT, þPOP_M2, þPOP_M1), Σ, β]),
            NUM_P0)
    
    @(⮂ REP("op_call", rec=␛A, n="Refactor assignment infix opertators"))
    ⊢ _(󱁕):
        α, Σ, β = 󱁕󰀂
        ¿𝔗(Σ󰀂₀) ∨ 𝔗(Σ󰀂₂): ↪󱁕
        txt = 𝔗(Σ)
        ¿txt≡␛≔ ∨ txt≡":=": ↪ mk_inline_asgn(α, ␛≔, β)
        ¿txt≡␛≕           : ↪ mk_inline_asgn(β, ␛≕, α)
        ¿␛=∉lang.opsₜₓₜ   : ↪ 󱁕
        ↪ mk_inline_asgn(α, OP.TND(txt﹕􍨄), β)

⊢ σ_25():
    ((⮂ RED("op_call", rec=␛B, n="Flatten cmp ops"))(
        󱁕↦␛λ∈op_man􋑺􊻍􊬤 ∧ 󱁕󰀂₀≠NULL≠󱁕󰀂₂ ⭜ [⠤󱁕󰀂₀󰀂, 󱁕󰀂₁, ⠤󱁕󰀂₂󰀂] ⭝ [󱁕]))

⊢ σ_30():
    ⊢ make_cmp_chain(󱁕, layers=ᗜ):
        layers = layers ∨ OPS_COMP
        layer, ⠤layers = layers
        
        rec       = 󱁕↦layers ⭜make_cmp_chain(󱁕, layers=layers)⭝ 󱁕
        mkexp_rec = 󱁕↦rec(mkexp(⠤󱁕))
        
        C = 󱁕󰀂 𝌂 󰲡OP.is_op(x) ∧ (k≔op_manₓ)ᵗ∈layer ∧ kᴮ ⥉𝑏
        ¿C🃌 < 3: ↪rec(󱁕)
        r = ✗
        
        ∀H,T,(a,(b,),c) ∈ mark_ends(windowed(C, 3, step=2)):
            c = mkexp_rec(c)
            v = mkexp(("op_call",
                H ∧ mkexp_rec(a) ∨ þþ,
                b,
                T ∧ c ∨ mknex_(þþ, c)))
            r = r ⭜mkexp(("op_call", r, OP.TND(␛∧), v))⭝ v
        ↪ 󱁕.copy(c=[r])
    ((⮂ REP("expr", rec=␛B, n="Generate comparison chains"))
    (make_cmp_chain))

demodp = o↦(𝔗(o󰂕􊬣), o󰀂₁, o󰀂₂󰀒 ⭜𝔗(o󰀂₂)⭝ o󰀂₂)
⊢ mkbltnop(op_l):  format builtins ¿ needed
    t = SWAP_TABLE.get(t ≔ 𝔗(op_l), t)
    ¿t∉OPS_BUILTIN􊯛󰂓: ↪ op_l
    ↪ mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
⊢ transform_oper(op_):  apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
     ¿op_l∈"¿¡⭜⭝":  󰤱
    ¿m_l 󷺥 m_r: ↪ op_l
    op_n = mkbltnop(op_l)
    mkmod = ⥌op,x↦mkexp(mkvar(‹OP_⟦x⟧›), mkgrp(op))
    
    ¿␛≺∈m_l: op_n = mkmod(op_n, "BSTAR")
    ¿␛⟥∈m_l: op_n = mkmod(op_n, "LNULL")
    
    ¿m_rᐹNode: ↪ mkexp(op_n, mkgxp(m_r, b="[]"))
    rmods = ᐦ
    ∀m∈m_r:
        ¿m∈"⟤ᵜ꜠´":
            ¿m≡␛⟤: op_n = mkmod(op_n, "RNULL")
            ⸘m≡␛ᵜ: op_n = mkmod(op_n, "SWAPA")
            ⸘m≡␛꜠: op_n = mkmod(op_n, "DUPER")
        ¡        : rmods += m
    ¿¬rmods: ↪op_n
    o = ␛χ∈op_man[op_] ⭜𝑠()⭝ ascii_uppercase
    rmods = ((FS(x)⊂o ⭜‹"⟦x⟧"›⭝ lang(x)) ∀x∈SCRIPT.nrm(rmods)󷹎␛𐞑)⨝␛,
    ↪ mkexp(op_n, Node("expr_", ‹[⟦rmods⟧]›))

⊢ σ_35():
    hnul = 󰲡x≡"NULL"⭜x.copy("NULL_")⭝x
    
    ⊢ try_builtin(m, op_l, L, m_l, t, m_r, R):  see ¿ op + arg matches can make a builtin
        ¿m_l ∨ m_r ∨ SWAP_TABLE.get(t, t) ∉ OPS_BUILTINₘ: ↪
        ↪ mkgxp(⠤ε(L), op_l, ⠤ε(R))

    ⊢ make_if(t, l, r, m_l, m_r):
        ↪ Ń(t, l, r, m_l, m_r)
    ⊢ make_el(t, l, r, m_l, m_r):
        ⨳ l₀ᵗ∈␛⭜␛¿
        ¿t≡␛⭝: ↪mkgxp(l₀ ₁, OP.TND(␛¿), l₀ ₀, OP.TND(␛¡), r)
        ¿t≡␛¡: ↪mkgxp(l₀ ₀, OP.TND(␛¿), l₀ ₁, OP.TND(␛¡), r)

    @(⮂ REP("op_call", rec=␛B, n="Refactor op calls"))
    ⊢ _(󱁕):
        l, op_, r = 󱁕󰀂
        op = op_man󰂼ₚ􋕞
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = l≠NULL ∧ mkgrp(l), r≠NULL ∧ mkgrp(r)
        
        ¿m_l 󷺥 m_r:
            ¿␛β∈op ∧  L∧R: ↪ mkgxp(L, op_l, R)
            ¿␛σ∈op ∧ ¬L∧R: ↪ mkexp(op_l, r)
            ¿␛ι∈op: ↪ mkexp(hnul(l), op_l, hnul(r))
            ¿␛ρ∈op:
                ¿t∈"➡→⭢"    : ↪ L
                ¿t∈"⬅←⭠"    : ↪ R
                ¿t≡␛⥉       : ↪ mkgxp(R, L)
                ¿t≡␛≔       : ↪ mkgxp(l, op_l, R)
                ¿t≡␛≕       : ↪ mkgxp(l, op_l, R)
                ¿t≡␛¬ ∧← L∨R: ↪ mkgxp(op_l, L ∨ R)
        ¿t∈␛⭜␛¿: ↪ make_if(t, l, r, m_l, m_r)
        ¿t∈␛⭝␛¡: ↪ make_el(t, l, r, m_l, m_r)
        ¿t≡␛󷺥: ↪ mkgxp(  x⭜✗⭝y⭜x⭝✓
                    FALSE, OP.TND(␛¿), fcall_(þPSH, 𝓛), OP.TND(␛¡), mkgxp(
                        þPOP_M1, OP.TND(␛¿), 𝓡, OP.TND(␛¡), mkgxp(
                            þPOPNR, Ń("oper_lit", ␛∨), TRUE)))
        ¿t≡␛󷺒: ↪ mkgxp(  x⭜(y⭜✗⭝x)⭝✓
                    mkgxp(
                        mkgxp(þPOPNR, Ń("oper_lit", ␛∨), FALSE),
                            OP.TND(␛¿), 𝓡, OP.TND(␛¡), þPOP_M1),
                    OP.TND(␛¿), fcall_(þPSH, 𝓛), OP.TND(␛¡), TRUE)
        
        A = (transform_oper(op_), L, m_l, t, m_r, R)
        tb, mblo = try_builtin, mkbltnop
        ¿op󰀒∧L  ∧¬opᴮ: ↪ tb(␛S, ⠤A) ∨ mkexp(mblo(op_), L)
        ¿opᴾ  ∧R∧¬opᴮ: ↪ tb(␛P, ⠤A) ∨ mkexp(mblo(op_), R)
        ¿opᴮ∧L∧R     : ↪ tb(␛B, ⠤A) ∨ mkexp(mblo(op_), mkgxp(   l, COMMA,    r))
        ¿op󰀒∧L       : ↪ tb(␛S, ⠤A) ∨ mkexp(mblo(op_), mkgxp(   l, COMMA, NULL))
        ¿opᴾ  ∧R     : ↪ tb(␛P, ⠤A) ∨ mkexp(mblo(op_), mkgxp(NULL, COMMA,    r))
        ¿opᴺ∧␛ν ∈ op : ↪ mkexp(mblo(op_), mkgxp())
        ↪ mkbltnop(op_)

⊢ σ_36():
    ((⮂ REP(␛⭜, rec=␛B, n="Refactor ⭝-less ⭜"))(
        󱁕↦mkgxp(󱁕₁, OP.TND(␛¿), n₀, OP.TND(␛¡), mkvar("None"))))

⊢ σ_40():
    @(⮂ REP("oper", rec=␛A, n="Refactor sitting ops"))
    ⊢ _(󱁕):
        ¿𝔗(󱁕󰀂₁) ∈ kw_neverswouce: ↪󱁕
        ¿𝔗(󱁕󰀂₂) 󷺥 𝔗(󱁕󰀂₀): 󱁕 = 󱁕.copy(c=[󱁕󰀂₀, 󱁕󰀂₁, 󱁕󰀂₂.copy(c=␛´)])
        ↪transform_oper(󱁕)
    
    ((⮂ REP(⠤KEYWORD_NODE_NAMES, "oper_lit", n="Lang keywords ← cpy keywords"))
    (󱁕↦󱁕.copy(c=py_escape_var(SWAP_TABLE.get(txt≔𝔗(󱁕), txt)))))
    
    ((⮂ REP("lamb", rec=␛B, n="Format lambda"))
    (󱁕↦mkgxp(󱁕󰀂₀, mkgrp(󱁕󰀂₁))))
    
    ((⮂ REP("lamb_h", rec=␛B, n="Format lambda header"))
    (󱁕↦Ń("lamb_h", ("kw", "lambda"), ⠤J́(󱁕󰀂, COMMA), ("oper_lit", ␛:))))

⊢ σ_45():
    ((⮂ REP("parser_main", rec=␛A, n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((⮂ RED("BLOCK", rec=␛B, n="Flatten blocks"))
    (󱁕↦󱁕󰀂))

⊢ σ_48():
    ((⮂ REP("for_expr", rec=␛B, n="Build for exprs"))
    (󱁕↦Ń("expr",
         󱁕󰀂₀, ("kw", "for"), 󱁕󰀂₁, ("kw", "in"), 󱁕󰀂₂,
         ⠤(󱁕􋕨󰂼ₙ􋕨 ⭜ [("kw", ␛¿), 󱁕󰀂₃] ⭝ []))))
    
    ((⮂ REP("for_stmt", rec=␛B, n="Build for stmt"))
    (󱁕↦Ń("kw_pfx_colon_expr",
            ("kw_pfx_colon", "for"),
            ("expr", 󱁕󰀂₀, ("kw", "in"), 󱁕󰀂₁),
            ⠤󱁕󰀂₂﹕)))

⊢ σ_50():
    ((⮂ REP("kw_pfx_colon_expr", rec=␛B, n="Add colons"))
    (󱁕↦󱁕.insert_after_marker(␛M, COLON)))
    
    ((⮂ REP("parser_main", rec=␛B, n="Insert spaces"))
    (ρ(add_spaces, ignore_nodes=("str_cpy", "str_py", "str_star", "str_$"))))

 §§§ node transpilers §§§
generator(⠤KEYWORD_NODE_NAMES, ⠤‹oper_lit var var_spec›⍭)(py_escape_var○𝔗)
generator("NULL")(󰻾􋕩ᴺᵁᴸᴸ􋕩)

generator("group")(𝔗(󱁕󰀂₀) + (󱁕󰀂₁﹕􍨄 ᴍ gen)⨝ᐦ + 𝔗(󱁕󰀂􍨄))

generator("str_guts"              )(󱁕 ↦      py_escape_string (󱁕⥉𝔗)     )
generator("str_escape", "str_star")(󱁕 ↦ ␛' + py_escape_string (󱁕⥉𝔗) + ␛')
generator("str_sub"               )(󱁕 ↦ ␛{ + gen(󱁕󰀂₀)                + ␛})
generator("str_spec_char"         )(󱁕 ↦ ␛' + py_special_mapper(󱁕⥉𝔗) + ␛')

⊢ make_str_cpy(󱁕):
    r=‹""f"›
    ∀c∈󱁕ᶜ:
        ¿cᵗ≡"str_escape"   : r += py_escape_string (c⥉𝔗)
        ⸘cᵗ≡"str_spec_char": r += py_special_mapper(c⥉𝔗)
        ¡                  : r += gen(c)
    ↪ r + ␛"

generator("neg_num")(󱁕↦‹(-⟦󱁕⥉𝔗 ⥉ UPSIDEDOWNSYNDROME.flip⟧)›)
generator("str_cpy")(make_str_cpy)

@generator("str_$")
⊢ make_str_money(󱁕):
    s, ⠤C = 󱁕ᶜ
    ↪ ‹SUBPROCA(⟦󱁕.copy(c=C)⥉make_str_cpy⟧,"⟦s⥉𝔗 ⥉ SCRIPT.nrm ⥉ py_escape_string⟧")›