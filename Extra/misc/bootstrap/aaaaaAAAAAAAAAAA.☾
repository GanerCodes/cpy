RED, REP = reduction, replacement

KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

ğ”— = ó°²¡x.as_txt()

âŠ¢ Ïƒ_00():
    @(â®‚ REP("lamb_tacit", rec=â›A, n="Reform tacit exprs"))
    âŠ¢ _(ó±•):
        bl, l, Î», r, br = ó±•
        bl, l,    r, br = ğ”—(bl), ğ”—(l), ğ”—(r), ğ”—(br)
        Â¿Î»áµ—âˆˆ{"exprs", "expr", "expr_norm"}:
            Î±, Î² = Î»â‚€á¶œ, Î»ô¨„á¶œ
        Â¡:  Î± = Î² = Î»á¶œ
        
        l, r = l âˆ¨ (râ­œâ›á³â­â›á‘€), r âˆ¨ â›á¸
        
        args, targs = [], [NUM_M1, NUM_M1]
        OP_NAME = "â€TACIT"
        Â¿l âˆ§ lâˆˆ"á‘€áµá’á–":
            Â¿Â¬bl: OP_NAME += â›L
            Â¿lâˆˆ"á‘€áµ": Î±.insert(0, TAC_L)
            targsâ‚€ = lâˆˆ"áµá–" â­œNUM_P1â­ NUM_P0
            args.append(TAC_L)
        Â¿r âˆ§ râˆˆ"á‘…á‘ˆá˜á›":
            Â¿Â¬br: OP_NAME += â›R
            Â¿râˆˆ"á‘…á‘ˆ": Î².append(   TAC_R)
            targsâ‚ = râˆˆ"á‘ˆá›" â­œNUM_P1â­ NUM_P0
            args.append(TAC_R)
        
        COM = OP.TND(â›,)
        args, targs = args â¨ COM, targs âŸ• COM
        
        Â¿args: args.append(COM)
        args.extend([OP.TND(â›â ¤), mkvar(â›ğ“), COM, OP.TND(â›â ¶), mkvar(â›ğ“š)])
        
        â†ª Åƒ("oper", ("oper_mod_l", á¦),
                    ("oper_lit", OP_NAME),
                    ("oper_mod_r", mkgxp(
                        ("lamb", ("lamb_h_normal", â ¤args),
                                 ("lamb_b", ("norm_expr", Î»))),
                        â ¤targs)))

âŠ¢ Ïƒ_03():
    @(â®‚ REP(â ¤KEYWORD_NODE_NAMES, n="Lang keywords â†’ cpy keywords"))
    âŠ¢ _(ó±•):
        txt = ğ”—(ó±•)
        î¬¦ keyword that are just ops:
        Â¿txtâˆˆkw_inline: â†ª OP.TND(KEYWORDS_TO_CPY.get(txt, txt))
        â†ª ó±•.copy(c=KEYWORDS_TO_CPY.get(txt, txt))
    
    @(â®‚ RED("supscript", n="Swap Superscripts"))
    âŠ¢ _(ó±•):
        t = gram(SCRIPT.nrm(ğ”—(ó±•)), "exprs")
        T = lang(txtâ‰•ğ”—(t).strip())
        Â¿Â¬T.isidentifier() âˆ¨ Tâˆˆescaped_var_specs:
            â†ª [OP.TND(â›âŒƒ), mkgxp_(Node(c=lang(txt)))]
        â†ª [OP.TND(â›.), t]
    
    ((â®‚ REP("subscript", rec=â›A, n="Subscripts to brackets"))
    (ó±•â†¦mkgrp(tree_transform(gram(SCRIPT.nrm(ó±•á¶œ), "exprs"), 3+1), b="[]")))
    
    ((â®‚ REP("norm_expr", "expr_not_colon", "expr_not_comma", rec=â›B,
                    n="Normalize expression types"))
    (ó±•â†¦ó±•.copy("expr")))
    
    ((â®‚ REP("W", n="Trim whitespace"))
    (ó±•â†¦ó±•.copy(c=Å„âˆˆó±•á¶œ â­œÅ„+âµ‰(ó±•á¶œ,Å„)ô¨„â­ ó±•á¶œ)))

âŠ¢ Ïƒ_05():
    op_chk = â¥Œó±•,oâ†¦ó±•áµ—â‰¡"oper" âˆ§ ğ”—(ó±•)â‰¡o
    hs_op  = â¥ŒC,oâ†¦any(op_chk(c,o) âˆ€câˆˆC)

    @(â®‚ REP("expr", rec=â›A, n="Detect for_expr"))
    âŠ¢ _(ó±•):
        Â¿Â¬hs_op(Câ‰”ó±•ó°€‚, â›âˆ€): â†ªó±•
        
        Î±, Î² = C ó·¹â° Ï(op_chk, o=â›âˆ€)
        Î², Î³ = Î² ó·¹â° Ï(op_chk, o=â›âˆˆ)
        Â¿hs_op(Î³, â›Â¿):
            Î³, Ïƒ = Î³ ó·¹â° Ï(op_chk, o=â›Â¿)
        Â¡:  Ïƒ = None
        
        cc = [Node("expr", Î±), Node("expr", Î²), Node("expr", Î³)]
        Â¿Ïƒ: cc.append(Node("expr", Ïƒ, e="cond"))
        â†ª ó±•.copy("for_expr", c=cc)
    
    @(â®‚ REP("kw_pfx_colon_expr", rec=â›A, n="Detect for_stmt"))
    âŠ¢ _(ó±•):
        Â¿Â¬op_chk(ó±•ó°€‚â‚€, â›âˆ€): â†ªó±•
        Î±, Î² = ó±•ó°€‚â‚ó°€‚ ó·¹â° Ï(op_chk, o=â›âˆˆ)
        â†ª ó±•.copy("for_stmt", c=[Node("expr", Î±), Node("expr", Î²), â ¤Nó°€‚â‚‚ï¹•])

âŠ¢ Ïƒ_10():
    ((â®‚ REP("parser_main", rec=â›A, n="Build whitespace blocks"))
    (whitespace_parser))

âŠ¢ Ïƒ_15():
    ((â®‚ REP("lamb_h_preset"))
    (ó±•â†¦Åƒ("lamb_h", â ¤"xyzwvutsr"[:ó±•â¥‰ğ”— â¥‰ "ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«ó°²­ó°²¯ó°²±".index] á´ mkexpâ—‹mkvar),
        ARG_A, ARG_K))
    
    ((â®‚ REP("lamb_h_implicit"))
    (ó±•â†¦Åƒ("lamb_h", ó±•ó°€‚â‚€ â¥‰ mkexp, ARG_A, ARG_K)))
    
    @(â®‚ REP("lamb_h_normal", "lamb_h_py"))
    âŠ¢ _(ó±•):
        C = ó±•ó°€‚ó·¹ó°²¡OP.is_op(x)âˆ§(kâ‰”op_manâ‚“)áµ—â‰¡â›,ó°…‚ êŸ¿ mkexp á´ Node.strip
        has_a = has_k = âœ—
        
        C ó°ˆ²= ğ”— î¬¦ âˆµ "â¥Œâ†¦" has empty an expr
        âˆ€câˆˆC:
            Â¿Â¬có°€‚ âˆ¨ (oâ‰”có°€‚â‚€)â‰ "oper": â†º
            k = oó°€‚â‚á¶œ
            Â¿k âˆˆ {  â›*, â›â ¤}: has_a = âœ“
            â¸˜k âˆˆ {"**", â›â ¶}: has_k = âœ“
            Â¡              : â†º
            Â¿cğŸƒŒâ‰¡1: có°€‚â‚€ = Åƒ("expr_", â›*â‹…(1+â†kâˆˆ{"**", â›â ¶}))
        Â¿Â¬has_a: C.append(ARG_A)
        Â¿Â¬has_k: C.append(ARG_K)
        â†ª Åƒ("lamb_h", â ¤C)
    
    ((â®‚ REP("lamb_b", rec=â›A))
    (ó±•â†¦ó±•.copy(t="expr")))

âŠ¢ Ïƒ_18():
    @(â®‚ REP("expr", rec=â›B, n="Implicit Multiplication"))
    âŠ¢ _(ó±•):
        Â¿Â¬ó±•ó°€‚: â†ªó±•
        cc, s = [], peekable(ó±•ó°€‚)
        â°âœ“:
            Î± = next(s)
            Â¿Â¬s: â‡¥
            Î² = s.peek()
            cc.append(Î±)
            
            S = { "number"  : {"var", "group", "var_spec", "number"},
                  "var_spec": {"number", "var", "var_spec"} }
            î¬¦ ó°¤± condition for 2âˆš2
            Â¿   Î±áµ—âˆˆS âˆ§ Î²áµ—âˆˆSó°ƒ¤ôŠ«¼ â›
              âˆ¨ Î²áµ—âˆˆS âˆ§ Î±áµ—âˆˆSó°ƒ¥ôŠ«¼ â›
              âˆ¨ Î±áµ—â‰¡"group" âˆ§ Î²áµ—â‰¡"var_spec": î¬¦ ó°¤± this is weird
                   cc.append(OP.TND("â€CAT"))
        cc.append(Î±)
        â†ª ó±•.copy(c=cc)

âŠ¢ Ïƒ_20():
    ((â®‚ REP("expr", rec=â›B, n="Parse expressions"))
    (ó±•â†¦ó±•.copy(c=into_expr(parse_expr(ó±•ó°€‚))á¶œ)))

âŠ¢ Ïƒ_21():
    âŠ¢ split_target(l):
        l, t = l.copy(), []
        â°l:
            Î± = l.pop()
            Â¿Î±â‰¡â›.         : â†ª â›., l, tâ‚€
            Â¿Î±.tâ‰¡"op_call":
                â¨³ ğ”—(Î±ó°€‚â‚)â‰¡â›.
                l += [â ¤Î±ó°€‚â‚€, â›., â ¤Î±ó°€‚â‚‚]
                â†º
            Â¿Î±.tâ‰¡"group" âˆ§ ğ”—(Î±ó°€‚â‚€)â‰¡â›[ âˆ§ ğ”—(Î±ó°€‚â‚‚)â‰¡â›]:
                â†ª â›l, l, Î±ó°€‚â‚
            t.insert(0, Î±)
        â¨³ tğŸƒŒâ‰¡1
        â†ª á¦, á—œ, tâ‚€

    âŠ¢ mk_inline_asgn(Î±, Î£, Î²): î¬¦ optimization: pull out some constant nodes
        Ï„, Îº, Ï‡ = split_target(Î±ó°€‚)
        
        Â¿Ï„â‰¡á¦: â†ª mkgrp(mknex_(Ï‡, mkgxp(Î£á¹Node â­œ("op_call", mkexp(Ï‡), Î£, Î²)â­ Î²)))
        
        Ï = Ï„â‰¡â›. â­œ"ATTR"â­ "ITEM"
        Îº = mkgxp(â ¤((iâ‰¡â›. â­œNode("expr_", â›.)â­ i) âˆ€iâˆˆÎº))
        Ï‡ = mkgxp(Ïâ‰¡"ATTR" â­œ("str_", â€¹"âŸ¦Ï‡ â¥‰ ğ”— â¥‰ py_escape_varâŸ§"â€º)â­ Ï‡)
        
        ST, GT = mkvar("SET"+Ï), mkvar("GET"+Ï)
        Â¿Î£â‰¡â›â‰”: â†ª fcall_(ST, Îº, Ï‡, Î², NUM_P0)
        Â¿Î£â‰¡â›â‰•: â†ª fcall_(ST, Î², Îº, Ï‡, NUM_P1)
        
        â†ª fcall_(ST,
            fcall_(Ã¾PSH, Îº),
            fcall_(Ã¾PSH, Ï‡),
            Node("op_call", [
                fcall_(GT, Ã¾POP_M2, Ã¾POP_M1), Î£, Î²]),
            NUM_P0)
    
    @(â®‚ REP("op_call", rec=â›A, n="Refactor assignment infix opertators"))
    âŠ¢ _(ó±•):
        Î±, Î£, Î² = ó±•ó°€‚
        Â¿ğ”—(Î£ó°€‚â‚€) âˆ¨ ğ”—(Î£ó°€‚â‚‚): â†ªó±•
        txt = ğ”—(Î£)
        Â¿txtâ‰¡â›â‰” âˆ¨ txtâ‰¡":=": â†ª mk_inline_asgn(Î±, â›â‰”, Î²)
        Â¿txtâ‰¡â›â‰•           : â†ª mk_inline_asgn(Î², â›â‰•, Î±)
        Â¿â›=âˆ‰lang.opsâ‚œâ‚“â‚œ   : â†ª ó±•
        â†ª mk_inline_asgn(Î±, OP.TND(txtï¹•ô¨„), Î²)

âŠ¢ Ïƒ_25():
    ((â®‚ RED("op_call", rec=â›B, n="Flatten cmp ops"))(
        ó±•â†¦â›Î»âˆˆop_manô‹‘ºôŠ»ôŠ¬¤ âˆ§ ó±•ó°€‚â‚€â‰ NULLâ‰ ó±•ó°€‚â‚‚ â­œ [â ¤ó±•ó°€‚â‚€ó°€‚, ó±•ó°€‚â‚, â ¤ó±•ó°€‚â‚‚ó°€‚] â­ [ó±•]))

âŠ¢ Ïƒ_30():
    âŠ¢ make_cmp_chain(ó±•, layers=á—œ):
        layers = layers âˆ¨ OPS_COMP
        layer, â ¤layers = layers
        
        rec       = ó±•â†¦layers â­œmake_cmp_chain(ó±•, layers=layers)â­ ó±•
        mkexp_rec = ó±•â†¦rec(mkexp(â ¤ó±•))
        
        C = ó±•ó°€‚ ğŒ‚ ó°²¡OP.is_op(x) âˆ§ (kâ‰”op_manâ‚“)áµ—âˆˆlayer âˆ§ ká´® â¥‰ğ‘
        Â¿CğŸƒŒ < 3: â†ªrec(ó±•)
        r = âœ—
        
        âˆ€H,T,(a,(b,),c) âˆˆ mark_ends(windowed(C, 3, step=2)):
            c = mkexp_rec(c)
            v = mkexp(("op_call",
                H âˆ§ mkexp_rec(a) âˆ¨ Ã¾Ã¾,
                b,
                T âˆ§ c âˆ¨ mknex_(Ã¾Ã¾, c)))
            r = r â­œmkexp(("op_call", r, OP.TND(â›âˆ§), v))â­ v
        â†ª ó±•.copy(c=[r])
    ((â®‚ REP("expr", rec=â›B, n="Generate comparison chains"))
    (make_cmp_chain))

demodp = oâ†¦(ğ”—(oó°‚•ôŠ¬£), oó°€‚â‚, oó°€‚â‚‚ó°€’ â­œğ”—(oó°€‚â‚‚)â­ oó°€‚â‚‚)
âŠ¢ mkbltnop(op_l): î¬¦ format builtins Â¿ needed
    t = SWAP_TABLE.get(t â‰” ğ”—(op_l), t)
    Â¿tâˆ‰OPS_BUILTINôŠ¯›ó°‚“: â†ª op_l
    â†ª mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
âŠ¢ transform_oper(op_): î¬¦ apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    î¬¦ Â¿op_lâˆˆ"Â¿Â¡â­œâ­": î¬¦ ó°¤±
    Â¿m_l ó·º¥ m_r: â†ª op_l
    op_n = mkbltnop(op_l)
    mkmod = â¥Œop,xâ†¦mkexp(mkvar(â€¹OP_âŸ¦xâŸ§â€º), mkgrp(op))
    
    Â¿â›â‰ºâˆˆm_l: op_n = mkmod(op_n, "BSTAR")
    Â¿â›âŸ¥âˆˆm_l: op_n = mkmod(op_n, "LNULL")
    
    Â¿m_rá¹Node: â†ª mkexp(op_n, mkgxp(m_r, b="[]"))
    rmods = á¦
    âˆ€mâˆˆm_r:
        Â¿mâˆˆ"âŸ¤áµœêœ Â´":
            Â¿mâ‰¡â›âŸ¤: op_n = mkmod(op_n, "RNULL")
            â¸˜mâ‰¡â›áµœ: op_n = mkmod(op_n, "SWAPA")
            â¸˜mâ‰¡â›êœ : op_n = mkmod(op_n, "DUPER")
        Â¡        : rmods += m
    Â¿Â¬rmods: â†ªop_n
    o = â›Ï‡âˆˆop_man[op_] â­œğ‘ ()â­ ascii_uppercase
    rmods = ((FS(x)âŠ‚o â­œâ€¹"âŸ¦xâŸ§"â€ºâ­ lang(x)) âˆ€xâˆˆSCRIPT.nrm(rmods)ó·¹â›ğ‘)â¨â›,
    â†ª mkexp(op_n, Node("expr_", â€¹[âŸ¦rmodsâŸ§]â€º))

âŠ¢ Ïƒ_35():
    hnul = ó°²¡xâ‰¡"NULL"â­œx.copy("NULL_")â­x
    
    âŠ¢ try_builtin(m, op_l, L, m_l, t, m_r, R): î¬¦ see Â¿ op + arg matches can make a builtin
        Â¿m_l âˆ¨ m_r âˆ¨ SWAP_TABLE.get(t, t) âˆ‰ OPS_BUILTINâ‚˜: â†ª
        â†ª mkgxp(â ¤Îµ(L), op_l, â ¤Îµ(R))

    âŠ¢ make_if(t, l, r, m_l, m_r):
        â†ª Åƒ(t, l, r, m_l, m_r)
    âŠ¢ make_el(t, l, r, m_l, m_r):
        â¨³ lâ‚€áµ—âˆˆâ›â­œâ›Â¿
        Â¿tâ‰¡â›â­: â†ªmkgxp(lâ‚€ â‚, OP.TND(â›Â¿), lâ‚€ â‚€, OP.TND(â›Â¡), r)
        Â¿tâ‰¡â›Â¡: â†ªmkgxp(lâ‚€ â‚€, OP.TND(â›Â¿), lâ‚€ â‚, OP.TND(â›Â¡), r)

    @(â®‚ REP("op_call", rec=â›B, n="Refactor op calls"))
    âŠ¢ _(ó±•):
        l, op_, r = ó±•ó°€‚
        op = op_manó°‚¼â‚šô‹•
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = lâ‰ NULL âˆ§ mkgrp(l), râ‰ NULL âˆ§ mkgrp(r)
        
        Â¿m_l ó·º¥ m_r:
            Â¿â›Î²âˆˆop âˆ§  Lâˆ§R: â†ª mkgxp(L, op_l, R)
            Â¿â›Ïƒâˆˆop âˆ§ Â¬Lâˆ§R: â†ª mkexp(op_l, r)
            Â¿â›Î¹âˆˆop: â†ª mkexp(hnul(l), op_l, hnul(r))
            Â¿â›Ïâˆˆop:
                Â¿tâˆˆ"â¡â†’â­¢"    : â†ª L
                Â¿tâˆˆ"â¬…â†â­ "    : â†ª R
                Â¿tâ‰¡â›â¥‰       : â†ª mkgxp(R, L)
                Â¿tâ‰¡â›â‰”       : â†ª mkgxp(l, op_l, R)
                Â¿tâ‰¡â›â‰•       : â†ª mkgxp(l, op_l, R)
                Â¿tâ‰¡â›Â¬ âˆ§â† Lâˆ¨R: â†ª mkgxp(op_l, L âˆ¨ R)
        Â¿tâˆˆâ›â­œâ›Â¿: â†ª make_if(t, l, r, m_l, m_r)
        Â¿tâˆˆâ›â­â›Â¡: â†ª make_el(t, l, r, m_l, m_r)
        Â¿tâ‰¡â›ó·º¥: â†ª mkgxp( î¬¦ xâ­œâœ—â­yâ­œxâ­âœ“
                    FALSE, OP.TND(â›Â¿), fcall_(Ã¾PSH, ğ“›), OP.TND(â›Â¡), mkgxp(
                        Ã¾POP_M1, OP.TND(â›Â¿), ğ“¡, OP.TND(â›Â¡), mkgxp(
                            Ã¾POPNR, Åƒ("oper_lit", â›âˆ¨), TRUE)))
        Â¿tâ‰¡â›ó·º’: â†ª mkgxp( î¬¦ xâ­œ(yâ­œâœ—â­x)â­âœ“
                    mkgxp(
                        mkgxp(Ã¾POPNR, Åƒ("oper_lit", â›âˆ¨), FALSE),
                            OP.TND(â›Â¿), ğ“¡, OP.TND(â›Â¡), Ã¾POP_M1),
                    OP.TND(â›Â¿), fcall_(Ã¾PSH, ğ“›), OP.TND(â›Â¡), TRUE)
        
        A = (transform_oper(op_), L, m_l, t, m_r, R)
        tb, mblo = try_builtin, mkbltnop
        Â¿opó°€’âˆ§L  âˆ§Â¬opá´®: â†ª tb(â›S, â ¤A) âˆ¨ mkexp(mblo(op_), L)
        Â¿opá´¾  âˆ§Râˆ§Â¬opá´®: â†ª tb(â›P, â ¤A) âˆ¨ mkexp(mblo(op_), R)
        Â¿opá´®âˆ§Lâˆ§R     : â†ª tb(â›B, â ¤A) âˆ¨ mkexp(mblo(op_), mkgxp(   l, COMMA,    r))
        Â¿opó°€’âˆ§L       : â†ª tb(â›S, â ¤A) âˆ¨ mkexp(mblo(op_), mkgxp(   l, COMMA, NULL))
        Â¿opá´¾  âˆ§R     : â†ª tb(â›P, â ¤A) âˆ¨ mkexp(mblo(op_), mkgxp(NULL, COMMA,    r))
        Â¿opá´ºâˆ§â›Î½ âˆˆ op : â†ª mkexp(mblo(op_), mkgxp())
        â†ª mkbltnop(op_)

âŠ¢ Ïƒ_36():
    ((â®‚ REP(â›â­œ, rec=â›B, n="Refactor â­-less â­œ"))(
        ó±•â†¦mkgxp(ó±•â‚, OP.TND(â›Â¿), nâ‚€, OP.TND(â›Â¡), mkvar("None"))))

âŠ¢ Ïƒ_40():
    @(â®‚ REP("oper", rec=â›A, n="Refactor sitting ops"))
    âŠ¢ _(ó±•):
        Â¿ğ”—(ó±•ó°€‚â‚) âˆˆ kw_neverswouce: â†ªó±•
        Â¿ğ”—(ó±•ó°€‚â‚‚) ó·º¥ ğ”—(ó±•ó°€‚â‚€): ó±• = ó±•.copy(c=[ó±•ó°€‚â‚€, ó±•ó°€‚â‚, ó±•ó°€‚â‚‚.copy(c=â›Â´)])
        â†ªtransform_oper(ó±•)
    
    ((â®‚ REP(â ¤KEYWORD_NODE_NAMES, "oper_lit", n="Lang keywords â† cpy keywords"))
    (ó±•â†¦ó±•.copy(c=py_escape_var(SWAP_TABLE.get(txtâ‰”ğ”—(ó±•), txt)))))
    
    ((â®‚ REP("lamb", rec=â›B, n="Format lambda"))
    (ó±•â†¦mkgxp(ó±•ó°€‚â‚€, mkgrp(ó±•ó°€‚â‚))))
    
    ((â®‚ REP("lamb_h", rec=â›B, n="Format lambda header"))
    (ó±•â†¦Åƒ("lamb_h", ("kw", "lambda"), â ¤JÌ(ó±•ó°€‚, COMMA), ("oper_lit", â›:))))

âŠ¢ Ïƒ_45():
    ((â®‚ REP("parser_main", rec=â›A, n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((â®‚ RED("BLOCK", rec=â›B, n="Flatten blocks"))
    (ó±•â†¦ó±•ó°€‚))

âŠ¢ Ïƒ_48():
    ((â®‚ REP("for_expr", rec=â›B, n="Build for exprs"))
    (ó±•â†¦Åƒ("expr",
         ó±•ó°€‚â‚€, ("kw", "for"), ó±•ó°€‚â‚, ("kw", "in"), ó±•ó°€‚â‚‚,
         â ¤(ó±•ô‹•¨î ó°‚¼â‚™î ô‹•¨ â­œ [("kw", â›Â¿), ó±•ó°€‚â‚ƒ] â­ []))))
    
    ((â®‚ REP("for_stmt", rec=â›B, n="Build for stmt"))
    (ó±•â†¦Åƒ("kw_pfx_colon_expr",
            ("kw_pfx_colon", "for"),
            ("expr", ó±•ó°€‚â‚€, ("kw", "in"), ó±•ó°€‚â‚),
            â ¤ó±•ó°€‚â‚‚ï¹•)))

âŠ¢ Ïƒ_50():
    ((â®‚ REP("kw_pfx_colon_expr", rec=â›B, n="Add colons"))
    (ó±•â†¦ó±•.insert_after_marker(â›M, COLON)))
    
    ((â®‚ REP("parser_main", rec=â›B, n="Insert spaces"))
    (Ï(add_spaces, ignore_nodes=("str_cpy", "str_py", "str_star", "str_$"))))

î¬¦ Â§Â§Â§ node transpilers Â§Â§Â§
generator(â ¤KEYWORD_NODE_NAMES, â ¤â€¹oper_litâ€‰varâ€‰var_specâ€ºâ­)(py_escape_varâ—‹ğ”—)
generator("NULL")(ó°»¾ô‹•©á´ºáµá´¸á´¸ô‹•©)

generator("group")(ğ”—(ó±•ó°€‚â‚€) + (ó±•ó°€‚â‚ï¹•ô¨„ á´ gen)â¨á¦ + ğ”—(ó±•ó°€‚ô¨„))

generator("str_guts"              )(ó±• â†¦      py_escape_string (ó±•â¥‰ğ”—)     )
generator("str_escape", "str_star")(ó±• â†¦ â›' + py_escape_string (ó±•â¥‰ğ”—) + â›')
generator("str_sub"               )(ó±• â†¦ â›{ + gen(ó±•ó°€‚â‚€)                + â›})
generator("str_spec_char"         )(ó±• â†¦ â›' + py_special_mapper(ó±•â¥‰ğ”—) + â›')

âŠ¢ make_str_cpy(ó±•):
    r=â€¹""f"â€º
    âˆ€câˆˆó±•á¶œ:
        Â¿cáµ—â‰¡"str_escape"   : r += py_escape_string (câ¥‰ğ”—)
        â¸˜cáµ—â‰¡"str_spec_char": r += py_special_mapper(câ¥‰ğ”—)
        Â¡                  : r += gen(c)
    â†ª r + â›"

generator("neg_num")(ó±•â†¦â€¹(-âŸ¦ó±•â¥‰ğ”— â¥‰ UPSIDEDOWNSYNDROME.flipâŸ§)â€º)
generator("str_cpy")(make_str_cpy)

@generator("str_$")
âŠ¢ make_str_money(ó±•):
    s, â ¤C = ó±•á¶œ
    â†ª â€¹SUBPROCA(âŸ¦ó±•.copy(c=C)â¥‰make_str_cpyâŸ§,"âŸ¦sâ¥‰ğ”— â¥‰ SCRIPT.nrm â¥‰ py_escape_stringâŸ§")â€º