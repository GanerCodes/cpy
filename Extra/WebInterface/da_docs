ó±€˜ ; Python "class"
â¨¡ ; Python "import"
â®‚ ; Python "yield"
â†ª ; Python "return"
â®Œ ; Python "from"
â†º ; Python "continue"
â‡¥ ; Python "break"
â° ; Python "while"
âˆ€ ; Python "for"
â ¤ ; Python "*" (For vargs)
â ¶ ; Python "**" (For kargs)
Â¿ ; Python "if"
â¸˜ ; Python "elif"
Â¡ ; Python "else"

â­œ ; ternary if
    "x â­œ y â­ z" ; y if x else z
    "x â­œ y" ; y if x else â–¡
â­ ; ternary else

â¬… ; push right into left (Strongest)
â¡ ; push left into right (Strongest)
â† ; push right into left (Medium)
â¥‰ ; swap right and left (Medium)
â†’ ; push left into right (Medium)
â­  ; push right into left (Weakest)
â­¢ ; push left into right (Weakest)

â‰” ; Assign to left
â‰• ; Assign to right
ó·¸‰ ; Assign to left, return previous value
ó·¸ ; Assign to right, return previous value
ó·¸Š ; Assign to left, foward value
ó·¸Œ ; Assign to right, foward value
ó·¸‹ ; Assign to left, foward value, return previous value
ó·¸ ; Assign to right, foward value, return previous value

â¨³ ; Assertion
    "ğ‘œ â¨³" = "â¨³ ğ‘œ" âŸ¶ Asserts ğ‘œ is truthy
    "ğ‘œâ‚ â¨³ ğ‘œâ‚‚" âŸ¶ Asserts ğ‘œâ‚ is truthy, puts ğ‘œâ‚‚ in error

âˆ¨ ; OR (short circuits)
â©” ; OR (doesn't short circuit)
ó·º¥ ; NOR (short circuits)
ó·º« ; NOR (doesn't short circuit)
ó·º¤ ; XOR
ó·º¦ ; NXOR

âˆ§ ; AND (short circuits)
â©“ ; AND (doesn't short circuit)
ó·º’ ; NAND (short circuits)
ó·º¬ ; NAND (doesn't short circuit)

â‰¡ ; equals
    Works similar to python, taking certain conveniences i.e. 0 as a float equals 0 as an int
ó··¼ ; diamond equals
    ó·¹‡ Requested by Michael for future advanced math things
â‰  ; not equal
â‰¤ ; less than or equal to
â‰¥ ; greater than or equal to
< ; less than
> ; greater than
âˆˆ ; element of right
    ğ”¬ âˆˆ ğ—œ
    "2âˆˆ{1,2,3}" âŸ¶ True
    "5âˆˆ{1}" âŸ¶ False
    "â›a âˆˆ â€¹hiaâ€º" âŸ¶ True
    "5 âˆˆ â€¹some stringâ€º" âŸ¶ False
âˆ‰ ; not element of right
âˆ‹ ; element of left
âˆŒ ; not element of left
âˆ£ ; divides
âˆ¤ ; does not divide
âŠ‚ ; subset of right
    ğ—œ âŠ‚ ğ—œ
    Works on non-set objects as well
âŠƒ ; subset of left
âŠŠ ; subset of not equal to right
    ğ—œ âŠŠ ğ—œ
    Works on non-set objects as well
âŠ‹ ; subset of not equal to left
âŠ„ ; not subset of right
âŠ… ; not subset of left

á´ ; map
    ğ—œ á´ ğ—™
        Maps an iterable with a function
        "[â€¹hiâ€º, â€¹thereâ€º] á´ ğŸƒŒ" âŸ¶ [2, 5]
    á´ô‹€,á´ô‹”›
        nâ‰¥0: Controls degree of the map, i.e.
            "[[â›a, â€¹bcâ€º],[â€¹defâ€º, â€¹bobâ€º]]" á´Â² ğŸƒŒ âŸ¶ [[1,2],[3,3]]
        n=âˆ: Unbounded degree
        n<0: Kinda weird, but generally backwards from âˆ
            ["hi", [[["egg"]]]] á´ô§± ğŸƒŒ â‰¡ [2, [[[3]]]]
            ó·¹‡ ó·°¾ would map the characters in those strings
    á´á´·,á´â±½,á´á´°
        Similar to above, but a dict:dict mapping
        K: keys  , Modify keys only
        V: values, Modify values only
        D: dict  , Both keys and values
        ó·¹‡ the function still expects one value which will be the [key, value] list
        ó·¹‡ use êŸ¿ for a function with two args
    ó·¹‡ supports ó°®ˆ
êŸ¿ ; starmap
    ğ—œ êŸ¿ ğ—™
    Map but instead of calling the function directly it unpacks the arg
    "[[1,2],[3,4]] êŸ¿ +" âŸ¶ [3,7]
    ó·¹‡ supports ó°®ˆ
ï’¼ ; threadmap
    ğ—œ ï’¼ ğ—™
    Same as map but uses multiple threads.
    The number of threads defaults to the number of CPU threads.
Å¿ ; fold
    ğ—œ Å¿ ğ—™
    The left-to-right classic fold.
        "[1,2,3,4] Å¿ +" âŸ¶ 10
    Å¿ô‹‰‘: ğ• is the starting value/default
        "[1,2,3,4] Å¿âµ +" âŸ¶ 15
        "[] Å¿âµ +" âŸ¶ 5
Ïœ ; accumulate
    ğ—œ Ïœ ğ—™
    fold, except returns the intermediate values
        "[1,2,3,4] Ïœ +" âŸ¶ [1,3,6,10]
â¨ ; sum
    ğ—œ â¨ ğ‘œôŠ½¨
    fold over left with +, with optional default starting value
â¨€ ; product
    ğ—œ â¨€ ğ‘œôŠ½¨
    fold over left with â‹…, with optional default starting value
ó°ˆ² ; filter positive
    ğ—œ ó°ˆ²
        filter left for truthyness
        "[0,1,âœ—,âœ“] ó°ˆ²" âŸ¶ [1,âœ“]
    ğ—œ ó°ˆ² ğ—™
        filter left for truthyness under right
        "[0,1,2,3] ó°ˆ² ó·º¹>1á¸" âŸ¶ [2,3]
    ğ—œ ó°ˆ²ô‹Š§ ğ—™
        conditional map, apply mod to elm if right true
        "[0,1,2,3] ó°ˆ²ôˆ½ ó·º¹>1á¸" âŸ¶ [0,1,ó·°¿,ó·±€]
        ó·¹‡ if modifier is not a ğ—™ it becomes a replcaement value
    ğ—œ ó°ˆ²ô‹Š§ôŒ¥¡ ğ‘œ
        same as previous but right func is equality check on ğ‘œ
    ó·¹‡ supports ó°®ˆ
ó°ˆ³ ; filter negative
    ó°ˆ² but condition is negated
    ó·¹‡ supports ó°®ˆ
ó°’¼ ; sort ascending
    ğ—œ ó°’¼
        sorts data
    ğ—œ ó°’¼ ğ—™
        sorts data by right arg
        ó·¹‡ right art is function of 1 variable
    ó·¹‡ supports ó°®ˆ
ó°’½ ; sort decending
    Reversed version of ó°’¼
î®† ; group by
    ğ—œ î®†
        group into dictionary with keys by truthyness
    ğ—œ î®† ğ—™
        group into dictionary with keys defined by right arg
    î®†ó°€’: return list of values, dropping keys
    î®†á´®: like î®†ó°€’, except groups are only false/true (& are included), so
        "[1,0,5] î®†á´®" âŸ¶ [[0],[1,5]]
        "[1,0,5] î®†á´® ó·º¹>1" âŸ¶ [[0,1],[5]]
        "[1,0,5] î®†á´® ó·º¹<0" âŸ¶ [[],[1,0,5]]
    ó·¹‡ supports ó°®ˆ
    
á™¡ ; window, with middle, with sides
    ó°¤± docs
á™§ ; window, with middle, no sides
    ó°¤± docs
á™ ; window, no middle, with sides
    ó°¤± docs
á—¢ ; window, no middle, no sides
    ó°¤± docs
ó±–” ; modifier as operator
    Binary/(indistinguishable)unary
    Calls modifier with one or two vars depending on how the operator is used. Good for treating a function as an operator
    ğ‘œôŠ½¨ ó±–”ô‹Š§ ğ‘œôŠ½¨
    "2 ó±–”ô¯ôŠ½®âºô¯‹ 3" âŸ¶ 7
    "2 ó±–”ô¯ôŠ½®" âŸ¶ 4
    "ó±–”ô¯ôŠ½® 2" âŸ¶ 4

á¹ ; left is type of right / get type of
    Binary/(indistinguishable)unary
    á¹ ğ‘œ
        Get type of ğ‘œ
        "á¹ 4" âŸ¶ ğ‘–
    ğ‘œ á¹ ğ‘œ
        Check if left is instance of right
        ó·¹‡ if right is not a type, we get the type of it first
        ó·¹‡ ğ—™ ğ—œ ğ—› acts like types
        "2 á¹ ğ‘–" âŸ¶ True
        "2 á¹ 5" âŸ¶ True
        "2 á¹ á”" âŸ¶ False
        "â€¹hâ€º á¹ ğ—œ" âŸ¶ True
á´ ; right is type of left / get type of
ó·¹µ ; left is not type of right
ó·¹´ ; right is not type of left
ó±‘¼ ; zip (left aligned)
    Binary/(indistinguishable)unary
    ğ—œ ó±‘¼ ğ—œ
        zips elements at cooresponding indicies
        "[1,2] ó·¹… [1,2,3]" âŸ¶ [[1,1],[2,2]]
    ğ—œ ó±‘¼
        arg is iterables of iterables that will be zipped
        "[[1,2,3],[5,2],[0,ó·°¾]] ó±‘¼" âŸ¶ [[1,5,0],[2,2,ó·°¾]]
    ó±‘¼ô‹‡œ fill with default value
        "[1,2] ó·¹…â¹ [1,2,3]" âŸ¶ [[1,1,9],[2,2,3]]
ó·¹… ; zip (left aligned)
    same as ó±‘¼ but elements are aligned towards the right
    "[1,2] ó·¹… [1,2,3]" âŸ¶ [[1,2],[2,3]]

| ; bitwise or

^ ; bitwise xor

& ; bitwise and

âª¡ ; bitshift left / circle arr left
    Binary/(indistinguishable)unary
    ğ‘– âª¡ ğ‘–
        bitshift left by right
    ğ—œ âª¡ ğ‘–
        rotate array list left
        "[5,6,7] âª¡ 2" âŸ¶ [7,5,6]
    ó·¹‡ unary case has right arg equal to 1
        "1 âª¡" âŸ¶ 2
        "â›aâ›b âª¡" âŸ¶ â›bâ›a
âª¢ ; bitshift right / circle arr right
    âª¡ but opposite direction

âˆ“ ; minus plus
    ğ‘œâˆ“ğ‘œôŠ½¨
    "âˆ“5" âŸ¶ [-5,5]
    "1âˆ“5" âŸ¶ [-6,4]
Â± ; plus minus
    ğ‘œÂ±ğ‘œôŠ½¨
    "Â±5" âŸ¶ [5,-5]
    "1Â±5" âŸ¶ [4,-6]
    
+ ; add
- ; subtract
ó··¶ ; diamond add
    ó·¹‡ Requested by Michael for future advanced math things
ó··» ; diamond subtract
    ó·¹‡ Requested by Michael for future advanced math things

âˆ˜ ; call left with right
    ó°¤± docs
â—‹ ; compose functions with balanced args, overflow right
    ó°¤± docs
âœ ; compose functions with balanced args, overflow left
    ó°¤± docs
ó°¬« ; compose functions, overflow extra args to right
    ó°¤± docs
ó°¬© ; compose functions, overflow extra args to left
    ó°¤± docs
ó±–š ; ó°¤±, NotImplemented
ó±–˜ ; ó°¤±, NotImplemented
ó··¹ ; diamond compose
    ó·¹‡ Requested by Michael for future advanced math things
ï ; curry function
    ó°¤± docs
âŠš ; loop
    ó°¤± docs
âŸ ; loop returning all iterations except final
    ó°¤± docs
âŠ› ; loop returning all iterations
    Same as âŸ but includes the iteration that failed check
âŠœ ; loop until fixed point
    ó°¤± docs
ğŸŸ• ; find cycle
    ó°¤± docs
ğŸŸ– ; find cycle, include prefix
    Same as ğŸŸ• but does not trim out the starting part of the cycle
ï± ; error raiser / error or-er
    ó°¤± docs
ó°”¶ ; return arg / retry with right
    ó°¤± docs
î©¬ ; return exception / custom error handle
    ó°¤± docs
á£† ; conditional function application
    ó°¤± docs

â—„ ; return left arg
    "1â—„2" âŸ¶ 1
â–º ; return right arg
    "1â–º2" âŸ¶ 2
â‹„ ; join into list
    "1â‹„2" âŸ¶ [1,2]
    "1â‹„2â‹„9" âŸ¶ [1,2,9]
    ó°¤± make this less janky

âˆª ; union
    ó°¤± docs

âˆ© ; intesection
    ó°¤± docs

âˆ– ; set minus
    ó°¤± docs
â¨‰ ; cross product
    ó°¤± docs
âŠ ; table product
    ó°¤± docs

â‰… ; is exactly the same object
    Works same as in python
â‰‡ ; is not exactly the same object
â‹… ; multiply
Ã· ; divide
â¹ ; integer divide
% ; modulo
ó··· ; diamond multiply
    ó·¹‡ Requested by Michael for future advanced math things
ó··¸ ; diamond divide
    ó·¹‡ Requested by Michael for future advanced math things
âˆš ; root
    Prefix unary
    "âˆš5"  âŸ¶ 5ôŠ½²
    "âˆšÂ³5" âŸ¶ 5ô‹€
    "âˆšó°›5" âŸ¶ 5ó°›ô©¯
! ; factorial
    Suffix unary
    "5!" âŸ¶ 120
    "0!" âŸ¶ 1
    ó°¤± generalize to gamma function
â‹€ ; all
    ğ—œ â‹€
    returns first falsy value or last value
    ó·¹‡ â‹€ô‹‡œ sets default for empty iterable (âœ“ if excluded)
â‹ ; any
    ğ—œ â‹
    returns first truthy value or last value
    ó·¹‡ â‹ô‹‡œ sets default for empty iterable (âœ— if excluded)
â«° ; absolute value
    Both-sides-indistinguishable unary
    ğ•â«° =  abs(ğ•)
â«¯ ; negative absolute value
    Both-sides-indistinguishable unary
    ğ•â«¯ = Â¯abs(ğ•)
â¨ ; join
    ó°¤± docs
âŸ• ; join include left
    ó°¤± docs
âŸ– ; join include right
    ó°¤± docs
âŸ— ; join include left and right
    ó°¤± docs
ó·¹• ; before
    ó°¤± docs
ó·¹“ ; before and including
    ó°¤± docs
ó°‘… ; where
    ó°¤± docs
ó·¹” ; after and including
    ó°¤± docs
ó·¹– ; after
    ó°¤± docs
ó·¸¹ ; range excluding end
    ó°¤± docs
ó·¸¸ ; range excluding start and end
    ó°¤± docs
ó·¸» ; range
    ó°¤± docs
ó·¸º ; range excluding start
    ó°¤± docs
â¤ˆ ; min
    ó°¤± docs
â¤‰ ; max
    ó°¤± docs
ó·¹„ ; constrain
    ó°¤± docs
â†¨ ; enumerate (zip with index)
    Both-sides-indistinguishable unary
    ğ•â†¨ is identical to (ğ•â­¥)ó±‘¼ğ•
â­¥ ; iterable/number to indices
    Both-sides-indistinguishable unary 
    "â€¹helloâ€ºâ­¥" âŸ¶ [0,1,2,3,4]
    "5â­¥"       âŸ¶ [0,1,2,3,4,5]
â¬“ ; round down
    ó°¤± docs
â–¢ ; round
    ó°¤± docs
â¬’ ; round up
    ó°¤± docs
â­ ; magic string split
    á” â­ or á” â­
    if "âŸ" is in arg:
        split by "âŸ" then by "â€‰"
        "â€¹aâŸbâ€‰câ€ºâ­" âŸ¶ [[â›a],[â›b,â›c]]
        "â€¹xâŸyâ€ºâ­"   âŸ¶ [[â›x],[â›y]]
    otherwise:
        split by just "â€‰"
        "â€¹xâ€‰yâ€ºâ­"âŸ¶ [â›x,â›y]
        "â€¹â€‰yâ€ºâ­" âŸ¶ [á¦,â›y]
        "â€¹yâ€ºâ­"  âŸ¶ [â›y]
ó°¸µ ; pad left
    ó°¤± docs
ó°¸· ; pad right
    ó°¤± docs
ó·¹Œ ; split include all seperators
    ó°¤± docs
ó·¹ ; split include 1-per-consecutive seperators
    ó°¤± docs
ó·¹ ; split disregard seperators
    ó°¤± docs
â¬„ ; strip
    ó°¤± Workings undetermined, may be removed
ğŒ‚ ; partition
    ó°¤± docs
ó°Œ· ; chain iterables
    ó°¤± docs
á´™ ; reverse
    ó°¤± docs
ó°›” ; string replacement
    ó°¤± docs
áš¤ ; first unique
    ó°¤± docs
â˜¾ ; print
    ó°¤± docs
â›¶ ; enlist arguments
    "2â›¶" âŸ¶ [2]
    "2â›¶âµ" âŸ¶ [2,2,2,2,2]
â‰ ; transpose
    Exactly the same as unary version of ó±‘¼
â´µ ; sign of number
    "ó·°¿â´µ"   âŸ¶ ó·°¾
    "0â´µ"   âŸ¶ 0
    "9.2â´µ" âŸ¶ 1
ğŸƒŒ ; cardinality/length
    ğ”¦ ğŸƒŒ
    Returns length of ğ”¦
    "â€¹eggâ€ºğŸƒŒ" âŸ¶ 3
    "[1,2]ğŸƒŒ" âŸ¶ 2
ó·¹ ; strâŸ·int involution
    ó°¤± docs
ó·¹œ ; str to int / change base
    ó°¤± docs
î‰° ; random float
    ó°¤± docs
ó±… ; random int
    ó°¤± docs
ï´ ; shuffle
    ó°¤± docs
ó°”› ; sleep / call/loop function after delay
    ó°¤± docs
ó±«© ; call/loop function after delay in thread
    ó°¤± docs
ó·¸š ; real part
    ó°¤± docs
ó·¸› ; imag part
    ó°¤± docs
ó·¸™ ; Äµ part
    ó°¤± docs
ó·¸˜ ; ó·ºˆ part
    ó°¤± docs
ó·¸œ ; tuple of real/imag parts
    ó°¤± docs
ó·¸— ; tuple of real/Äµ parts
    ó°¤± docs
ó·¸– ; tuple of real/ó·ºˆ parts
    ó°¤± docs
ó·¸• ; tuple of real/imag/Äµ/ó·ºˆ parts
    ó°¤± docs

Â¬ ; not
    Negates, can be from either side
Â¯ ; negate
    Strictly prefix unary operator
    "Â¯5" âŸ¶ ó·±‚

âŒƒ ; exponential
    "5âŒƒ2" âŸ¶ 25
ó··º ; diamond exponential
    ó·¹‡ Requested by Michael for future advanced math things

ï€… ; splat function
    ó°¤± docs
âˆ¾ ; reverse function args
    ó°¤± docs
    
î®¦ ; call function without args
    i.e. "fî®¦" is the same as "f()"
ó·¹ ; invert function
    ó°¤± docs

ó°»¾ ; identify
    ó°»¾ô‹‡œ
        function that always returns the modifier value
        "ó°»¾âµ(22)" âŸ¶ 5
    "ó°»¾(x)" âŸ¶ x
    "ó°»¾(x1,x2)" âŸ¶ x1
â„µ ; magic namespace: iterates by pairs
    ó°¤± docs
â„¶ ; magic namespace: iterates by values
    ó°¤± docs
âˆ… ; empty set
    "âˆ…" âŸ¶ ğ‘ ()
    "âˆ…Â³" âŸ¶ [ğ‘ (), ğ‘ (), ğ‘ ()]
â ; empty list
    "â" âŸ¶ []
    "âÂ³" âŸ¶ [[], [], []]

ó°®ˆ ; signal delete element from iteration
ğ—™ ; check if function
ğ—œ ; check if iterable
ğ—› ; check if hashable, if so, return hashed value
ô‹³ ; cos
    Not an operator (yet...?)
ô‹² ; sin
    Not an operator (yet...?)
ô‹´ ; tan
    Not an operator (yet...?)
ô‹‘¯ ; log
    Not an operator (yet...?)
âœ“ ; true
â´³ ; truthy function that always returns True
âœ— ; false
â´´ ; falsey function that always returns False
â–¡ ; none
á¦ ; empty string
âˆ ; infinity
Ã® ; imaginary unit
â„‡ ; euler's number
Ï„ ; tau
Ï€ ; Â½Ï„
ó·º ; Â½Ï€
ó·º ; Â¼Ï€
ó·º ; â…›Ï€