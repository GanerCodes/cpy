


op_maps ᴍ①x󰘬𝘀 ᴍ①x󰛔␛𝐬⋄𝘀

# swag = ⥌f,n↦①②①②y(x)󰅂ſ|[x]+f﹕﹕₋₁󰅂(x)󰅂ſ|[x]+[0]n

# x²➡[⊣+2,⊣²]➡⊣⨯2+⊢⬅√y
# x²➡([⊣+2,⊣²]➡⊣⨯2+⊢⬅√y)
# x²➡([⊣+2,⊣²]➡(⊣⨯2+⊢⬅√y))
# ⟨x²⟩➡ ⟨[⊣+2,⊣²]⟩➡ (⊣⨯2+⊢ ⬅⟨√y⟩))

# f➡g➡ h𐞁 ⬅k

# f➡g➡h➡m⬅k⬅l➡p
# (f➡g➡h➡ m ⬅k⬅l)➡p
# (f➡g➡h➡ m ⬅k⬅l)➡p
# d⬅f➡g➡h➡m⬅k⬅l➡p
# (d⬅f)➡g➡h➡((m⬅k)⬅l)➡p
# ((((d⬅f)➡g)➡h)➡((m⬅k)⬅l))➡p


K = (①[☾(':',⠤x,sep='\n'),x]₁)
# ①x-0⤉()
gs = ③1…10∖∪(z,(z⍉)ₓ,⍉z₋₁﹕₊₂ ₓ₋₁﹕ₓ₊₂⍉Σ∅)
sr = ④(z ₓ≔w)►nx(z)
nx = z↦(K z¿□∉Σ(z))∨⁅⁅sr(x,y,K dcp𐞂⨯z,h)∀h∈gs(x,y,z)⁆∀x,y∈9↕|⨉|9↕¿¬z ₓ⁆
nx([7⋄8⋄□⋄4⋄□⋄□⋄1⋄2⋄□,
    6⋄□⋄□⋄□⋄7⋄5⋄□⋄□⋄9,
    □⋄□⋄□⋄6⋄□⋄1⋄□⋄7⋄8,
    □⋄□⋄7⋄□⋄4⋄□⋄2⋄6⋄□,
    □⋄□⋄1⋄□⋄5⋄□⋄9⋄3⋄□,
    9⋄□⋄4⋄□⋄6⋄□⋄□⋄□⋄5,
    □⋄7⋄□⋄3⋄□⋄□⋄□⋄1⋄2,
    1⋄2⋄□⋄□⋄□⋄7⋄4⋄□⋄□,
    □⋄4⋄9⋄2⋄□⋄6⋄□⋄□⋄7])



TODO:
    F STRINGS
    TYPEHINTS {PROB DONT DO THIS ONE}

1⋄2 ζ 3⋄4 ſ ②x🃌→⌃←🃌y󰅂
((1⋄2) ζ (3⋄4)) ſ (②x🃌→⌃←🃌y󰅂)

②x🃌→⌃←🃌y󰅂 = ②(x🃌)⌃(🃌y)󰅂 = ②(🃌(x))⌃(🃌(y))󰅂
②x🃌→f←🃌y󰅂 = ②f(x🃌, 🃌y)󰅂 = ②f(🃌(x), 🃌(y))󰅂

‹A␛›C〚2+2〛D␛␛E␛𝗻F𝗻›
␛x 𝗻 ␛𝗻
αdasβ
"𝗻K\""+𝗻+␛𝗻
〚([]⟨⟩)²[[]⁅⁆]〛〚2〛
"hi" \a\b

(
    hi
)

① x²
2
②x+y
󰅂+1
𝕋𝔽Σamong







5|2+3→ᴍ𝑥
5|(2+3)→ᴍ𝑥
5|((2+3)→ᴍ𝑥)

𝑥ᴍ←2+5|2
𝑥ᴍ←(2+5)|2
(𝑥ᴍ←(2+5))|2



def swag_arrow(n, arrow, layers):
    spl_ops = reduce(lambda x,y:x|y, layers[:arrow.o])
    α, β = partition(ρ(𝕊.get_op, layer=is_this_arrow))
    if arrow.d == 'r':
        n = partition(β, ρ(𝕊.get_op, layer=spl_ops))
    if arrow.d == 'l':
        n = partition(α, ρ(𝕊.get_op, layer=spl_ops))

𝜶 ᴍ 𝑥∨𝑦+2 = 𝜶 ᴍ 𝑥∨(𝑦+2)
𝜶 ᴍ 𝑥∨𝑦→+2 = 𝜶 ᴍ (𝑥∨𝑦)+2

𝜶⋅𝑥∨𝑦+2 = (𝜶⋅𝑥)∨𝑦+2
𝜶⋅←𝑥∨𝑦+2 = 𝜶⋅(𝑥∨𝑦+2)


[f]→[g]→[h]→[m]←[k]←[l]→[p]
(f)[g]→[h]→[m]←[k]←[l]→[p]
((f)(g))[h]→[m]←[k]←[l]→[p]





# f➡g➡h➡m⬅k⬅l➡p
# (((((((f)➡g)➡h)➡m)⬅k)⬅l)➡p)
# ((((f)➡g)➡h)➡m)⬅(k⬅((l)➡p))
# (f➡g➡h➡ m ⬅k⬅l)➡p

[5|2⋅3] → [ᴍ𝑥|2] # α,β
[5|2⋅3] # α
    [[5]|[2⋅3]] # spl α by op > '→'󰂞
    [[5]|] ; [2⋅3] # *γ,Δ
γ(Δ)β
5|(2⋅3)ᴍ𝑥|2

[[5]|][[2+3] ᴍ𝑥] # α ((γ) β)
5 | ((2+3) ᴍ𝑥)


5|2+3→ᴍ𝑥→²
[5|2+3] → [ᴍ𝑥→²]
5 | ((2+3) [ᴍ𝑥→²])

[ᴍ[𝑥]]
[ᴍ][𝑥]
[ᴍ][[𝑥]²]
ᴍ ((𝑥)²)

5 | ((2+3) ᴍ ((𝑥)²))

1+2⋅3-4

1+2⋅3-4
1+[2⋅3]-4

1+2⋅3-4

a+b⟶+c+d
[a+b]⟶[+c+d]
((a+b)⟶+c)+d

scan(n, l/r, f):
    

1 → [1] []
+
    {2⋅3-4}
    2
    ⋅
    3-4
    
    
calc_indent = ⥌n ↦ nᵗ ≡ ␛W ∧ n.c.split('\n')₋₁.count(' ') // 4 ∨ 0

🟑
¿ x+2: yield y+2
if x+2: yield y+2

class Node:
    __slots__ = ('t', 'c')
    
    t = x ¿ y > 2 ¡ z
    
    ⊢ __init__(𝕊, t=ᐦ, c=ᗜ):
        𝕊.t, 𝕊.c = t, c or []
    
    ⊢ __eq__(𝕊, n):
        if ᐹ(n, ᔐ):
            return 𝕊.t == n
        assert n ᐹ Node
        return 𝕊.t == n.t and 𝕊.c == n.c

# whitespace stuff
calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
def p_indent_stack(S, n=0):
    r = []
    while S:
        indent, *exprs = S[0]
        if indent > n:
            r.append(p_indent_stack(S, indent))
        elif indent < n:
            break
        else:
            S.pop(0)
            r.extend(exprs)
    return Node("BLOCK", r)

aΣb

calc_indent = ⥌n ↦ nᵗ ≡ ␛W ∧ n.c.split('\n')₋₁.count(' ') // 4 ∨ 0
⊢ p_indent_stack(S, n=0):
    r = []
    ➰ S:
        indent, ⠤exprs = S₀
        ¿ indent > n:
            r.append(p_indent_stack(S, indent))
        ⸘ indent < n:
            break
        ¡:
            S.pop(0)
            r.extend(exprs)
    ↪ Node("BLOCK", r)






a
    b
        c
d
    e
f

②x🃌→+←🃌y→⋅2󰅂
2+3

2⋅5 + (⋅)

γ = 2

@cheese
def hi():
    print(1)

αΣβ

# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt[1:]) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[1]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("special_str")
def gen_special_str(n, *, r='"'):
    for c in n.c[1:-1]:
        match c.t:
            case "str_escape"   : r += py_escape_string(c.txt[1:])
            case "str_spec_char": r += py_special_mapper(c.txt)
            case _              : r += gen(c)
    return r + '"'


hi [xd]
    2+2
    if 2:
        print
        ① x² + 2


if 1:
    print(2)
    asd
        egg
                eg2
            eg3
else:
    print(2)

a
aʸ

if x
    print(1)
    asd
        asd
    〚 print(1)
        2+x
    〛

[+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 → ☾ + 1

a⋅b+c⋅d

2∪ ← [+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 → ☾ + 1

if x 〚 print(1) 
asd 〚 asd 〛
〚 print(1) 〚 2x 〛 〛 〛


[+,-,/] ζ [1,2,3]
 ſ ②x(y)󰅂 → ☾ + 1
1 → a

①(1)

(0…2]


2 + ␛
  5 + 2


‹hi␛𝐛›+␛𝐬⋄𝘀
aʸᶻ ʸz₂₃w₂
‹really cheese 〚x²〛›
1←2←3
[+,-,/] ζ [1,2,3] ſ ②x(y)󰅂
x⋅y→+3
1→2→3
f→g→h→m←k←l→p

1←2←3


a⨉b∩c⨉d

print(1)
2+(5+2)
2+3→⋅2
a ∪ ((b ∪ (c ζ d)) ᴍ (e ∪ f))
1…2⌃3⌃4⌃5…6

5+2→⟶⟶+a⋅1⟶+2

if op.t in '←⟶←→🡸🡺':
    j = 𝕊.into_expr(collapse(res+[cur]))
    j.text = f"({j.text})"
    print("PARSING", [j] + stack)
    return 𝕊.parse_exprs([j] + stack)

[+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 ⟶ ☾ + 1

2+3󰅂⋅2
(2+3)⋅2
(2+3)⋅2

([+,-,/] ζ [1,2,3] ſ ②x(y)󰅂) ⟶ (☾ + 1)

a⌃b⌃

1 (☾) 2


[+,-,/] ζ [1,2,3] ſ ②x(y)󰅂 → ☾ + 1

x("a").y

op_maps ᴍ①x󰘬𝘀ᴍ①x󰛔␛𝐬⋄𝘀

class Mapper_py(Mapper):
    def generate_gram_regexes(𝕊, op_names):
        rgx_keywords = rgx_or(py_kw.kwlist + py_kw.softkwlist)
        rgx_operator = rgx_or(flat([re.escape(c+'='), re.escape(c)] for c in op_names))
        rgx_specials = rgx_or([*"ℵ𝕋𝔽îπτ□∅∞ᐦ", "\\."*3])
        return {
            "OPERATORS": i_rgx_fmt(rgx_operator),
            "VAR_SPECIAL": i_rgx_fmt(rgx_specials),
            "KEYWORDS": i_rgx_fmt(f"({rgx_keywords})(\\Z|[^_a-zA-Z0-9])") }

# actual operators
# blocks
# 

# V,pr=0,lambda*a,**k:print(V*'#',*a,**k)
# def A(*a,**k): global V ; V += 1 ; pr(*a,**k)
# def B(*a,**k): global V ; pr(*a,**k) ; V -= 1

(+)⋄(-)⋄(⋅)

class Mapper:
    SPECIALS = ...

☾´
ᴍ꜠ᵜ

¬1+1⋅2/2!+1⌃2⌃3

¿ 1>x>2:
    1+1⋅2/2!+1⌃2⌃3
    ‹hi␛𝐛›
    x+(y+[] a b)*z

class dasjiod:
    def asfmdiaf:
        daodasd

class Mapper:
    SPECIALS = ...
    GRAM_FILE = ...
    OPERATOR_FILE = ...
    NODE_CLS = ...

⟥d
ssssd

𝚲1
①1
②1
x↦1
⥌x,y,*a↦2
⥌x,y,*a,**k↦2
⥌x,y,*a↦2
⥌x,y,**k↦2
⥌a↦2
⥌**,x,*↦2

⥌**k,x,y↦2

☾´ᴍ↕10
☾ᴍ↕10

¿ 1>x>2:
    1+1⋅2/2!+1⌃2⌃3
    ‹hi␛𝐛›´
    x+(y+[] a b)*z

os = "os" ⨡
os.system(‹echo 〚2 5〛›)

a b,c d

 asdijasd
# dasd

 ⭥⬍↨

5↕ ζ 5↕ᴙ ᴍ ⋅´ → ☾
f○f = f(f(⬤))
10⭥ ᴍ ☾´○⛶´
f∘f = f(f)
⥌F,n↦①②②y∘x󰅂 ſ x⛶+ᴙF󰅂 ſ x⛶+0⛶n
0…10 ᴍ ①x⌃2󰅂 Σ ↕ 󰈲 ①x%2≡1

10↕ ᴍ ⋅꜠
 normalize ´
 duplicate input? ꜠
   Forces into binop
 swap? ᵜ
 ? ꝰⵯᵔˆꜛ𐞴

if 𝕋:
    print(1)
else dasd:
    dasd

0…10 ᴍ ①x⌃2󰅂 Σ ↕ 󰈲 ①x%2≡1
0…10 │ᴍ│ ①x⌃2󰅂 │Σ│ ↕ │󰈲│ ①x%2≡1
(0…10 │ᴍ│ ①x⌃2󰅂) │Σ│ ↕ │󰈲│ ①x%2≡1
((0…10 │ᴍ│ ①x⌃2󰅂) │Σ│ ↕) │󰈲│ ①x%2≡1
(((0…10 │ᴍ│ ①x⌃2󰅂) │Σ│ ↕) │󰈲│ ①x%2≡1)
((((0…10 │ᴍ│ ①x⌃2󰅂) │Σ)│ ↕) │󰈲│ ①x%2≡1)