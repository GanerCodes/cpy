TODO:
    F STRINGS
    TYPEHINTS {PROB DONT DO THIS ONE}

1â‹„2 Î¶ 3â‹„4 Å¿ â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚
((1â‹„2) Î¶ (3â‹„4)) Å¿ (â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚)

â‘¡xğŸƒŒâ†’âŒƒâ†ğŸƒŒyó°…‚ = â‘¡(xğŸƒŒ)âŒƒ(ğŸƒŒy)ó°…‚ = â‘¡(ğŸƒŒ(x))âŒƒ(ğŸƒŒ(y))ó°…‚
â‘¡xğŸƒŒâ†’fâ†ğŸƒŒyó°…‚ = â‘¡f(xğŸƒŒ, ğŸƒŒy)ó°…‚ = â‘¡f(ğŸƒŒ(x), ğŸƒŒ(y))ó°…‚

â€¹Aâ›â€ºCã€š2+2ã€›Dâ›â›Eâ›ğ—»Fğ—»â€º
â›x ğ—» â›ğ—»
Î±dasÎ²
"ğ—»K\""+ğ—»+â›ğ—»
ã€š([]âŸ¨âŸ©)Â²[[]â…â†]ã€›ã€š2ã€›
"hi" \a\b

(
    hi
)

â‘  xÂ²
2
â‘¡x+y
ó°…‚+1
ğ•‹ğ”½Î£among







5|2+3â†’á´ğ‘¥
5|(2+3)â†’á´ğ‘¥
5|((2+3)â†’á´ğ‘¥)

ğ‘¥á´â†2+5|2
ğ‘¥á´â†(2+5)|2
(ğ‘¥á´â†(2+5))|2



def swag_arrow(n, arrow, layers):
    spl_ops = reduce(lambda x,y:x|y, layers[:arrow.o])
    Î±, Î² = partition(Ï(ğ•Š.get_op, layer=is_this_arrow))
    if arrow.d == 'r':
        n = partition(Î², Ï(ğ•Š.get_op, layer=spl_ops))
    if arrow.d == 'l':
        n = partition(Î±, Ï(ğ•Š.get_op, layer=spl_ops))

ğœ¶ á´ ğ‘¥âˆ¨ğ‘¦+2 = ğœ¶ á´ ğ‘¥âˆ¨(ğ‘¦+2)
ğœ¶ á´ ğ‘¥âˆ¨ğ‘¦â†’+2 = ğœ¶ á´ (ğ‘¥âˆ¨ğ‘¦)+2

ğœ¶â‹…ğ‘¥âˆ¨ğ‘¦+2 = (ğœ¶â‹…ğ‘¥)âˆ¨ğ‘¦+2
ğœ¶â‹…â†ğ‘¥âˆ¨ğ‘¦+2 = ğœ¶â‹…(ğ‘¥âˆ¨ğ‘¦+2)


[f]â†’[g]â†’[h]â†’[m]â†[k]â†[l]â†’[p]
(f)[g]â†’[h]â†’[m]â†[k]â†[l]â†’[p]
((f)(g))[h]â†’[m]â†[k]â†[l]â†’[p]





# fâ¡gâ¡hâ¡mâ¬…kâ¬…lâ¡p
# (((((((f)â¡g)â¡h)â¡m)â¬…k)â¬…l)â¡p)
# ((((f)â¡g)â¡h)â¡m)â¬…(kâ¬…((l)â¡p))
# (fâ¡gâ¡hâ¡ m â¬…kâ¬…l)â¡p

[5|2â‹…3] â†’ [á´ğ‘¥|2] # Î±,Î²
[5|2â‹…3] # Î±
    [[5]|[2â‹…3]] # spl Î± by op > 'â†’'ó°‚
    [[5]|] ; [2â‹…3] # *Î³,Î”
Î³(Î”)Î²
5|(2â‹…3)á´ğ‘¥|2

[[5]|][[2+3] á´ğ‘¥] # Î± ((Î³) Î²)
5 | ((2+3) á´ğ‘¥)


5|2+3â†’á´ğ‘¥â†’Â²
[5|2+3] â†’ [á´ğ‘¥â†’Â²]
5 | ((2+3) [á´ğ‘¥â†’Â²])

[á´[ğ‘¥]]
[á´][ğ‘¥]
[á´][[ğ‘¥]Â²]
á´ ((ğ‘¥)Â²)

5 | ((2+3) á´ ((ğ‘¥)Â²))

1+2â‹…3-4

1+2â‹…3-4
1+[2â‹…3]-4

1+2â‹…3-4

a+bâŸ¶+c+d
[a+b]âŸ¶[+c+d]
((a+b)âŸ¶+c)+d

scan(n, l/r, f):
    

1 â†’ [1] []
+
    {2â‹…3-4}
    2
    â‹…
    3-4
    
    
calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0

ğŸŸ‘
Â¿ x+2: yield y+2
if x+2: yield y+2

class Node:
    __slots__ = ('t', 'c')
    
    t = x Â¿ y > 2 Â¡ z
    
    âŠ¢ __init__(ğ•Š, t=á¦, c=á—œ):
        ğ•Š.t, ğ•Š.c = t, c or []
    
    âŠ¢ __eq__(ğ•Š, n):
        if á¹(n, á”):
            return ğ•Š.t == n
        assert n á¹ Node
        return ğ•Š.t == n.t and ğ•Š.c == n.c

# whitespace stuff
calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
def p_indent_stack(S, n=0):
    r = []
    while S:
        indent, *exprs = S[0]
        if indent > n:
            r.append(p_indent_stack(S, indent))
        elif indent < n:
            break
        else:
            S.pop(0)
            r.extend(exprs)
    return Node("BLOCK", r)

aÎ£b

calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0
âŠ¢ p_indent_stack(S, n=0):
    r = []
    â° S:
        indent, â ¤exprs = Sâ‚€
        Â¿ indent > n:
            r.append(p_indent_stack(S, indent))
        â¸˜ indent < n:
            break
        Â¡:
            S.pop(0)
            r.extend(exprs)
    â†ª Node("BLOCK", r)






a
    b
        c
d
    e
f

â‘¡xğŸƒŒâ†’+â†ğŸƒŒyâ†’â‹…2ó°…‚
2+3

2â‹…5 + (â‹…)

Î³ = 2

@cheese
def hi():
    print(1)

Î±Î£Î²

# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt[1:]) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[1]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("special_str")
def gen_special_str(n, *, r='"'):
    for c in n.c[1:-1]:
        match c.t:
            case "str_escape"   : r += py_escape_string(c.txt[1:])
            case "str_spec_char": r += py_special_mapper(c.txt)
            case _              : r += gen(c)
    return r + '"'


hi [xd]
    2+2
    if 2:
        print
        â‘  xÂ² + 2


if 1:
    print(2)
    asd
        egg
                eg2
            eg3
else:
    print(2)

aî …
aÊ¸

if x
    print(1)
    asd
        asd
    ã€š print(1)
        2+x
    ã€›

[+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

aâ‹…b+câ‹…d

2âˆª â† [+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

if x ã€š print(1) 
asd ã€š asd ã€›
ã€š print(1) ã€š 2x ã€› ã€› ã€›


[+,-,/] Î¶ [1,2,3]
 Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1
1 â†’ a

â‘ (1)

(0â€¦2]


2 + â›
  5 + 2


â€¹hiâ›ğ›â€º+â›ğ¬â‹„ğ˜€
aÊ¸á¶» Ê¸zâ‚‚â‚ƒwâ‚‚
â€¹really cheese ã€šxÂ²ã€›â€º
1â†2â†3
[+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚
xâ‹…yâ†’+3
1â†’2â†’3
fâ†’gâ†’hâ†’mâ†kâ†lâ†’p

1â†2â†3


aâ¨‰bâˆ©câ¨‰d

print(1)
2+(5+2)
2+3â†’â‹…2
a âˆª ((b âˆª (c Î¶ d)) á´ (e âˆª f))
1â€¦2âŒƒ3âŒƒ4âŒƒ5â€¦6

5+2â†’âŸ¶âŸ¶+aâ‹…1âŸ¶+2

if op.t in 'â†âŸ¶â†â†’ğŸ¡¸ğŸ¡º':
    j = ğ•Š.into_expr(collapse(res+[cur]))
    j.text = f"({j.text})"
    print("PARSING", [j] + stack)
    return ğ•Š.parse_exprs([j] + stack)

[+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ âŸ¶ â˜¾ + 1

2+3ó°…‚â‹…2
(2+3)â‹…2
(2+3)â‹…2

([+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚) âŸ¶ (â˜¾ + 1)

aâŒƒbâŒƒ

1 (â˜¾) 2


[+,-,/] Î¶ [1,2,3] Å¿ â‘¡x(y)ó°…‚ â†’ â˜¾ + 1

x("a").y

op_maps á´â‘ xó°˜¬ğ˜€á´â‘ xó°›”â›ğ¬â‹„ğ˜€

class Mapper_py(Mapper):
    def generate_gram_regexes(ğ•Š, op_names):
        rgx_keywords = rgx_or(py_kw.kwlist + py_kw.softkwlist)
        rgx_operator = rgx_or(flat([re.escape(c+'='), re.escape(c)] for c in op_names))
        rgx_specials = rgx_or([*"â„µğ•‹ğ”½Ã®Ï€Ï„â–¡âˆ…âˆá¦", "\\."*3])
        return {
            "OPERATORS": i_rgx_fmt(rgx_operator),
            "VAR_SPECIAL": i_rgx_fmt(rgx_specials),
            "KEYWORDS": i_rgx_fmt(f"({rgx_keywords})(\\Z|[^_a-zA-Z0-9])") }

# actual operators
# blocks
# 

# V,pr=0,lambda*a,**k:print(V*'#',*a,**k)
# def A(*a,**k): global V ; V += 1 ; pr(*a,**k)
# def B(*a,**k): global V ; pr(*a,**k) ; V -= 1

op_maps á´â‘ xó°˜¬ğ˜€ á´â‘ xó°›”â›ğ¬â‹„ğ˜€

(+)â‹„(-)â‹„(â‹…)

class Mapper:
    SPECIALS = ...

â˜¾Â´
á´êœ áµœ

Â¬1+1â‹…2/2!+1âŒƒ2âŒƒ3

Â¿ 1>x>2:
    1+1â‹…2/2!+1âŒƒ2âŒƒ3
    â€¹hiâ›ğ›â€º
    x+(y+[] a b)*z

class dasjiod:
    def asfmdiaf:
        daodasd

class Mapper:
    SPECIALS = ...
    GRAM_FILE = ...
    OPERATOR_FILE = ...
    NODE_CLS = ...

âŸ¥d
ssssd

ğš²1
â‘ 1
â‘¡1
xâ†¦1
â¥Œx,y,*aâ†¦2
â¥Œx,y,*a,**kâ†¦2
â¥Œx,y,*aâ†¦2
â¥Œx,y,**kâ†¦2
â¥Œaâ†¦2
â¥Œ**,x,*â†¦2

â¥Œ**k,x,yâ†¦2

â˜¾Â´á´â†•10
â˜¾á´â†•10

Â¿ 1>x>2:
    1+1â‹…2/2!+1âŒƒ2âŒƒ3
    â€¹hiâ›ğ›â€ºÂ´
    x+(y+[] a b)*z

os = "os" â¨¡
os.system(â€¹echo ã€š2 5ã€›â€º)

a b,c d

î¬¦ asdijasd
# dasd

î¬¦ â­¥â¬â†¨

5â†• Î¶ 5â†•á´™ á´ â‹…Â´ â†’ â˜¾
fâ—‹f = f(f(â¬¤))
10â­¥ á´ â˜¾Â´â—‹â›¶Â´
fâˆ˜f = f(f)
â¥ŒF,nâ†¦â‘ â‘¡â‘¡yâˆ˜xó°…‚ Å¿ xâ›¶+á´™Fó°…‚ Å¿ xâ›¶+0â›¶n
0â€¦10 á´ â‘ xâŒƒ2ó°…‚ Î£ â†• ó°ˆ² â‘ x%2â‰¡1

10â†• á´ â‹…êœ 
î¬¦ normalize Â´
î¬¦ duplicate input? êœ 
î¬¦   Forces into binop
î¬¦ swap? áµœ
î¬¦ ? ê°âµ¯áµ”Ë†êœ›ğ´

if ğ•‹:
    print(1)
else dasd:
    dasd

0â€¦10 á´ â‘ xâŒƒ2ó°…‚ Î£ â†• ó°ˆ² â‘ x%2â‰¡1
0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚ â”‚Î£â”‚ â†• â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
(0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†• â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1
(((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1)
((((0â€¦10 â”‚á´â”‚ â‘ xâŒƒ2ó°…‚) â”‚Î£)â”‚ â†•) â”‚ó°ˆ²â”‚ â‘ x%2â‰¡1)

def print(ğ•Š, p=á—œ,es=Z.lR+'âˆ…'+Z.p, fmt=lambda x:á–‡(x,'\n',Z.P+'_'+Z.WH), clr=lambda x:Z.GR+x+Z.WH, m=64, sp=3):
        if p is á—œ:
            return print(Å„.join(x[1] for x in ğ•Š.print(0)))
        R = []
        for i,v in enum(cs:=[c.print(p+1) for c in ğ•Š.C]):
            end = i == âµŒ(cs)-1
            for o,(a,d) in enum(v):
                v[o][1] = clr('â”œâ•°â”‚ '[end+2*á–²(o)]+'â”€ '[á–²(o)]*(sp-1)) + v[o][1]
            R += v
        return [[p, f"{clr(p and "â•´â•®Â­"[á–²(ğ•Š.C)] or 'â•·')}{ğ•Š.t or es} {Z.bdB}{fmt(ğ•Š.txt[:m]) or es}{Z.bBLA}{((l:=âµŒ(ğ•Š.txt)) > m) and f"â€¦â€¦+{l-64}" or á¦}"]] + R