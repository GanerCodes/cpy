# I: Include self in group (right asoc.)
# α: basic concat
# ρ: *special*

«««««««««««««««««««««««««««««««««« HEADERS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

py_bad_string_chr  = lambda s, bad="\\\"'{}": s in bad
py_escape_char     = lambda c, u='\\u': u+HXO(c) if py_bad_string_chr(c) else c
py_escape_string   = lambda s: ᐦ.join(py_escape_char(c) for c in s)
py_escape_var      = lambda s: 'NOVAR' in CONST and s or ᒍ(ᐦ, ((ord(c)>127 or c == '!') and '_'+HXO(c) or c for c in s))
py_special_mapper  = lambda c, m={'𝗻':'\\n','𝘀':' ','𝘁':'\\t'}: m[c]
COMMA = ("oper_lit", ',')

mkgrp = lambda *X, b="()": Ń("group", b[0], ⵌ(X)==1 and X[0] or X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkexp = lambda *X: Ń("expr", *X)
mkvar = lambda x: Ń("variable_", x)
mkstr = lambda x: Ń("str", '"', x, '"')

def p_indent_stack(S, n=0):
    r = []
    while S:
        indent, *exprs = S[0]
        if indent > n:
            r.append(p_indent_stack(S, indent))
        elif indent < n:
            break
        else:
            S.pop(0)
            r.extend(exprs)
    return Node("BLOCK", r)

calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
def whitespace_parser(n):
    if n.S: return n
    N = n.copy()
    N.c = ᴍ(whitespace_parser, N.c)
    
    if N.t == "exprs":
        if not N.C: return N
        
        c_pre = N.C[0]
        blocks = [[indent_pre := calc_indent(c_pre)]]
        for c in N.C:
            if c.t == 'W':
                c_pre = c
                continue
            indent = calc_indent(c_pre)
            if indent == indent_pre:
                blocks[-1].append(c)
            else:
                blocks.append([indent, c])
            indent_pre = indent
        N.c = p_indent_stack(blocks, blocks[0][0]).c
    
    elif N.t == "group" and N.C[0].c == '〚':
        raise NotImplementedError
    
    return N

def whitespace_unparser(n, i=0):
    if n.S: return n
    N = n.copy()
    
    if N.t == "BLOCK":
        i += 1
    if N.t in ("BLOCK", "exprs"):
        sep = Node("N", ń+ś*4*i)
        N.c = sum(([sep, n] if n.t != "BLOCK" else [n] for n in N.c), [])
        if N.c and N.t == "exprs":
            N.c.pop(0)
    
    N.c = [whitespace_unparser(c, i) for c in N.c]
    return N

sst = lambda x: set(ᖵ(ᗜ,ᴍ(ⵐ,ⵉ(ᖇ(x,'␉',ń),ń))))
mdt = lambda y: ᖱ(ᴍ(ⵐ,ⵉ(x,ś,1)) for x in sst(y))
inv = lambda z: {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

OPS_BUILTIN = {
    'S': ᐦ,
    'N': """; ␉ : ␉ , ␉ if ␉ elif ␉ else ␉ for""",
    'P': """+ ␉ - ␉ * ␉ ~  ␉   ** ␉  not ␉ yield""",
    'B': """+ ␉ - ␉ * ␉ @  ␉   ** ␉   // ␉  < ␉ > ␉ % ␉ .
            & ␉ ^ ␉ | ␉ /  ␉   != ␉   == ␉ << ␉ >>
                               in ␉   is ␉ or ␉ and""" }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

OPS_COMP = ᖵ(ᗜ, ({s for s in l if 'λ' in lang.ops[s]} for l in lang.op_orders.values()))

SWAP_TABLE = mdt("""
    ⋅   * ␉ ⌃    ** ␉ ≡     == ␉ ≤ <= ␉ ≔ := ␉ ¯ -
    ⠤   * ␉ ⠶    ** ␉ ≠     != ␉ ≥ >= ␉ ÷ /
    ∨  or ␉ ≅    is ␉ 󰆴    del ␉ Ω class
    ¬ not ␉ ¿    if ␉ ⊢    def ␉ ➰ while
    ∧ and ␉ ⸘  elif ␉ ⮂  yield ␉ ↪ return
    ∀ for ␉ ¡  else ␉ ⇥  break ␉ ↺ continue
    ∈  in ␉ ⮌  from ␉ ⨡ import ␉ ≇ is not""")
KEYWORDS_TO_CPY=rmk(inv(SWAP_TABLE), sst("* ␉ **"))

merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in SWAP_TABLE.items() if y in z}

kw_pfx_colon = merge_shorthands("""
    if ␉ elif ␉ else ␉ for ␉ while
    try ␉ except ␉ finally ␉ class
    match ␉ case ␉ def ␉ with""")
kw_pfx = merge_shorthands("""
    return ␉ continue ␉ break ␉ pass
    import ␉ global ␉ nonlocal
    raise ␉ assert ␉ del ␉ async""")
kw_neverswouce = merge_shorthands("""if ␉ elif ␉ else ␉ for ␉ yield""")
kw_inline = merge_shorthands("""in ␉ is ␉ is not ␉ or ␉ and ␉ not""") | kw_neverswouce
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("ℵ𝕋𝔽îπτ□∅∞ᐦ")

register("VAR_SPEC", var_spec)
register("KW", kw)
register("KW_PFX", kw_pfx)
register("KW_SPEC", kw_spec)
register("KW_PFX_COLON", kw_pfx_colon)

«««««««««««««««««««««««««««««««««« OPERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

⨡ᴺᴾ󰁔
;ᴺᴾ󰁔 ,ᴺᴾ󰁔
=ᴺᴾ󰁔 ⮂ᴺᴾ󰁔 ↪ᴺᴾ󰁔 ↺ᴺ󰁔 ⇥ᴺ󰁔 ➰ᴺᴾ󰁔 ∀ᴺᴾᴮ󰁔 ␛
     ⮌ᴺᴾ󰁔
⠤ᴾ󰁔 ⠶ᴾ󰁔 :ᴺ󰁔
␀1ᴵᴮ ¿ᴺᴾ󰁔 ⸘ᴺᴾ󰁔 ¡ᴺᴾ󰁔
⨳ᴮᴾ󰀒ᴺ
⊻ᴮᴺ󰁖 ⨁ᴮᴺ󰁖 ␉ ∨ᴮᴺ󰁜 ␉ ⊼ᴮᴺ󰁖 ␉ ∧ᴮᴺ󰁜
==ᴮᴺ󰁖 !=ᴮᴺ󰁖 ≜ᴮᴺ󰁖 ≡ᴮᴺ󰁖 ≠ᴮᴺ󰁖 ≮ᴮᴺ󰁖 <ᴮᴺ󰁖 ≤ᴮᴺ󰁖 ≥ᴮᴺ󰁖 >ᴮᴺ󰁖 ≯ᴮᴺ󰁖 ␛
       ∈ᴮᴺ󰁖 ∉ᴮᴺ󰁖 ∌ᴮᴺ󰁖 ∋ᴮᴺ󰁖 ⊈ᴮᴺ󰁖 ⊆ᴮᴺ󰁖 ⊄ᴮᴺ󰁖 ⊂ᴮᴺ󰁖 ⊃ᴮᴺ󰁖 ⊅ᴮᴺ󰁖 ␛
       ⊇ᴮᴺ󰁖 ⊉ᴮᴺ󰁖
ᴍᴮᴺ ſᴮᴺ Σᴮᴾ󰀒ᴺ Πᴮᴾ󰀒ᴺ 󰈲ᴮᴾ󰀒ᴺ 󰈳ᴮᴾ󰀒ᴺ
ᐹᴮᴺ ζᴮᴺ
|ᴮᴺ ␉ ^ᴮᴺ ␉ &ᴮᴺ
<<ᴮᴺ >>ᴮᴺ
+ᴾᴮᴺ -ᴾᴮᴺ
≅ᴮᴺ󰁜 ≇ᴮᴺ󰁜
∘ᴮᴺ ○ᴮᴺ ⋄ᴮᴺ
◄ᴮᴺ ►ᴮᴺ
∪ᴮᴺ ␉ ∩ᴮᴺ ␉ ⨉ᴮᴺ ∖ᴮᴺ
//ᴮᴺ /ᴮᴺ  ÷ᴮᴺ   %ᴮᴺ @ᴮᴾᴺ󰁜 *ᴮᴺᴾ󰁜 ⋅ᴮᴺ !󰀒ᴺ  ␛
     ⭥ᴾ󰀒ᴺ ↨ᴾ󰀒ᴺ  ⤉ᴮᴾ󰀒ᴺ ⤈ᴮᴾ󰀒ᴺ  󷹄ᴮᴾ󰀒ᴺ  ☾ᴾ󰀒ᴺ 🃌ᴾ󰀒ᴺ ␛
     ᒍᴮᴺ  󰛔ᴮᴾ󰀒ᴺ 󰘬ᴮᴾ󰀒ᴺ ⛶ᴾ󰀒ᴺ   ⍉ᴾ󰀒ᴺ   ᴙᴾ󰀒ᴺ ␛
     ⋀ᴾ󰀒ᴺ ⋁ᴾ󰀒ᴺ
¬ᴾ󰀒ᴺ󰁜 ¯ᴾ
…ᴮᴺ ⌃ᴵᴮ **ᴵᴮᴾ󰁜
.ᴵᴮ󰁔
...ᴺ

 .｜:=ᴵᴮ󰁜｜␀1
 .｜ ≔ᴵᴮ󰁜｜␀1
  ｜  ←ᴾ󰁜｜␀1
␀1｜  →󰀒󰁜｜

«««««««««««««««««««««««««««««««««« GRAMMAR »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

parser_main = exprs
parser_comment = (_str / comment / ~"."s)*

exprs = W? (_expr W?)*
_expr = kw_pfx_colon_expr / kw_pfx_expr / norm_expr

        norm_expr = _norm_expr_atom+
      kw_pfx_expr = _kw_pfx norm_expr
kw_pfx_colon_expr = _kw_pfx_colon __E? expr_not_colon? ':' __E? _expr?

expr_not_colon = (!':' _norm_expr_atom)+
expr_not_comma = (!',' _norm_expr_atom)+

_kw_pfx_colon = (&kw_spec kw_pfx_colon) / (kw_pfx_colon __text_breaker)
_kw_pfx       = (&kw_spec kw_pfx      ) / (kw_pfx       __text_breaker)
_kw           = (&kw_spec kw          ) / (kw           __text_breaker)

_norm_expr_atom = (lamb / _gen_expr_atom) __E?
_gen_expr_atom = group / _str / var_spec / oper / _kw / _script / variable_
variable_ = (!W !oper !var_spec !_script ~"[^𝗮-𝘇␛𝚲⥌↦①②③④󰅂\\\"\\' \\[\\](){}⁅⁆〚〛⟨⟩‹›]")+

group = ~"[\\[({⁅⟨〚]" __W? exprs __W? ~"[\\])}⁆⟩〛]"

oper = oper_mod_l oper_lit oper_mod_r
oper_mod_l = ~"[⟥]*"
oper_mod_r = ~"[´꜠ᵜ⟤]*"

_script = supscript / subscript
supscript = ~"[ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻᴬᴮ󰀂ᴰᴱ󰀅ᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾ󰀐ᴿ󰀒ᵀᵁⱽᵂ󰀗󰀘󰀙󰁌󰁍󰁎󰁏󰁐󰁑󰁒󰁓◌󰁔󰁕󰁖󰁗󰁘󰁙󰁛󰁜󰁝󰁞󰁟󰁠󰁡󰁢󰁣󰁤◌◌󰀶◌󰀻󰁁󰁃󰁅󰁈󰁊󰁋⁰¹²³⁴⁵⁶⁷⁸⁹◌󰁱󰂂󰂁󰁲◌ꜝ⁺⁻ᐟ⁼⁽⁾◌◌◌˜]+"
subscript = ~"[ₐₑₕᵢⱼₖₗₘₙ󰂼ₚᵣₛₜᵤᵥₓ󰂓󰂔󰂕󰂖󰂗󰂘󰂙󰂚󰂛󰂜󰂝󰂞󰂟󰂠󰂡󰂢󰂣󰂤󰂥󰂦󰂧󰂨󰂩󰂪󰂫󰂬󰃤󰃥󰃦󰃧󰃨󰃩󰃪󰃫◌󰃬󰃭󰃮󰃯󰃰󰃱󰃳󰃴󰃵󰃶󰃷󰃸󰃹󰃺󰃻󰃼◌◌󰃎󰃏◌󰃓󰃙󰃛󰃝󰃠󰃢󰃣₀₁₂₃₄₅₆₇₈₉﹕󰄎󰄟󰄞󰄏﹖◌₊₋⸝₌₍₎﹠﹩﹪◌]+"

lamb = _lamb_h __E? lamb_b
_lamb_h = lamb_h_py / lamb_h_normal / lamb_h_implicit / lamb_h_preset
lamb_b = (exprs __cap) / expr_not_comma
__cap = '󰅂'
__zap = '⥌'
__map = '↦'
__cln = ':'
__kwl = "lambda"

lamb_h_preset   = ~"[𝚲①②③④]"
lamb_h_implicit = variable_ __map
lamb_h_normal   = __zap _lamb_h_exprs __map
lamb_h_py       = __kwl __text_breaker _expr_not_colon? __cln
_lamb_h_exprs = W? (_lamb_h_expr W?)+
_lamb_h_expr = (!lamb_h_implicit lamb) / _gen_expr_atom
_expr_not_colon = (!':' _norm_expr_atom)+ # this is dumb

_str = str_cpy / str_py / str_escape / str_spec_char
str_cpy = __L1 (str_escape / str_sub / str_spec_char / str_guts)* __R1
__L1 = "‹"
__R1 = "›"
str_sub = __L2 exprs __R2
__L2 = "〚"
__R2 = "〛"
str_spec_char = ~"[𝗮-𝘇]"
str_guts = ~"[^␛〚›]+"
str_escape = __escape ~"."
str_py = (('"' (str_py_sub / ~"[^\\\\\"]+")* '"')
       /  ("'" (str_py_sub / ~"[^\\\\\']+")* "'"))
str_py_sub = ~"\\\\."

w = ~"[ \t]+"
W = ~"[ \t\n]+"
__w = w ''
__W = W ''
__text_breaker = __E / &kw_spec / &var_spec / !variable_
__E = __w / __escaped_newline
__escaped_newline = __escape '\n'
__escape = '␛'

comment = ~"((|#)[^\\n]*(\\n|\\Z))|(🟑[^🟑]*(🟑|\\Z))|(֎[^֎]*(֎|\\Z))"s

«««««««««««««««««««««««««««««««««« GENERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

# § tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

O_1 = (-1, "Subscripts to brackets + Superscripts to dot + Trim whitespace")
@reduction("supscript", order=O_1)
def supscript(n): return [OP.TND("."), Node("variable_", n.txt)]
@replacement("subscript", recurse_children='A', order=O_1)
def subscript(n): return mkgrp(parse_as("exprs", n.c), b="[]")
@replacement("W", order=O_1)
def W(n): return n.copy(c=ń in n.c and ń+ⵉ(n.c,ń)[-1] or n.c)

O0 = (0, "Build whitespace blocks/Normalize expression types")
replacement("parser_main", recurse_children='A', order=O0)(whitespace_parser)
@replacement("norm_expr", "expr_not_colon", "expr_not_comma", recurse_children='B', order=O0)
def expr_types(n): return n.copy("expr")

@replacement(*KEYWORD_NODE_NAMES, order=(1, "Lang keywords → cpy keywords"))
def rep_keyword(n):
    if n.txt in kw_inline: # keyword that are just ops
        return OP.TND(KEYWORDS_TO_CPY.get(n.txt, n.txt))
    else:
        return n.copy(c=KEYWORDS_TO_CPY.get(n.txt, n.txt))

ARG_A = mkexp(("oper_lit", "⠤"), mkvar('𝔸'))
ARG_K = mkexp(("oper_lit", "⠶"), mkvar('𝕂'))
O2 = (2, "Refactor lambdas")
@replacement("lamb_h_preset", order=O2)
def lamb_h_preset(n):
    return Ń("lamb_h",
        *ᴍ(lambda t: mkexp(mkvar(t)), "xyzw"[:"𝚲①②③④".index(n.c)]),
        ARG_A, ARG_K)
@replacement("lamb_h_implicit", order=O2)
def lamb_h_implicit(n):
    return Ń("lamb_h", mkexp(n.C[0]), ARG_A, ARG_K)
@replacement("lamb_h_normal", "lamb_h_py", order=O2)
def lamb_h_normpy(n):
    C = ᴍ(Node.strip, ᴍs(mkexp, split_at(n.C,
        lambda x: OP.is_op(x) and (k:=op_man[x]).t == ',')))
    has_a = has_k = ⴴ
    for c in C:
        if not c.C or (o:=c.C[0]) != "oper":
            continue
        k = o.C[1].c
        if   k in ( "*", "⠤"): has_a = ⴳ
        elif k in ("**", "⠶"): has_k = ⴳ
    if not has_a: C.append(ARG_A)
    if not has_k: C.append(ARG_K)
    return Ń("lamb_h", *C)

@replacement("expr", recurse_children='B', order=(50, "Parse expressions"))
def expr(n): return into_expr(parse_expr(ᖵ(lambda x: x.t != 'w', n.C)))

@reduction("op_call", recurse_children='B', order=(51, "Reduce comparison operators"))
def op_call(n):
    if 'λ' in op_man[n.C[1]] and \
            n.C[0] != NULL and n.C[2] != NULL:
        return [*n.C[0].C, n.C[1], *n.C[2].C]
    return [n]

def make_cmp_chain(n, layers=ᗜ):
    layers = layers or OPS_COMP
    layer, *layers = layers
    
    rec = lambda n: layers and make_cmp_chain(n, layers=layers) or n
    mkexp_rec = lambda N: rec(mkexp(*N))
    
    C = ᒪ(split_at(n.C,
        lambda x: OP.is_op(x) and (k:=op_man[x]).t in layer and k.B,
        keep_separator=ⴳ))
    if ⵌ(C) < 3:
        return rec(n)
    r = ⴴ
    
    tmp_v = mkexp(mkvar("🜄"))
    for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
        c = mkexp_rec(c)
        v = mkexp(("op_call", H and mkexp_rec(a) or tmp_v,
                              b,
                              T and c or mkexp(("op_call", tmp_v, OP.TND('≔'), c))))
        r = mkexp(("op_call", r, OP.TND('∧'), v)) if r else v
    return n.copy(c=[r])
replacement("expr", recurse_children='B', order=(52, "Generate comparison chains"))(make_cmp_chain)

def mkbltnop(op_l): # format builtins if needed
    t = op_l.txt
    if (t := SWAP_TABLE.get(t,t)) not in OPS_BUILTIN['A']:
        return op_l
    return mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))

demodp = lambda o: (o.C[0].txt, o.C[1], o.C[2].txt)
def transform_oper(op_): # apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    if not (m_l or m_r):
        return op_l
    op_n = mkbltnop(op_l)
    mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
    if '⟥' in m_l: op_n = mkmod(op_n, "LNULL")
    if '⟤' in m_r: op_n = mkmod(op_n, "RNULL")
    if 'ᵜ' in m_r: op_n = mkmod(op_n, "SWAPA")
    if '꜠' in m_r: op_n = mkmod(op_n, "DUPER")
    return op_n

def try_builtin(m, op_l, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
    if m_l or m_r:
        return
    t_ = SWAP_TABLE.get(t, t)
    if t_ not in OPS_BUILTIN[m]:
        return
    return mkgxp(*ε(L), op_l, *ε(R))

hnul = lambda x: x.copy("NULL_") if x == "NULL" else x
def op_call(n):
    l, op_, r = n.C
    op = op_man[op_]
    t = KEYWORDS_TO_CPY.get(op.t, op.t)
    m_l, op_l, m_r = demodp(op_)
    L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
    
    if not (m_l or m_r):
        if 'ι' in op:
            return mkexp(hnul(l), op_l, hnul(r))
        if 'ρ' in op:
            match t:
                case '→': return L
                case '←': return R
                case '≔': return mkgxp(l, op_l, R)
                case ('¬') if L or R:
                        return mkgxp(op_l, L or R)
                case ('∨'|'∧'|'≅'|'≇') if L and R:
                        return mkgxp(L, op_l, R)
                case ('⠤'|'⠶'|'@'|'*'|'**') if not L and R:
                        return mkexp(op_l, r)
                # case '.': return mkexp(l, op_l, r)
                # case ':'|'¿'|'⸘'|'¡'|'=':
                #         return mkexp(op_l, hnul(r))
                # case ','|'⮂'|'↺'|'⇥'|'↪':
                #         return mkexp(op_l, hnul(r))
    
    op_l = transform_oper(op_)
    
    A = (op_l, L, m_l, t, m_r, R)
    if op.S and L and not op.B:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), L)
    if op.P and R and not op.B:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), R)
    if op.B and L and R:
        return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA,    r))
    if op.S and L:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA, NULL))
    if op.P and R:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    r))
    return mkbltnop(op_)
replacement("op_call", recurse_children='B', order=(53, "Refactor op calls"))(op_call)

@replacement("oper", order=(54, "Refactor sitting ops"))
def rep_oper(n):
    if n.C[1].txt in kw_neverswouce:
        return n
    if not (n.C[2].txt or n.C[0].txt):
        n = n.copy(c=[n.C[0], n.C[1], n.C[2].copy(c="´")])
    return transform_oper(n)

@replacement(*KEYWORD_NODE_NAMES, "oper_lit", order=(60, "Lang keywords ← cpy keywords"))
def rep_keyword(n): return n.copy(c=py_escape_var(SWAP_TABLE.get(n.txt, n.txt)))

O61 = (61, "Format lambdas")
@replacement("lamb", recurse_children='B', order=O61)
def lamb(n):
    return mkgxp(n.C[0], mkgrp(n.C[1]))
@replacement("lamb_h", recurse_children='B', order=O61)
def lamb_h(n): return Ń("lamb_h", ("kw", "lambda"), *print(J́(n.C, COMMA)), ("oper_lit", ":"))

replacement("parser_main", recurse_children='A', order=(100, "Unparse whitespace"))(whitespace_unparser)
@reduction("BLOCK", recurse_children='B', order=(100, "Flatten blocks"))
def BLOCK(n): return n.C

def incompat_char(x, y):
    good_chars = "~*/@%&^|-+=:;,.#<>()[]{}' \"\n\t\\"
    return not (x in good_chars or y in good_chars)
def flat_all(n):
    skips = "lamb lamb_h lamb_b lamb_h_preset lamb_h_implicit lamb_h_normal lamb_h_py lamb_h_exprs".split()
    if not n.C: return n
    cc, s = [], peekable(ᴍ(flat_all, n.C))
    while (α := next(s)) and s:
        β = s.peek()
        cc.append(α)
        if α.t in skips or β.t in skips:
            continue
        if (a:=α.txt) and (b:=β.txt) and incompat_char(a[-1], b[0]):
            cc.append(Ń('w', ' '))
    cc.append(α)
    return n.copy(c=cc)
    
replacement("exprs", order=(101, "Insert spaces"))(flat_all)

# § node transpilers
@generator(*KEYWORD_NODE_NAMES, "oper_lit")
def gen_oper_lit     (n): return n.txt
@generator("variable_", "var_spec")
def gen_variable     (n): return py_escape_var(n.txt)
@generator("NULL")
def gen_variable     (n): return "NULL"


# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[0]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("str_cpy")
def gen_special_str(n):
    r='f"'
    for c in n.c:
        if   c.t == "str_escape"   : r += py_escape_string(c.txt)
        elif c.t == "str_spec_char": r += py_special_mapper(c.txt)
        else                       : r += gen(c)
    return r + '"'