# I: Include self in group (right asoc.)
# Î±: basic concat
# Ï: *special*

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« HEADERS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

py_bad_string_chr  = lambda s, bad="\\\"'{}": s in bad
py_escape_char     = lambda c, u='\\u': u+HXO(c) if py_bad_string_chr(c) else c
py_escape_string   = lambda s: á¦.join(py_escape_char(c) for c in s)
py_escape_var      = lambda s: 'NOVAR' in CONST and s or á’(á¦, ((ord(c)>127 or c == '!') and '_'+HXO(c) or c for c in s))
py_special_mapper  = lambda c, m={'ğ—»':'\\n','ğ˜€':' ','ğ˜':'\\t'}: m[c]
COMMA = ("oper_lit", ',')

mkgrp = lambda *X, b="()": Åƒ("group", b[0], âµŒ(X)==1 and X[0] or X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkexp = lambda *X: Åƒ("expr", *X)
mkvar = lambda x: Åƒ("variable_", x)
mkstr = lambda x: Åƒ("str", '"', x, '"')

def p_indent_stack(S, n=0):
    r = []
    while S:
        indent, *exprs = S[0]
        if indent > n:
            r.append(p_indent_stack(S, indent))
        elif indent < n:
            break
        else:
            S.pop(0)
            r.extend(exprs)
    return Node("BLOCK", r)

calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
def whitespace_parser(n):
    if n.S: return n
    N = n.copy()
    N.c = á´(whitespace_parser, N.c)
    
    if N.t == "exprs":
        if not N.C: return N
        
        c_pre = N.C[0]
        blocks = [[indent_pre := calc_indent(c_pre)]]
        for c in N.C:
            if c.t == 'W':
                c_pre = c
                continue
            indent = calc_indent(c_pre)
            if indent == indent_pre:
                blocks[-1].append(c)
            else:
                blocks.append([indent, c])
            indent_pre = indent
        N.c = p_indent_stack(blocks, blocks[0][0]).c
    
    elif N.t == "group" and N.C[0].c == 'ã€š':
        raise NotImplementedError
    
    return N

def whitespace_unparser(n, i=0):
    if n.S: return n
    N = n.copy()
    
    if N.t == "BLOCK":
        i += 1
    if N.t in ("BLOCK", "exprs"):
        sep = Node("N", Å„+Å›*4*i)
        N.c = sum(([sep, n] if n.t != "BLOCK" else [n] for n in N.c), [])
        if N.c and N.t == "exprs":
            N.c.pop(0)
    
    N.c = [whitespace_unparser(c, i) for c in N.c]
    return N

sst = lambda x: set(á–µ(á—œ,á´(âµ,âµ‰(á–‡(x,'â‰',Å„),Å„))))
mdt = lambda y: á–±(á´(âµ,âµ‰(x,Å›,1)) for x in sst(y))
inv = lambda z: {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

OPS_BUILTIN = {
    'S': á¦,
    'N': """; â‰ : â‰ , â‰ if â‰ elif â‰ else â‰ for""",
    'P': """+ â‰ - â‰ * â‰ ~  â‰   ** â‰  not â‰ yield""",
    'B': """+ â‰ - â‰ * â‰ @  â‰   ** â‰   // â‰  < â‰ > â‰ % â‰ .
            & â‰ ^ â‰ | â‰ /  â‰   != â‰   == â‰ << â‰ >>
                               in â‰   is â‰ or â‰ and""" }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

OPS_COMP = á–µ(á—œ, ({s for s in l if 'Î»' in lang.ops[s]} for l in lang.op_orders.values()))

SWAP_TABLE = mdt("""
    â‹…   * â‰ âŒƒ    ** â‰ â‰¡     == â‰ â‰¤ <= â‰ â‰” := â‰ Â¯ -
    â ¤   * â‰ â ¶    ** â‰ â‰      != â‰ â‰¥ >= â‰ Ã· /
    âˆ¨  or â‰ â‰…    is â‰ ó°†´    del â‰ Î© class
    Â¬ not â‰ Â¿    if â‰ âŠ¢    def â‰ â° while
    âˆ§ and â‰ â¸˜  elif â‰ â®‚  yield â‰ â†ª return
    âˆ€ for â‰ Â¡  else â‰ â‡¥  break â‰ â†º continue
    âˆˆ  in â‰ â®Œ  from â‰ â¨¡ import â‰ â‰‡ is not""")
KEYWORDS_TO_CPY=rmk(inv(SWAP_TABLE), sst("* â‰ **"))

merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in SWAP_TABLE.items() if y in z}

kw_pfx_colon = merge_shorthands("""
    if â‰ elif â‰ else â‰ for â‰ while
    try â‰ except â‰ finally â‰ class
    match â‰ case â‰ def â‰ with""")
kw_pfx = merge_shorthands("""
    return â‰ continue â‰ break â‰ pass
    import â‰ global â‰ nonlocal
    raise â‰ assert â‰ del â‰ async""")
kw_neverswouce = merge_shorthands("""if â‰ elif â‰ else â‰ for â‰ yield""")
kw_inline = merge_shorthands("""in â‰ is â‰ is not â‰ or â‰ and â‰ not""") | kw_neverswouce
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("â„µğ•‹ğ”½Ã®Ï€Ï„â–¡âˆ…âˆá¦")

register("VAR_SPEC", var_spec)
register("KW", kw)
register("KW_PFX", kw_pfx)
register("KW_SPEC", kw_spec)
register("KW_PFX_COLON", kw_pfx_colon)

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« OPERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

â¨¡á´ºá´¾ó°”
;á´ºá´¾ó°” ,á´ºá´¾ó°”
=á´ºá´¾ó°” â®‚á´ºá´¾ó°” â†ªá´ºá´¾ó°” â†ºá´ºó°” â‡¥á´ºó°” â°á´ºá´¾ó°” âˆ€á´ºá´¾á´®ó°” â›
     â®Œá´ºá´¾ó°”
â ¤á´¾ó°” â ¶á´¾ó°” :á´ºó°”
â€1á´µá´® Â¿á´ºá´¾ó°” â¸˜á´ºá´¾ó°” Â¡á´ºá´¾ó°”
â¨³á´®á´¾ó°€’á´º
âŠ»á´®á´ºó°– â¨á´®á´ºó°– â‰ âˆ¨á´®á´ºó°œ â‰ âŠ¼á´®á´ºó°– â‰ âˆ§á´®á´ºó°œ
==á´®á´ºó°– !=á´®á´ºó°– â‰œá´®á´ºó°– â‰¡á´®á´ºó°– â‰ á´®á´ºó°– â‰®á´®á´ºó°– <á´®á´ºó°– â‰¤á´®á´ºó°– â‰¥á´®á´ºó°– >á´®á´ºó°– â‰¯á´®á´ºó°– â›
       âˆˆá´®á´ºó°– âˆ‰á´®á´ºó°– âˆŒá´®á´ºó°– âˆ‹á´®á´ºó°– âŠˆá´®á´ºó°– âŠ†á´®á´ºó°– âŠ„á´®á´ºó°– âŠ‚á´®á´ºó°– âŠƒá´®á´ºó°– âŠ…á´®á´ºó°– â›
       âŠ‡á´®á´ºó°– âŠ‰á´®á´ºó°–
á´á´®á´º Å¿á´®á´º Î£á´®á´¾ó°€’á´º Î á´®á´¾ó°€’á´º ó°ˆ²á´®á´¾ó°€’á´º ó°ˆ³á´®á´¾ó°€’á´º
á¹á´®á´º Î¶á´®á´º
|á´®á´º â‰ ^á´®á´º â‰ &á´®á´º
<<á´®á´º >>á´®á´º
+á´¾á´®á´º -á´¾á´®á´º
â‰…á´®á´ºó°œ â‰‡á´®á´ºó°œ
âˆ˜á´®á´º â—‹á´®á´º â‹„á´®á´º
â—„á´®á´º â–ºá´®á´º
âˆªá´®á´º â‰ âˆ©á´®á´º â‰ â¨‰á´®á´º âˆ–á´®á´º
//á´®á´º /á´®á´º  Ã·á´®á´º   %á´®á´º @á´®á´¾á´ºó°œ *á´®á´ºá´¾ó°œ â‹…á´®á´º !ó°€’á´º  â›
     â­¥á´¾ó°€’á´º â†¨á´¾ó°€’á´º  â¤‰á´®á´¾ó°€’á´º â¤ˆá´®á´¾ó°€’á´º  ó·¹„á´®á´¾ó°€’á´º  â˜¾á´¾ó°€’á´º ğŸƒŒá´¾ó°€’á´º â›
     á’á´®á´º  ó°›”á´®á´¾ó°€’á´º ó°˜¬á´®á´¾ó°€’á´º â›¶á´¾ó°€’á´º   â‰á´¾ó°€’á´º   á´™á´¾ó°€’á´º â›
     â‹€á´¾ó°€’á´º â‹á´¾ó°€’á´º
Â¬á´¾ó°€’á´ºó°œ Â¯á´¾
â€¦á´®á´º âŒƒá´µá´® **á´µá´®á´¾ó°œ
.á´µá´®ó°”
...á´º

 .ï½œ:=á´µá´®ó°œï½œâ€1
 .ï½œ â‰”á´µá´®ó°œï½œâ€1
  ï½œ  â†á´¾ó°œï½œâ€1
â€1ï½œ  â†’ó°€’ó°œï½œ

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GRAMMAR Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

parser_main = exprs
parser_comment = (_str / comment / ~"."s)*

exprs = W? (_expr W?)*
_expr = kw_pfx_colon_expr / kw_pfx_expr / norm_expr

        norm_expr = _norm_expr_atom+
      kw_pfx_expr = _kw_pfx norm_expr
kw_pfx_colon_expr = _kw_pfx_colon __E? expr_not_colon? ':' __E? _expr?

expr_not_colon = (!':' _norm_expr_atom)+
expr_not_comma = (!',' _norm_expr_atom)+

_kw_pfx_colon = (&kw_spec kw_pfx_colon) / (kw_pfx_colon __text_breaker)
_kw_pfx       = (&kw_spec kw_pfx      ) / (kw_pfx       __text_breaker)
_kw           = (&kw_spec kw          ) / (kw           __text_breaker)

_norm_expr_atom = (lamb / _gen_expr_atom) __E?
_gen_expr_atom = group / _str / var_spec / oper / _kw / _script / variable_
variable_ = (!W !oper !var_spec !_script ~"[^ğ—®-ğ˜‡â›ğš²â¥Œâ†¦â‘ â‘¡â‘¢â‘£ó°…‚\\\"\\' \\[\\](){}â…â†ã€šã€›âŸ¨âŸ©â€¹â€º]")+

group = ~"[\\[({â…âŸ¨ã€š]" __W? exprs __W? ~"[\\])}â†âŸ©ã€›]"

oper = oper_mod_l oper_lit oper_mod_r
oper_mod_l = ~"[âŸ¥]*"
oper_mod_r = ~"[Â´êœ áµœâŸ¤]*"

_script = supscript / subscript
supscript = ~"[áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–î ‡Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»á´¬á´®ó°€‚á´°á´±ó°€…á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾ó°€á´¿ó°€’áµ€áµâ±½áµ‚ó°€—ó°€˜ó°€™ó°Œó°ó°ó°ó°ó°‘ó°’ó°“â—Œó°”ó°•ó°–ó°—ó°˜ó°™ó°›ó°œó°ó°ó°Ÿó° ó°¡ó°¢ó°£ó°¤â—Œâ—Œó°€¶â—Œó°€»ó°ó°ƒó°…ó°ˆó°Šó°‹â°Â¹Â²Â³â´âµâ¶â·â¸â¹â—Œó°±ó°‚‚ó°‚ó°²â—Œêœâºâ»áŸî â¼â½â¾â—Œâ—Œâ—ŒËœ]+"
subscript = ~"[â‚î …î î â‚‘î î ‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™ó°‚¼â‚šî †áµ£â‚›â‚œáµ¤áµ¥î ’â‚“î “î ”ó°‚“ó°‚”ó°‚•ó°‚–ó°‚—ó°‚˜ó°‚™ó°‚šó°‚›ó°‚œó°‚ó°‚ó°‚Ÿó°‚ ó°‚¡ó°‚¢ó°‚£ó°‚¤ó°‚¥ó°‚¦ó°‚§ó°‚¨ó°‚©ó°‚ªó°‚«ó°‚¬ó°ƒ¤ó°ƒ¥ó°ƒ¦ó°ƒ§ó°ƒ¨ó°ƒ©ó°ƒªó°ƒ«â—Œó°ƒ¬ó°ƒ­ó°ƒ®ó°ƒ¯ó°ƒ°ó°ƒ±ó°ƒ³ó°ƒ´ó°ƒµó°ƒ¶ó°ƒ·ó°ƒ¸ó°ƒ¹ó°ƒºó°ƒ»ó°ƒ¼â—Œâ—Œó°ƒó°ƒâ—Œó°ƒ“ó°ƒ™ó°ƒ›ó°ƒó°ƒ ó°ƒ¢ó°ƒ£â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰ï¹•ó°„ó°„Ÿó°„ó°„ï¹–â—Œâ‚Šâ‚‹â¸î ‰â‚Œâ‚â‚ï¹ ï¹©ï¹ªâ—Œ]+"

lamb = _lamb_h __E? lamb_b
_lamb_h = lamb_h_py / lamb_h_normal / lamb_h_implicit / lamb_h_preset
lamb_b = (exprs __cap) / expr_not_comma
__cap = 'ó°…‚'
__zap = 'â¥Œ'
__map = 'â†¦'
__cln = ':'
__kwl = "lambda"

lamb_h_preset   = ~"[ğš²â‘ â‘¡â‘¢â‘£]"
lamb_h_implicit = variable_ __map
lamb_h_normal   = __zap _lamb_h_exprs __map
lamb_h_py       = __kwl __text_breaker _expr_not_colon? __cln
_lamb_h_exprs = W? (_lamb_h_expr W?)+
_lamb_h_expr = (!lamb_h_implicit lamb) / _gen_expr_atom
_expr_not_colon = (!':' _norm_expr_atom)+ # this is dumb

_str = str_cpy / str_py / str_escape / str_spec_char
str_cpy = __L1 (str_escape / str_sub / str_spec_char / str_guts)* __R1
__L1 = "â€¹"
__R1 = "â€º"
str_sub = __L2 exprs __R2
__L2 = "ã€š"
__R2 = "ã€›"
str_spec_char = ~"[ğ—®-ğ˜‡]"
str_guts = ~"[^â›ã€šâ€º]+"
str_escape = __escape ~"."
str_py = (('"' (str_py_sub / ~"[^\\\\\"]+")* '"')
       /  ("'" (str_py_sub / ~"[^\\\\\']+")* "'"))
str_py_sub = ~"\\\\."

w = ~"[ \t]+"
W = ~"[ \t\n]+"
__w = w ''
__W = W ''
__text_breaker = __E / &kw_spec / &var_spec / !variable_
__E = __w / __escaped_newline
__escaped_newline = __escape '\n'
__escape = 'â›'

comment = ~"((î¬¦|#)[^\\n]*(\\n|\\Z))|(ğŸŸ‘[^ğŸŸ‘]*(ğŸŸ‘|\\Z))|(Ö[^Ö]*(Ö|\\Z))"s

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GENERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

# Â§ tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

O_1 = (-1, "Subscripts to brackets + Superscripts to dot + Trim whitespace")
@reduction("supscript", order=O_1)
def supscript(n): return [OP.TND("."), Node("variable_", n.txt)]
@replacement("subscript", recurse_children='A', order=O_1)
def subscript(n): return mkgrp(parse_as("exprs", n.c), b="[]")
@replacement("W", order=O_1)
def W(n): return n.copy(c=Å„ in n.c and Å„+âµ‰(n.c,Å„)[-1] or n.c)

O0 = (0, "Build whitespace blocks/Normalize expression types")
replacement("parser_main", recurse_children='A', order=O0)(whitespace_parser)
@replacement("norm_expr", "expr_not_colon", "expr_not_comma", recurse_children='B', order=O0)
def expr_types(n): return n.copy("expr")

@replacement(*KEYWORD_NODE_NAMES, order=(1, "Lang keywords â†’ cpy keywords"))
def rep_keyword(n):
    if n.txt in kw_inline: # keyword that are just ops
        return OP.TND(KEYWORDS_TO_CPY.get(n.txt, n.txt))
    else:
        return n.copy(c=KEYWORDS_TO_CPY.get(n.txt, n.txt))

ARG_A = mkexp(("oper_lit", "â ¤"), mkvar('ğ”¸'))
ARG_K = mkexp(("oper_lit", "â ¶"), mkvar('ğ•‚'))
O2 = (2, "Refactor lambdas")
@replacement("lamb_h_preset", order=O2)
def lamb_h_preset(n):
    return Åƒ("lamb_h",
        *á´(lambda t: mkexp(mkvar(t)), "xyzw"[:"ğš²â‘ â‘¡â‘¢â‘£".index(n.c)]),
        ARG_A, ARG_K)
@replacement("lamb_h_implicit", order=O2)
def lamb_h_implicit(n):
    return Åƒ("lamb_h", mkexp(n.C[0]), ARG_A, ARG_K)
@replacement("lamb_h_normal", "lamb_h_py", order=O2)
def lamb_h_normpy(n):
    C = á´(Node.strip, á´s(mkexp, split_at(n.C,
        lambda x: OP.is_op(x) and (k:=op_man[x]).t == ',')))
    has_a = has_k = â´´
    for c in C:
        if not c.C or (o:=c.C[0]) != "oper":
            continue
        k = o.C[1].c
        if   k in ( "*", "â ¤"): has_a = â´³
        elif k in ("**", "â ¶"): has_k = â´³
    if not has_a: C.append(ARG_A)
    if not has_k: C.append(ARG_K)
    return Åƒ("lamb_h", *C)

@replacement("expr", recurse_children='B', order=(50, "Parse expressions"))
def expr(n): return into_expr(parse_expr(á–µ(lambda x: x.t != 'w', n.C)))

@reduction("op_call", recurse_children='B', order=(51, "Reduce comparison operators"))
def op_call(n):
    if 'Î»' in op_man[n.C[1]] and \
            n.C[0] != NULL and n.C[2] != NULL:
        return [*n.C[0].C, n.C[1], *n.C[2].C]
    return [n]

def make_cmp_chain(n, layers=á—œ):
    layers = layers or OPS_COMP
    layer, *layers = layers
    
    rec = lambda n: layers and make_cmp_chain(n, layers=layers) or n
    mkexp_rec = lambda N: rec(mkexp(*N))
    
    C = á’ª(split_at(n.C,
        lambda x: OP.is_op(x) and (k:=op_man[x]).t in layer and k.B,
        keep_separator=â´³))
    if âµŒ(C) < 3:
        return rec(n)
    r = â´´
    
    tmp_v = mkexp(mkvar("ğŸœ„"))
    for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
        c = mkexp_rec(c)
        v = mkexp(("op_call", H and mkexp_rec(a) or tmp_v,
                              b,
                              T and c or mkexp(("op_call", tmp_v, OP.TND('â‰”'), c))))
        r = mkexp(("op_call", r, OP.TND('âˆ§'), v)) if r else v
    return n.copy(c=[r])
replacement("expr", recurse_children='B', order=(52, "Generate comparison chains"))(make_cmp_chain)

def mkbltnop(op_l): # format builtins if needed
    t = op_l.txt
    if (t := SWAP_TABLE.get(t,t)) not in OPS_BUILTIN['A']:
        return op_l
    return mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))

demodp = lambda o: (o.C[0].txt, o.C[1], o.C[2].txt)
def transform_oper(op_): # apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    if not (m_l or m_r):
        return op_l
    op_n = mkbltnop(op_l)
    mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
    if 'âŸ¥' in m_l: op_n = mkmod(op_n, "LNULL")
    if 'âŸ¤' in m_r: op_n = mkmod(op_n, "RNULL")
    if 'áµœ' in m_r: op_n = mkmod(op_n, "SWAPA")
    if 'êœ ' in m_r: op_n = mkmod(op_n, "DUPER")
    return op_n

def try_builtin(m, op_l, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
    if m_l or m_r:
        return
    t_ = SWAP_TABLE.get(t, t)
    if t_ not in OPS_BUILTIN[m]:
        return
    return mkgxp(*Îµ(L), op_l, *Îµ(R))

hnul = lambda x: x.copy("NULL_") if x == "NULL" else x
def op_call(n):
    l, op_, r = n.C
    op = op_man[op_]
    t = KEYWORDS_TO_CPY.get(op.t, op.t)
    m_l, op_l, m_r = demodp(op_)
    L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
    
    if not (m_l or m_r):
        if 'Î¹' in op:
            return mkexp(hnul(l), op_l, hnul(r))
        if 'Ï' in op:
            match t:
                case 'â†’': return L
                case 'â†': return R
                case 'â‰”': return mkgxp(l, op_l, R)
                case ('Â¬') if L or R:
                        return mkgxp(op_l, L or R)
                case ('âˆ¨'|'âˆ§'|'â‰…'|'â‰‡') if L and R:
                        return mkgxp(L, op_l, R)
                case ('â ¤'|'â ¶'|'@'|'*'|'**') if not L and R:
                        return mkexp(op_l, r)
                # case '.': return mkexp(l, op_l, r)
                # case ':'|'Â¿'|'â¸˜'|'Â¡'|'=':
                #         return mkexp(op_l, hnul(r))
                # case ','|'â®‚'|'â†º'|'â‡¥'|'â†ª':
                #         return mkexp(op_l, hnul(r))
    
    op_l = transform_oper(op_)
    
    A = (op_l, L, m_l, t, m_r, R)
    if op.S and L and not op.B:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), L)
    if op.P and R and not op.B:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), R)
    if op.B and L and R:
        return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA,    r))
    if op.S and L:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA, NULL))
    if op.P and R:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    r))
    return mkbltnop(op_)
replacement("op_call", recurse_children='B', order=(53, "Refactor op calls"))(op_call)

@replacement("oper", order=(54, "Refactor sitting ops"))
def rep_oper(n):
    if n.C[1].txt in kw_neverswouce:
        return n
    if not (n.C[2].txt or n.C[0].txt):
        n = n.copy(c=[n.C[0], n.C[1], n.C[2].copy(c="Â´")])
    return transform_oper(n)

@replacement(*KEYWORD_NODE_NAMES, "oper_lit", order=(60, "Lang keywords â† cpy keywords"))
def rep_keyword(n): return n.copy(c=py_escape_var(SWAP_TABLE.get(n.txt, n.txt)))

O61 = (61, "Format lambdas")
@replacement("lamb", recurse_children='B', order=O61)
def lamb(n):
    return mkgxp(n.C[0], mkgrp(n.C[1]))
@replacement("lamb_h", recurse_children='B', order=O61)
def lamb_h(n): return Åƒ("lamb_h", ("kw", "lambda"), *print(JÌ(n.C, COMMA)), ("oper_lit", ":"))

replacement("parser_main", recurse_children='A', order=(100, "Unparse whitespace"))(whitespace_unparser)
@reduction("BLOCK", recurse_children='B', order=(100, "Flatten blocks"))
def BLOCK(n): return n.C

def incompat_char(x, y):
    good_chars = "~*/@%&^|-+=:;,.#<>()[]{}' \"\n\t\\"
    return not (x in good_chars or y in good_chars)
def flat_all(n):
    skips = "lamb lamb_h lamb_b lamb_h_preset lamb_h_implicit lamb_h_normal lamb_h_py lamb_h_exprs".split()
    if not n.C: return n
    cc, s = [], peekable(á´(flat_all, n.C))
    while (Î± := next(s)) and s:
        Î² = s.peek()
        cc.append(Î±)
        if Î±.t in skips or Î².t in skips:
            continue
        if (a:=Î±.txt) and (b:=Î².txt) and incompat_char(a[-1], b[0]):
            cc.append(Åƒ('w', ' '))
    cc.append(Î±)
    return n.copy(c=cc)
    
replacement("exprs", order=(101, "Insert spaces"))(flat_all)

# Â§ node transpilers
@generator(*KEYWORD_NODE_NAMES, "oper_lit")
def gen_oper_lit     (n): return n.txt
@generator("variable_", "var_spec")
def gen_variable     (n): return py_escape_var(n.txt)
@generator("NULL")
def gen_variable     (n): return "NULL"


# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[0]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("str_cpy")
def gen_special_str(n):
    r='f"'
    for c in n.c:
        if   c.t == "str_escape"   : r += py_escape_string(c.txt)
        elif c.t == "str_spec_char": r += py_special_mapper(c.txt)
        else                       : r += gen(c)
    return r + '"'