# I: Include self in group (right asoc.)
# α: basic concat
# ρ: *special*

«««««««««««««««««««««««««««««««««« HEADERS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

py_bad_string_chr  = lambda s, bad="\\\"'{}": s in bad
py_escape_char     = lambda c, u='\\u': u+HXO(c) if py_bad_string_chr(c) else c
py_escape_string   = lambda s: ᐦ.join(py_escape_char(c) for c in s)
py_special_mapper  = lambda c, m={'𝗻':'\\n','𝘀':' ','𝘁':'\\t'}: m[c]
py_escape_var      = lambda s: ᒍ(ᐦ, ((ord(c)>127 or c in '!') and '_'+HXO(c) or c for c in s)) \
                            if 'NOVAR' not in CONST and s != '!=' else s

mkgrp = lambda *X, b="()": Ń("group", b[0], ⵌ(X)==1 and X[0] or X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkexp = lambda *X: Ń("expr", *X)
mkvar = lambda x: Ń("var", x)
mkstr = lambda x: Ń("str", '"', x, '"')

sst = lambda x: set(ᖵ(ᗜ,ᴍ(ⵐ,ⵉ(ᖇ(x,'␉',ń),ń))))
mdt = lambda y: ᖱ(ᴍ(ⵐ,ⵉ(x,ś,1)) for x in sst(y))
inv = lambda z: {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

COMMA, COLON = Node("oper_lit", ','), Node("oper_lit", ':')

def p_indent_stack(S, n=0):
    r = []
    while S:
        indent, *exprs = S[0]
        if indent > n:
            r.append(p_indent_stack(S, indent))
        elif indent < n:
            break
        else:
            S.pop(0)
            r.extend(exprs)
    return Node("BLOCK", r)

def whitespace_parser(n):
    calc_indent = lambda n: n.t == 'W' and n.c.split('\n')[-1].count(' ') // 4 or 0
    if n.S: return n
    N = n.copy()
    N.c = ᴍ(whitespace_parser, N.c)
    
    if N.t == "exprs":
        if not N.C: return N
        
        c_pre = N.C[0]
        blocks = [[indent_pre := calc_indent(c_pre)]]
        for c in N.C:
            if c.t == 'W':
                c_pre = c
                continue
            indent = calc_indent(c_pre)
            if indent == indent_pre:
                blocks[-1].append(c)
            else:
                blocks.append([indent, c])
            indent_pre = indent
        N.c = p_indent_stack(blocks, blocks[0][0]).c
    
    elif N.t == "group" and N.C[0].c == '〚':
        raise NotImplementedError
    
    return N

def whitespace_unparser(n, i=0):
    if n.S: return n
    N = n.copy()
    
    if N.t == "BLOCK":
        i += 1
    if N.t in ("BLOCK", "exprs"):
        sep = Node("N", ń+ś*4*i)
        N.c = sum(([sep, n] if n.t != "BLOCK" else [n] for n in N.c), [])
        if N.c and N.t == "exprs":
            N.c.pop(0)
    
    N.c = [whitespace_unparser(c, i) for c in N.c]
    return N

OPS_BUILTIN = {
    'S': ᐦ,
    'N': """; ␉ : ␉ , ␉ if ␉ elif ␉ else ␉ for""",
    'P': """+ ␉ - ␉ * ␉ ~  ␉   ** ␉  not ␉ yield""",
    'B': """+ ␉ - ␉ * ␉ @  ␉   ** ␉   // ␉  < ␉ > ␉ % ␉ .
            & ␉ ^ ␉ | ␉ /  ␉   != ␉   == ␉ << ␉ >>
                               in ␉   is ␉ or ␉ and""" }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

OPS_COMP = ᖵ(ᗜ, ({s for s in l if 'λ' in lang.ops[s]} for l in lang.op_orders.values()))

SWAP_TABLE = mdt("""
    ⋅   * ␉ ⌃    ** ␉ ≡     == ␉ ≤ <= ␉ ≔ := ␉ ¯ -
    ⠤   * ␉ ⠶    ** ␉ ≠     != ␉ ≥ >= ␉ ÷ /
    ∨  or ␉ ≅    is ␉ 󰆴    del ␉ Ω class
    ¬ not ␉ ¿    if ␉ ⊢    def ␉ ➰ while
    ∧ and ␉ ⸘  elif ␉ ⮂  yield ␉ ↪ return
    ∀ for ␉ ¡  else ␉ ⇥  break ␉ ↺ continue
    ∈  in ␉ ⮌  from ␉ ⨡ import ␉ ≇ is not""")
KEYWORDS_TO_CPY=rmk(inv(SWAP_TABLE), sst("* ␉ **"))

merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in SWAP_TABLE.items() if y in z}

kw_pfx_colon = merge_shorthands("""
    if ␉ elif ␉ else ␉ for ␉ while
    try ␉ except ␉ finally ␉ class
    match ␉ case ␉ def ␉ with""")
kw_pfx = merge_shorthands("""
    return ␉ continue ␉ break ␉ pass
    import ␉ global ␉ nonlocal
    raise ␉ assert ␉ del ␉ async""")
kw_neverswouce = merge_shorthands("""if ␉ elif ␉ else ␉ for ␉ yield""")
kw_inline = merge_shorthands("""in ␉ is ␉ is not ␉ or ␉ and ␉ not""") | kw_neverswouce
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("ℵ𝕋𝔽îπτ□∅∞ᐦ")

register("KW", kw)
register("KW_PFX", kw_pfx)
register("KW_SPEC", kw_spec)
register("KW_PFX_COLON", kw_pfx_colon)
register("VAR_SPEC", var_spec)

# 2 + a *= 5 ¿ z - 2*y ¡ 2 + z

new_ops = {}
for k, v in lang.ops.items():
    if not v.B or 'δ' in v: continue
    n = OP(k+'=', 'B', v.L, lang.ops["␀ASGN_MRK"].R, v.f)
    new_ops[n.t] = n
lang.ops |= new_ops

«««««««««««««««««««««««««««««««««« OPERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

⨡ᴺᴾ󰁔
␀ASGN_MRK ;ᴺᴾ󰁔 ,ᴺᴾ󰁔
=ᴺᴾ󰁔 ⮂ᴺᴾ󰁔 ↪ᴺᴾ󰁔 ⮌ᴺᴾ󰁔 ↺ᴺ󰁔 ⇥ᴺ󰁔 ➰ᴺᴾ󰁔 ∀ ␛
⠤ᴾ󰁔󰁞 ⠶ᴾ󰁔󰁞 :ᴺ󰁔
␀1ᴵᴮ ¿ᴺᴾ󰁔 ⸘ᴺᴾ󰁔 ¡ᴺᴾ󰁔
⨳ᴮᴾ󰀒ᴺ
⊻ᴮᴺ󰁖 ␉ ⨁ᴮᴺ󰁖 ␉ ∨ᴮᴺ󰁜 ␉ ⊼ᴮᴺ󰁖 ␉ ∧ᴮᴺ󰁜
≡ᴮᴺ󰁍󰁖 ≠ᴮᴺ󰁍󰁖 ≤ᴮᴺ󰁍󰁖 ≥ᴮᴺ󰁍󰁖 ∈ᴮᴺ󰁖 ∉ᴮᴺ󰁖 ∌ᴮᴺ󰁖 ∋ᴮᴺ󰁖 ␛
      <ᴮᴺ󰁖󰁏 >ᴮᴺ󰁖󰁏 ␛
      ≮ᴮᴺ󰁖 ≯ᴮᴺ󰁖 ⊈ᴮᴺ󰁖 ⊆ᴮᴺ󰁖 ⊄ᴮᴺ󰁖 ⊂ᴮᴺ󰁖 ⊃ᴮᴺ󰁖 ⊅ᴮᴺ󰁖 ⊇ᴮᴺ󰁖 ⊉ᴮᴺ󰁖
ᴍᴮᴺ ſᴮᴺ Σᴮᴾ󰀒ᴺ Πᴮᴾ󰀒ᴺ 󰈲ᴮᴾ󰀒ᴺ 󰈳ᴮᴾ󰀒ᴺ
ᐹᴮᴺ ζᴮᴺ
|ᴮᴺ ␉ ^ᴮᴺ ␉ &ᴮᴺ
<<ᴮᴺ >>ᴮᴺ
+ᴾᴮᴺ -ᴾᴮᴺ
≅ᴮᴺ󰁍 ≇ᴮᴺ󰁍
∘ᴮᴺ ○ᴮᴺ ⋄ᴮᴺ
◄ᴮᴺ󰁏 ►ᴮᴺ󰁏
∪ᴮᴺ ␉ ∩ᴮᴺ ␉ ⨉ᴮᴺ ∖ᴮᴺ
//ᴮᴺ /ᴮᴺ  ÷ᴮᴺ   %ᴮᴺ   @ᴮᴾᴺ󰁞  *ᴮᴺᴾ󰁞  ⋅ᴮᴺ  !󰀒ᴺ ␛
     ⭥ᴾ󰀒ᴺ ↨ᴾ󰀒ᴺ  ⤉ᴮᴾ󰀒ᴺ ⤈ᴮᴾ󰀒ᴺ  󷹄ᴮᴾ󰀒ᴺ  ☾ᴾ󰀒ᴺ 🃌ᴾ󰀒ᴺ ␛
     ᒍᴮᴺ  󰛔ᴮᴾ󰀒ᴺ 󰘬ᴮᴾ󰀒ᴺ ⛶ᴾ󰀒ᴺ   ⍉ᴾ󰀒ᴺ   ᴙᴾ󰀒ᴺ ␛
     ⋀ᴾ󰀒ᴺ ⋁ᴾ󰀒ᴺ
¬ᴾ󰀒ᴺ󰁜 ¯ᴾ
**ᴵᴮᴾ󰁞 …ᴮᴺ ⌃ᴵᴮ
.ᴵᴮ󰁏󰁔
...ᴺ

 .｜:=ᴵᴮ󰁜󰁏｜␀1
 .｜ ≔ᴵᴮ󰁜󰁏｜␀1
  ｜  ←ᴾ󰁜󰁏｜␀1
␀1｜  →󰀒󰁜󰁏｜

«««««««««««««««««««««««««««««««««« GRAMMAR »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

parser_main = exprs
parser_comment = (⠶str ∨ 󰆴comment ∨ ~‹.|\n›)*

exprs = W? (⠶expr W?)*
expr = (
    (kw_pfx_colon_expr =  ⠶vkw_pfx_colon 󰆴Æ? (expr_not_colon? 󰆴Æ? 󰆴':') M:✓ 󰆴E? expr?)
        ∨ (kw_pfx_expr =  ⠶vkw_pfx 󰆴E? expr?)
          ∨ (norm_expr = (⠶norm_expr_atom)+))

expr_not_colon = (¬':' ⠶norm_expr_atom)+
expr_not_comma = (¬',' ⠶norm_expr_atom)+

vkw_pfx_colon = ⮞kw_spec kw_pfx_colon ∨ kw_pfx_colon ⮞text_breaker
vkw_pfx       = ⮞kw_spec kw_pfx       ∨ kw_pfx       ⮞text_breaker
vkw           = ⮞kw_spec kw           ∨ kw           ⮞text_breaker

norm_expr_atom = (lamb ∨ ⠶gen_expr_atom) 󰆴E?
gen_expr_atom = group ∨ ⠶str ∨ var_spec ∨ oper ∨ ⠶vkw ∨ ⠶script ∨ var
var = (¬W ¬oper ¬var_spec ¬script ~‹[^𝗮-𝘇𝚲⥌↦①②③④󰅂"'\[\](){}⁅⁆〚〛⟨⟩‹ ␛␛␛›]›)+

group = ~‹[\[({⁅⟨〚]› (W? ↷ exprs) ~‹[\])}⁆⟩〛]›

oper = (
    (oper_mod_l = ~‹[⟥]*›)
     oper_lit
    (oper_mod_r = ~‹[´꜠ᵜ⟤]*›))

script = (
    (supscript = ~‹[ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻᴬᴮ󰀂ᴰᴱ󰀅ᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾ󰀐ᴿ󰀒ᵀᵁⱽᵂ󰀗󰀘󰀙󰁌󰁍󰁎󰁏󰁐󰁑󰁒󰁓◌󰁔󰁕󰁖󰁗󰁘󰁙󰁛󰁜󰁝󰁞󰁟󰁠󰁡󰁢󰁣󰁤◌◌󰀶◌◌󰀻󰁁󰁃󰁅󰁈󰁊󰁋⁰¹²³⁴⁵⁶⁷⁸⁹◌󰁱󰂂󰂁󰁲◌ꜝ⁺⁻ᐟ⁼⁽⁾◌◌◌˜]+›)
  ∨ (subscript = ~‹[ₐₑₕᵢⱼₖₗₘₙ󰂼ₚᵣₛₜᵤᵥₓ󰂓󰂔󰂕󰂖󰂗󰂘󰂙󰂚󰂛󰂜󰂝󰂞󰂟󰂠󰂡󰂢󰂣󰂤󰂥󰂦󰂧󰂨󰂩󰂪󰂫󰂬󰃤󰃥󰃦󰃧󰃨󰃩󰃪󰃫◌󰃬󰃭󰃮󰃯󰃰󰃱󰃳󰃴󰃵󰃶󰃷󰃸󰃹󰃺󰃻󰃼◌◌󰃎󰃏◌󰃓󰃙󰃛󰃝󰃠󰃢󰃣₀₁₂₃₄₅₆₇₈₉﹕󰄎󰄟󰄞󰄏﹖◌₊₋⸝₌₍₎﹠﹩﹪◌]+›))

lamb = (
    ( 
        (lamb_h_py = 󰆴"lambda" ⮞text_breaker 󰆴Æ ⠶expr_not_colon 󰆴':')
      ∨ (lamb_h_normal = 
            󰆴('⥌' Æ?)
            ⠶((¬lamb_h_implicit lamb) ∨ ⠶gen_expr_atom 󰆴Æ?)*
            󰆴'↦' )
      ∨ (lamb_h_preset = ~"[𝚲①②③④]")
      ∨ (lamb_h_implicit = var 󰆴(Æ? '↦'))) 󰆴Æ?
    (lamb_b = ⠶((exprs 󰆴'󰅂') ∨ expr_not_comma)))

str = str_cpy ∨ str_py ∨ str_escape ∨ str_spec_char
str_cpy = 󰆴'‹' (str_escape ∨ str_sub ∨ str_spec_char ∨ str_guts)* 󰆴'›'
str_sub = 󰆴'〚' exprs 󰆴'〛'
str_spec_char = ~‹[𝗮-𝘇]›
str_guts = ~"[^〚␛␛›]+"
str_escape = 󰆴"␛␛" ~‹.›
str_py = ((‹"› (str_py_sub ∨ ~‹[^"\\]+›)* ‹"›)
       ∨  (‹'› (str_py_sub ∨ ~‹[^'\\]+›)* ‹'›))

str_py_sub = ~‹\\.›

w = ~‹[ \t]+›
W = ~‹[ \t\n]+›
text_breaker = ⮞(E ∨ kw_spec ∨ var_spec ∨ ¬var)
E = w ∨ ~‹␛␛[\\\n]›
Æ = W ∨ ~‹␛␛[\\\n]›

comment = ~‹((|#)[^\n]*(\n|\Z))|(🟑[^🟑]*(🟑|\Z))|(֎[^֎]*(֎|\Z))›

«««««««««««««««««««««««««««««««««« GENERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

# § tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

def σ_00():
    @(yield replacement(
        *KEYWORD_NODE_NAMES,
        n="Lang keywords → cpy keywords"))
    def _(n):
        if n.txt in kw_inline: # keyword that are just ops
            return OP.TND(KEYWORDS_TO_CPY.get(n.txt, n.txt))
        else:
            return n.copy(c=KEYWORDS_TO_CPY.get(n.txt, n.txt))
    
    ((yield replacement(
        "norm_expr", "expr_not_colon", "expr_not_comma",
        rec='B', n="Normalize expression types"))
    (lambda n: n.copy("expr")))
    
    ((yield reduction(
        "subscript",
        rec='A',
        n="Subscripts to brackets"))
    (lambda n: mkgrp(gram(n.c, "exprs"), b="[]")))
    
    ((yield replacement(
        "W",
        n="Trim whitespace"))
    (lambda n: n.copy(c=ń in n.c and ń+ⵉ(n.c,ń)[-1] or n.c)))

def σ_05():
    op_chk = lambda n, o: n.t == "oper" and n.txt == o
    hs_op = lambda C, o: ⴸ(op_chk(c, o) for c in C)

    @(yield replacement(
        "expr",
        rec='A',
        n="Detect for_expr"))
    def _(N):
        if not hs_op(C := N.C, '∀'): return N
        
        α, _, β = part(C, ρ(op_chk, o='∀'))
        β, _, γ = part(β, ρ(op_chk, o='∈'))
        if hs_op(γ, '¿'):
            γ, _, σ = part(γ, ρ(op_chk, o='¿'))
        else:
            σ = None
        
        cc = [Node("expr", α), Node("expr", β), Node("expr", γ)]
        if σ: cc.append(Node("expr", σ, e="cond"))
        return N.copy("for_expr", c=cc)
    
    @(yield replacement(
        "kw_pfx_colon_expr",
        rec='A',
        n="Detect for_stmt"))
    def _(N):
        if not op_chk(N.C[0], '∀'): return N
        α, _, β = part(N.C[1].C, ρ(op_chk, o='∈'))
        return N.copy("for_stmt", c=[Node("expr", α), Node("expr", β), *N.C[2:]])

def σ_10():
    ((yield replacement(
        "parser_main", rec='A', n="Build whitespace blocks"))
    (whitespace_parser))

ARG_A = mkexp(("oper_lit", "⠤"), mkvar('𝔸'))
ARG_K = mkexp(("oper_lit", "⠶"), mkvar('𝕂'))
def σ_15():
    yield "Refactor lambdas"
    ((yield replacement(
        "lamb_h_preset"))
    (lambda n: Ń("lamb_h",
            *ᴍ(lambda t: mkexp(mkvar(t)), "xyzw"[:"𝚲①②③④".index(n.c)]),
            ARG_A, ARG_K)))
    
    ((yield replacement(
        "lamb_h_implicit"))
    (lambda n: Ń("lamb_h", mkexp(n.C[0]), ARG_A, ARG_K)))
    
    @(yield replacement(
        "lamb_h_normal", "lamb_h_py"))
    def _(n):
        C = ᴍ(Node.strip, ᴍs(mkexp, split_at(n.C,
            lambda x: OP.is_op(x) and (k:=op_man[x]).t == ',')))
        has_a = has_k = ⴴ
        for c in C:
            if not c.C or (o:=c.C[0]) != "oper":
                continue
            k = o.C[1].c
            if   k in ( "*", "⠤"): has_a = ⴳ
            elif k in ("**", "⠶"): has_k = ⴳ
        if not has_a: C.append(ARG_A)
        if not has_k: C.append(ARG_K)
        return Ń("lamb_h", *C)
    
    ((yield replacement(
        "lamb_b",
        rec='A'))
    (lambda n: n.copy(t="expr")))

def σ_20():
    ((yield replacement(
        "expr",
        rec='B',
        n="Parse expressions"))
    (lambda n: n.copy(c=into_expr(parse_expr(n.C)).c)))

def σ_25():
    @(yield reduction(
        "op_call",
        rec='B',
        n="Flatten cmp ops"))
    def _(n):
        if 'λ' in op_man[n.C[1]] and \
                n.C[0] != NULL and n.C[2] != NULL:
            return [*n.C[0].C, n.C[1], *n.C[2].C]
        return [n]

def make_cmp_chain(n, layers=ᗜ):
    layers = layers or OPS_COMP
    layer, *layers = layers
    
    rec = lambda n: layers and make_cmp_chain(n, layers=layers) or n
    mkexp_rec = lambda N: rec(mkexp(*N))
    
    C = ᒪ(split_at(n.C,
        lambda x: OP.is_op(x) and (k:=op_man[x]).t in layer and k.B,
        keep_separator=ⴳ))
    if ⵌ(C) < 3:
        return rec(n)
    r = ⴴ
    
    tmp_v = mkexp(mkvar("🜄"))
    for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
        c = mkexp_rec(c)
        v = mkexp(("op_call", H and mkexp_rec(a) or tmp_v,
                              b,
                              T and c or mkexp(("op_call", tmp_v, OP.TND('≔'), c))))
        r = mkexp(("op_call", r, OP.TND('∧'), v)) if r else v
    return n.copy(c=[r])

def σ_30():
    yield "Generate comparison chains"
    ((yield replacement(
        "expr",
        rec='B'))
    (make_cmp_chain))

demodp = lambda o: (o.C[0].txt, o.C[1], o.C[2].txt)
def mkbltnop(op_l): # format builtins if needed
    t = op_l.txt
    if (t := SWAP_TABLE.get(t,t)) not in OPS_BUILTIN['A']:
        return op_l
    return mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
def transform_oper(op_): # apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    if not (m_l or m_r):
        return op_l
    op_n = mkbltnop(op_l)
    mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
    if '⟥' in m_l: op_n = mkmod(op_n, "LNULL")
    if '⟤' in m_r: op_n = mkmod(op_n, "RNULL")
    if 'ᵜ' in m_r: op_n = mkmod(op_n, "SWAPA")
    if '꜠' in m_r: op_n = mkmod(op_n, "DUPER")
    return op_n

def σ_35():
    hnul = lambda x: x.copy("NULL_") if x == "NULL" else x
    
    def try_builtin(m, op_l, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
        if m_l or m_r:
            return
        t_ = SWAP_TABLE.get(t, t)
        if t_ not in OPS_BUILTIN[m]:
            return
        return mkgxp(*ε(L), op_l, *ε(R))

    @(yield replacement(
        "op_call",
        rec='B',
        n="Refactor op calls"))
    def _(n):
        l, op_, r = n.C
        op = op_man[op_]
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
        
        if not (m_l or m_r):
            if 'β' in op and     L and R: return mkgxp(L, op_l, R)
            if 'σ' in op and not L and R: return mkexp(op_l, r)
            if 'ι' in op: return mkexp(hnul(l), op_l, hnul(r))
            if 'ρ' in op:
                match t:
                    case '→': return L
                    case '←': return R
                    case '≔': return mkgxp(l, op_l, R)
                    case ('¬') if L or R:
                            return mkgxp(op_l, L or R)
        
        op_l = transform_oper(op_)
        
        A = (op_l, L, m_l, t, m_r, R)
        if op.S and L and not op.B:
            return try_builtin('S', *A) or mkexp(mkbltnop(op_), L)
        if op.P and R and not op.B:
            return try_builtin('P', *A) or mkexp(mkbltnop(op_), R)
        if op.B and L and R:
            return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA,    r))
        if op.S and L:
            return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA, NULL))
        if op.P and R:
            return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    r))
        return mkbltnop(op_)

def σ_40():
    @(yield replacement(
        "oper",
        rec='A',
        n="Refactor sitting ops"))
    def _(n):
        if n.C[1].txt in kw_neverswouce:
            return n
        if not (n.C[2].txt or n.C[0].txt):
            n = n.copy(c=[n.C[0], n.C[1], n.C[2].copy(c="´")])
        return transform_oper(n)
    
    ((yield replacement(
        *KEYWORD_NODE_NAMES, "oper_lit",
        n="Lang keywords ← cpy keywords"))
    (lambda n: n.copy(c=py_escape_var(SWAP_TABLE.get(n.txt, n.txt)))))
    
    ((yield replacement(
        "lamb",
        rec='B',
        n="Format lambda"))
    (lambda n: mkgxp(n.C[0], mkgrp(n.C[1]))))
    
    ((yield replacement(
        "lamb_h",
        rec='B',
        n="Format lambda header"))
    (lambda n: Ń("lamb_h", ("kw", "lambda"), *J́(n.C, COMMA), ("oper_lit", ":"))))

def σ_45():
    ((yield replacement(
        "parser_main",
        rec='A',
        n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((yield reduction(
        "BLOCK",
        rec='B',
        n="Flatten blocks"))
    (lambda n: n.C))

def σ_48():
    ((yield replacement(
        "for_expr",
        rec='B',
        n="Build for exprs"))
    (lambda n: Ń(
        "expr",
        n.C[0], ("kw", "for"), n.C[1], ("kw", "in"), n.C[2],
        *([("kw", "if"), n.C[3]] if n['cond'] else []))))
    
    ((yield replacement(
        "for_stmt",
        rec='B',
        n="Build for stmt"))
    (lambda n: Ń(
        "kw_pfx_colon_expr",
        Node("kw_pfx_colon", "for"),
        ("expr", n.C[0], ("kw", "in"), n.C[1]),
        *n.C[2:])))

def σ_50():
    def incompat_char(x, y):
        good_chars = "~*/@%&^|-+=:;,.#<>()[]{}' \"\n\t\\"
        return not (x in good_chars or y in good_chars)
    
    def flat_all(n):
        if not n.C: return n
        cc, s = [], peekable([flat_all(c) for c in n.C])
        while ((α := next(s)) or 1) and s:
            β = s.peek()
            cc.append(α)
            if (a:=α.txt) and (b:=β.txt) and incompat_char(a[-1], b[0]):
                cc.append(Node('w', ś))
        cc.append(α)
        return n.copy(c=cc)

    ((yield replacement(
        "kw_pfx_colon_expr",
        rec='B',
        n="Add colons"))
    (lambda n: n.insert_after_marker('M', COLON)))
    
    ((yield replacement(
        "parser_main",
        rec='B',
        n="Insert spaces"))
    (flat_all))

# § node transpilers
@generator(*KEYWORD_NODE_NAMES, "oper_lit")
def gen_oper_lit     (n): return py_escape_var(n.txt) # n.txt
@generator("var", "var_spec")
def gen_variable     (n): return py_escape_var(n.txt)
@generator("NULL")
def gen_variable     (n): return "NULL"

# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[0]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("str_cpy")
def gen_special_str(n):
    r='f"""'
    for c in n.c:
        if   c.t == "str_escape"   : r += py_escape_string(c.txt)
        elif c.t == "str_spec_char": r += py_special_mapper(c.txt)
        else                       : r += gen(c)
    return r + '"""'