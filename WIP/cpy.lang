# N: 0
# P: 1 (Prefix)
# S: 1 (Suffix)
# B: 2
# α: basic concat
# Δ: has binary builtin
# ρ: *special*

«««««««««««««««««««««««««««««««««« HEADERS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

py_bad_string_chr  = lambda s, bad="\\\"'{}": s in bad
py_escape_char     = lambda c, pre=ᐦ: pre+HXO(c) if py_bad_string_chr(c) else c
py_escape_string   = lambda s: ᐦ.join(py_escape_char(c, '\\u') for c in s)
py_escape_var      = lambda s: s # ᐦ.join(f'_{HXO(c)}' if ord(c) > 127 else c for c in s)
py_special_mapper  = lambda c, m={'𝗻':'\\n','𝘀':' ','𝘁':'\\t'}: m[c]
PY_ARGS, PY_KWARGS = py_escape_var("𝔸"), py_escape_var("𝕂")

mkgrp = lambda *X, b="()": Ń("group", b[0], ⵌ(X)==1 and X[0] or X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkexp = lambda *X: Ń("expr", *X)
mkvar = lambda x: Ń("variable", x)
mkstr = lambda x: Ń("str", '"', x, '"')
fmtop = lambda x: inv(SWAP_TABLE).get(x, x)

def p_indent_stack(S, n=0):
    r = []
    while S:
        indent, *exprs = S[0]
        if indent > n:
            r.append(p_indent_stack(S, indent))
        elif indent < n:
            break
        else:
            S.pop(0)
            r.extend(exprs)
    return Node("BLOCK", r)

calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
def whitespace_parser(n):
    if n.S: return n
    N = n.copy()
    N.c = ᴍ(whitespace_parser, N.c)
    
    if N.t == "exprs":
        if not N.C: return N
        
        c_pre = N.C[0]
        blocks = [[indent_pre := calc_indent(c_pre)]]
        for c in N.C:
            if c.t == 'W':
                c_pre = c
                continue
            indent = calc_indent(c_pre)
            if indent == indent_pre:
                blocks[-1].append(c)
            else:
                blocks.append([indent, c])
            indent_pre = indent
        N.c = p_indent_stack(blocks, blocks[0][0]).c
    
    elif N.t == "group" and N.C[0].c == '〚':
        raise NotImplementedError
    
    return N

def whitespace_unparser(n, i=0):
    if n.S: return n
    N = n.copy()
    
    if N.t == "BLOCK":
        i += 1
    if N.t in ("BLOCK", "exprs"):
        sep = Node("N", ń+ś*4*i)
        N.c = sum(([sep, n] if n.t != "BLOCK" else [n] for n in N.c), [])
        if N.c and N.t == "exprs":
            N.c.pop(0)
    
    N.c = [whitespace_unparser(c, i) for c in N.c]
    return N

sst = lambda x: set(ᖵ(ᗜ,ᴍ(ⵐ,ⵉ(ᖇ(x,'␉',ń),ń))))
mdt = lambda y: ᖱ(ᴍ(ⵐ,ⵉ(x,ś,1)) for x in sst(y))
inv = lambda z: {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

OPS_BUILTIN = {
    'S': ᐦ,
    'N': """; ␉ : ␉ ,""",
    'P': """+ ␉ - ␉ * ␉ ~ ␉ **""",
    'B': """+ ␉ - ␉ * ␉ @ ␉ ** ␉ // ␉  < ␉ > ␉ % ␉ .
            & ␉ ^ ␉ | ␉ / ␉ != ␉ == ␉ << ␉ >> """ }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

SWAP_TABLE = mdt("""
    ⋅   * ␉ ≡    == ␉ ≔   := ␉ ÷ / ␉ ≠ != ␉ ≤ <=
    ⠤   * ␉ ⠶    ** ␉ ≥   >= ␉ ¯ - ␉ ⌃ **
    ∨  or ␉ 󰆴   del ␉ ≅   is ␉ Ω class
    ¬ not ␉ ⊢   def ␉ ¿   if ␉ ➰ while
    ∧ and ␉ ⮂ yield ␉ ⸘ elif ␉ ↪ return
    ∀ for ␉ ⇥ break ␉ ¡ else ␉ ↺ continue""")
SWAP_NO = sst("* ␉ **")
merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in rmk(SWAP_TABLE, SWAP_NO).items() if y in z}

kw_pfx_colon = merge_shorthands("""
    if ␉ elif ␉ else ␉ for ␉ while
    try ␉ except ␉ finally ␉ class
    match ␉ case ␉ def ␉ with""")
kw_pfx = merge_shorthands("""
    return ␉ continue ␉ break ␉ pass
    import ␉ global ␉ nonlocal
    raise ␉ assert ␉ del ␉ async""")
kw_inline = merge_shorthands("""
    is ␉ or ␉ and ␉ not ␉ if ␉ elif ␉ else ␉ for ␉ yield""")
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("ℵ𝕋𝔽îπτ□∅∞ᐦ")

register("VAR_SPEC", var_spec)
register("KW", kw)
register("KW_PFX", kw_pfx)
register("KW_SPEC", kw_spec)
register("KW_PFX_COLON", kw_pfx_colon)

«««««««««««««««««««««««««««««««««« OPERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

;ᴺ ,ᴺᴾ󰁜
=ᴺ ⮂ᴾ
⠤ᴾ󰁜 ⠶ᴾ󰁜 :ᴺ
␀1ᴵᴮ ¿ᴺ ⸘ᴺ ¡ᴺ
⨳ᴮᴾ󰀒ᴺ
⊻ᴮᴺ󰁖 ␉ ∨ᴮᴺ󰁜󰀷
⊼ᴮᴺ󰁖 ␉ ∧ᴮᴺ󰁜󰀷
==ᴮᴺ󰁖 !=ᴮᴺ󰁖 ≜ᴮᴺ󰁖 ≡ᴮᴺ󰁖 ≠ᴮᴺ󰁖 ≮ᴮᴺ󰁖 <ᴮᴺ󰁖 ≤ᴮᴺ󰁖 ≥ᴮᴺ󰁖 >ᴮᴺ󰁖 ≯ᴮᴺ󰁖 ␛
      ∈ᴮᴺ󰁖 ∉ᴮᴺ󰁖 ∌ᴮᴺ󰁖 ∋ᴮᴺ󰁖 ⊈ᴮᴺ󰁖 ⊆ᴮᴺ󰁖 ⊄ᴮᴺ󰁖 ⊂ᴮᴺ󰁖 ⊃ᴮᴺ󰁖 ⊅ᴮᴺ󰁖 ␛
      ⊇ᴮᴺ󰁖 ⊉ᴮᴺ󰁖
ᴍᴮᴺ ſᴮᴺ Σᴮᴾ󰀒ᴺ Πᴮᴾ󰀒ᴺ 󰈲ᴮᴾ󰀒ᴺ 󰈳ᴮᴾ󰀒ᴺ
ᐹᴮᴺ ζᴮᴺ
|ᴮᴺ󰀷 ␉ ^ᴮᴺ󰀷 ␉ &ᴮᴺ󰀷
<<ᴮᴺ󰀷 >>ᴮᴺ󰀷
+ᴾᴮᴺ󰀷 -ᴾᴮᴺ󰀷
∘ᴮᴺ ○ᴮᴺ ⋄ᴮᴺ
◄ᴮᴺ ►ᴮᴺ
∪ᴮᴺ ␉ ∩ᴮᴺ ␉ ⨉ᴮᴺ ∖ᴮᴺ
//ᴮᴺ󰀷 /ᴮᴺ󰀷 ÷ᴮᴺ󰀷  %ᴮᴺ󰀷  @ᴮᴾᴺ󰀷󰁜 *ᴮᴺᴾ󰀷󰁜 ⋅ᴮᴺ󰀷 !󰀒ᴺ  ␛
      ⭥ᴾ󰀒ᴺ ↨ᴾ󰀒ᴺ  ⤉ᴮᴾ󰀒ᴺ ⤈ᴮᴾ󰀒ᴺ  󷹄ᴮᴾ󰀒ᴺ  ☾ᴾ󰀒ᴺ 🃌ᴾ󰀒ᴺ ␛
      ᒍᴮᴺ  󰛔ᴮᴾ󰀒ᴺ 󰘬ᴮᴾ󰀒ᴺ ⛶ᴾ󰀒ᴺ   ⍉ᴾ󰀒ᴺ   ᴙᴾ󰀒ᴺ ␛
      ⋀ᴾ󰀒ᴺ ⋁ᴾ󰀒ᴺ
¬ᴾᴺ󰀷 ¯ᴾ󰀷
…ᴮ ⌃ᴵᴮ󰀷 **ᴵᴮᴾ󰀷󰁜
.ᴵᴮ󰁜

 .｜:=ᴵᴮ󰁜｜␀1
 .｜ ≔ᴵᴮ󰁜｜␀1
  ｜  ←ᴾ󰁜｜␀1
␀1｜  →󰀒󰁜｜

«««««««««««««««««««««««««««««««««« GRAMMAR »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

parser_main = exprs
parser_comment = (str / comment / ~"."s)*

exprs = W? (_expr W?)*
_expr = kw_pfx_colon_expr / kw_pfx_expr / norm_expr

        norm_expr = _norm_expr_atom+
      kw_pfx_expr = _kw_pfx norm_expr
kw_pfx_colon_expr = _kw_pfx_colon __E? expr_not_colon? ':' __E? _expr?

expr_not_colon = (!':' _norm_expr_atom)+

_kw_pfx_colon = (&kw_spec kw_pfx_colon) / (kw_pfx_colon __text_breaker)
_kw_pfx       = (&kw_spec kw_pfx      ) / (kw_pfx       __text_breaker)
_kw           = (&kw_spec kw          ) / (kw           __text_breaker)

_norm_expr_atom = (lamb / _gen_expr_atom) __E?
_gen_expr_atom = group / str / var_spec / oper / _kw / _script / variable_
variable_ = (!W !oper !var_spec !_script ~"[^𝗮-𝘇␛𝚲⥌↦①②③④󰅂\\\"\\' \\[\\](){}⁅⁆〚〛⟨⟩‹›]")+

group = ~"[\\[({⁅⟨〚]" exprs ~"[\\])}⁆⟩〛]"

oper = oper_mod_l oper_lit oper_mod_r
oper_mod_l = ~"[⟥]*"
oper_mod_r = ~"[´꜠ᵜ⟤]*"

_script = supscript / subscript
supscript = ~"[ᵃᵇᶜᵈᵉᶠᵍʰⁱʲᵏˡᵐⁿᵒᵖʳˢᵗᵘᵛʷˣʸᶻᴬᴮ󰀂ᴰᴱ󰀅ᴳᴴᴵᴶᴷᴸᴹᴺᴼᴾ󰀐ᴿ󰀒ᵀᵁⱽᵂ󰀗󰀘󰀙󰁌󰁍󰁎󰁏󰁐󰁑󰁒󰁓◌󰁔󰁕󰁖󰁗󰁘󰁙󰁛󰁜󰁝󰁞󰁟󰁠󰁡󰁢󰁣󰁤◌◌󰀶󰀷◌󰀻󰁁󰁃󰁅󰁈󰁊󰁋⁰¹²³⁴⁵⁶⁷⁸⁹◌󰁱󰂂󰂁󰁲◌ꜝ⁺⁻ᐟ⁼⁽⁾◌◌◌˜]+"
subscript = ~"[ₐₑₕᵢⱼₖₗₘₙ󰂼ₚᵣₛₜᵤᵥₓ󰂓󰂔󰂕󰂖󰂗󰂘󰂙󰂚󰂛󰂜󰂝󰂞󰂟󰂠󰂡󰂢󰂣󰂤󰂥󰂦󰂧󰂨󰂩󰂪󰂫󰂬󰃤󰃥󰃦󰃧󰃨󰃩󰃪󰃫◌󰃬󰃭󰃮󰃯󰃰󰃱󰃳󰃴󰃵󰃶󰃷󰃸󰃹󰃺󰃻󰃼◌◌󰃎󰃏◌󰃓󰃙󰃛󰃝󰃠󰃢󰃣₀₁₂₃₄₅₆₇₈₉﹕󰄎󰄟󰄞󰄏﹖◌₊₋⸝₌₍₎﹠﹩﹪◌]+"

lamb = lamb_h __E? lamb_b
lamb_h = lamb_h_py / lamb_h_normal / lamb_h_implicit / lamb_h_preset
lamb_b = (exprs '󰅂') / _expr
lamb_h_preset   = ~"[𝚲①②③④]"
lamb_h_implicit = variable_ '↦'
lamb_h_normal   = '⥌' lamb_h_exprs '↦'
lamb_h_py       = "lambda" __text_breaker expr_not_colon? ':'
lamb_h_exprs = W? (_lamb_h_expr W?)+
_lamb_h_expr = (!lamb_h_implicit lamb) / _gen_expr_atom

str = str_cpy / str_py / str_escape / str_spec_char
str_cpy = ('‹' (str_escape / str_sub / str_spec_char / str_guts)* '›')
str_sub = '〚' exprs '〛'
str_guts = !str_spec_char ~"[^␛〚›]+"
str_escape = ~"␛."
str_spec_char = ~"[𝗮-𝘇]"
str_py = (('"' (str_py_sub / ~"[^\\\\\"]+")* '"')
       /  ("'" (str_py_sub / ~"[^\\\\\']+")* "'"))
str_py_sub = ~"\\\\."

w = ~"[ \t]+"
W = ~"[ \t\n]+"
__w = w
__text_breaker = __E / &kw_spec / &var_spec / !variable_
__E = __w / __escaped_newline
__escaped_newline = "␛\n"

comment = ~"([|#][^\\n]*(\\n|\\Z))|(🟑[^🟑]*(🟑|\\Z))|(֎[^֎]*(֎|\\Z))"s

«««««««««««««««««««««««««««««««««« GENERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

# § tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

@reduction("supscript", order=-1)
def supscript(n): return [OP.sym_to_node("."), Node("variable_", n.txt)]
@replacement("subscript", recurse_children='A', order=-1)
def subscript(n): return Ń("group", '[', parse_as("exprs", n.c), ']')

replacement("parser_main", order=0, recurse_children='A')(whitespace_parser)
@replacement("norm_expr", "expr_not_colon", recurse_children='B', order=0)
def expr_not_colon(n): return n.copy("expr")

OP_NORMER = inv(rmk(SWAP_TABLE, SWAP_NO))
@replacement(*KEYWORD_NODE_NAMES, order=0)
def kw(n): return OP.sym_to_node(h) if (h := OP_NORMER.get(n.txt)) else n
@replacement(*KEYWORD_NODE_NAMES, order=49)
def rep_keyword(n): return n.copy(c=OP_NORMER.get(n.txt, n.txt))

@replacement("expr", recurse_children='B', order=50)
def expr(n): return into_expr(parse_expr(ᖵ(lambda x: x.t != 'w', n.C)))

@reduction("op_call", recurse_children='B', order=50.1)
def op_call(n):
    if 'λ' in op_man[n.C[1]] and \
            n.C[0] != NULL and n.C[2] != NULL:
        return [*n.C[0].C, n.C[1], *n.C[2].C]
    return [n]

@replacement("expr", recurse_children='B', order=50.2)
def expr(n):
    C = ᒪ(split_at(n.C,
        lambda x: OP.is_op(x) and 'λ' in (k:=op_man[x]) and k.B,
        keep_separator=ⴳ))
    if ⵌ(C) <= 3: return n
    r = ⴴ
    
    for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
        v = Ń("op_call",
            mkexp(*(a if H else [mkvar("tmp")])),
            b,
            mkexp(*(c if T else [mkgxp(("op_call",
                    mkvar("tmp"),
                    OP.sym_to_node('≔'),
                    mkgxp(*c)))])))
        r = mkgxp(("op_call", mkexp(r), OP.sym_to_node('∧'), mkexp(v))) if r else v
    return n.copy(c=[r])

# replacement("exprs", order=50.3)(exit)

demodp = lambda o: (o.C[0].txt, o.C[1], o.C[2].txt)

@replacement("op_call", recurse_children='A', order=51)
def op_call(n):
    l, op_, r = n.C
    op = op_man[op_]
    t = fmtop(op.t)
    m_l, op_l, m_r = demodp(op_)
    L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
    
    if 'ρ' in op and not (m_l or m_r):
        match t:
            case '→': return L
            case '←': return R
            case ',': return mkexp(   op_l, r)
            case '.': return mkexp(l, op_l, r)
            case '≔': return mkgxp(l, op_l, R)
            case ('¬') if R:
                      return mkgxp(op_l, R)
            case ('∨'|'∧') if L and R:
                      return mkgxp(L, op_l, R)
            case ('@'|'⠤'|'⠶'|'*'|'**') if not L and R:
                      return mkexp(op_l, R)
    
    def mkbltnop(op_l): # format builtins if needed
        t = op_l.txt
        if SWAP_TABLE.get(t,t) not in OPS_BUILTIN['A']:
            return op_l
        return mkgxp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
    
    def transform_oper(op_): # apply modifiers to op
        m_l, op_l, m_r = demodp(op_)
        if not (m_l or m_r):
            return op_l
        op_n = mkbltnop(op_l)
        mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
        if '⟥' in m_l: op_n = mkmod(op_n, "LNULL")
        if '⟤' in m_r: op_n = mkmod(op_n, "RNULL")
        if 'ᵜ' in m_r: op_n = mkmod(op_n, "SWAPA")
        if '꜠' in m_r: op_n = mkmod(op_n, "DUPER")
        return op_n
    
    def try_builtin(m, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
        if m_l or m_r:
            return
        t_ = SWAP_TABLE.get(t, t)
        if t_ not in OPS_BUILTIN[m]:
            return
        return mkgxp(*ε(L), op_l, *ε(R))
    
    op_l = transform_oper(op_)
    COMMA = ("oper_lit", ',')
    
    A = (L, m_l, t, m_r, R)
    if op.S and L and not (op.P or R):
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(L))
    if op.P and R and not (op.S or L):
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(R))
    if op.B and L and R:
        return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA,    R))
    if op.S and L:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA, NULL))
    if op.P and R:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    R))
    return mkbltnop(op_)

@replacement("oper", recurse_children='A', order=52)
def rep_oper(n): return transform_oper(*(x.c for x in n.C)) if '´' in n.C[2].txt else n

@replacement(*KEYWORD_NODE_NAMES, "oper_lit", order=52)
def rep_keyword(n): return n.copy(c=SWAP_TABLE.get(n.txt, n.txt))

replacement("parser_main", order=100, recurse_children='A')(whitespace_unparser)
@reduction("BLOCK", recurse_children='B', order=100)
def BLOCK(n): return n.C
@replacement("expr", recurse_children='B', order=100)
def expr(n): return n.copy(c=J́(n.C, Node('w', ś)))

# § node transpilers
@generator("oper_lit", *KEYWORD_NODE_NAMES)
def gen_oper_lit     (n): return SWAP_TABLE.get(n.txt, n.txt) + ś
@generator("variable_", "op_spec")
def gen_variable     (n): return py_escape_var(n.txt)

# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt[1:]) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[1]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("str_cpy")
def gen_special_str(n, *, r='"'):
    for c in n.c[1:-1]:
        match c.t:
            case "str_escape"   : r += py_escape_string(c.txt[1:])
            case "str_spec_char": r += py_special_mapper(c.txt)
            case _              : r += gen(c)
    return r + '"'

# lambdas
@generator("lamb")
def gen_lamb(n):
    h, b = n.C
    h = h.C[0]
    if h.t == "lamb_h_preset":
        H = ᐦ.join(x+',' for x in [*"xyzw"[:"𝚲①②③④".index(h.txt)]])
        H = f"{H}*{PY_ARGS},**{PY_KWARGS}"
    elif h.t == "lamb_h_implicit":
        H = f"{h.C[0].txt},*{PY_ARGS},**{PY_KWARGS}"
    elif h.t in ("lamb_h_normal", "lamb_h_py"):
        h = h.C[1]
        expr = split_at(h.C, lambda x: x.txt == ',')
        has_a = has_k = ⴴ
        for e in expr:
            if not (t := ⵐ(ᒍ(ᐦ, (k.txt for k in e)))): continue
            if t[:2] == '**': has_k = ⴳ
            elif t[0] == '*': has_a = ⴳ
        
        H = gen(h)
        if has_a and has_k: pass
        elif has_a: H += f',**{PY_KWARGS}'
        elif has_k: H += f',*{PY_ARGS}'
        else      : H += f',*{PY_ARGS},**{PY_KWARGS}'
    else:
        assert ⴴ
    return f"(lambda {H}: {gen(b.C[0])})"