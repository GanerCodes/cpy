# N: 0
# P: 1 (Prefix)
# S: 1 (Suffix)
# B: 2
# Î±: basic concat
# Î”: has binary builtin
# Ï: *special*

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« HEADERS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

py_bad_string_chr  = lambda s, bad="\\\"'{}": s in bad
py_escape_char     = lambda c, pre=á¦: pre+HXO(c) if py_bad_string_chr(c) else c
py_escape_string   = lambda s: á¦.join(py_escape_char(c, '\\u') for c in s)
py_escape_var      = lambda s: s # á¦.join(f'_{HXO(c)}' if ord(c) > 127 else c for c in s)
py_special_mapper  = lambda c, m={'ğ—»':'\\n','ğ˜€':' ','ğ˜':'\\t'}: m[c]
PY_ARGS, PY_KWARGS = py_escape_var("ğ”¸"), py_escape_var("ğ•‚")

mkgrp = lambda *X, b="()": Åƒ("group", b[0], âµŒ(X)==1 and X[0] or X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkexp = lambda *X: Åƒ("expr", *X)
mkvar = lambda x: Åƒ("variable", x)
mkstr = lambda x: Åƒ("str", '"', x, '"')
fmtop = lambda x: inv(SWAP_TABLE).get(x, x)

def p_indent_stack(S, n=0):
    r = []
    while S:
        indent, *exprs = S[0]
        if indent > n:
            r.append(p_indent_stack(S, indent))
        elif indent < n:
            break
        else:
            S.pop(0)
            r.extend(exprs)
    return Node("BLOCK", r)

calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
def whitespace_parser(n):
    if n.S: return n
    N = n.copy()
    N.c = á´(whitespace_parser, N.c)
    
    if N.t == "exprs":
        if not N.C: return N
        
        c_pre = N.C[0]
        blocks = [[indent_pre := calc_indent(c_pre)]]
        for c in N.C:
            if c.t == 'W':
                c_pre = c
                continue
            indent = calc_indent(c_pre)
            if indent == indent_pre:
                blocks[-1].append(c)
            else:
                blocks.append([indent, c])
            indent_pre = indent
        N.c = p_indent_stack(blocks, blocks[0][0]).c
    
    elif N.t == "group" and N.C[0].c == 'ã€š':
        raise NotImplementedError
    
    return N

def whitespace_unparser(n, i=0):
    if n.S: return n
    N = n.copy()
    
    if N.t == "BLOCK":
        i += 1
    if N.t in ("BLOCK", "exprs"):
        sep = Node("N", Å„+Å›*4*i)
        N.c = sum(([sep, n] if n.t != "BLOCK" else [n] for n in N.c), [])
        if N.c and N.t == "exprs":
            N.c.pop(0)
    
    N.c = [whitespace_unparser(c, i) for c in N.c]
    return N

sst = lambda x: set(á–µ(á—œ,á´(âµ,âµ‰(á–‡(x,'â‰',Å„),Å„))))
mdt = lambda y: á–±(á´(âµ,âµ‰(x,Å›,1)) for x in sst(y))
inv = lambda z: {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

OPS_BUILTIN = {
    'S': á¦,
    'N': """; â‰ : â‰ ,""",
    'P': """+ â‰ - â‰ * â‰ ~ â‰ **""",
    'B': """+ â‰ - â‰ * â‰ @ â‰ ** â‰ // â‰  < â‰ > â‰ % â‰ .
            & â‰ ^ â‰ | â‰ / â‰ != â‰ == â‰ << â‰ >> """ }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

SWAP_TABLE = mdt("""
    â‹…   * â‰ â‰¡    == â‰ â‰”   := â‰ Ã· / â‰ â‰  != â‰ â‰¤ <=
    â ¤   * â‰ â ¶    ** â‰ â‰¥   >= â‰ Â¯ - â‰ âŒƒ **
    âˆ¨  or â‰ ó°†´   del â‰ â‰…   is â‰ Î© class
    Â¬ not â‰ âŠ¢   def â‰ Â¿   if â‰ â° while
    âˆ§ and â‰ â®‚ yield â‰ â¸˜ elif â‰ â†ª return
    âˆ€ for â‰ â‡¥ break â‰ Â¡ else â‰ â†º continue""")
SWAP_NO = sst("* â‰ **")
merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in rmk(SWAP_TABLE, SWAP_NO).items() if y in z}

kw_pfx_colon = merge_shorthands("""
    if â‰ elif â‰ else â‰ for â‰ while
    try â‰ except â‰ finally â‰ class
    match â‰ case â‰ def â‰ with""")
kw_pfx = merge_shorthands("""
    return â‰ continue â‰ break â‰ pass
    import â‰ global â‰ nonlocal
    raise â‰ assert â‰ del â‰ async""")
kw_inline = merge_shorthands("""
    is â‰ or â‰ and â‰ not â‰ if â‰ elif â‰ else â‰ for â‰ yield""")
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("â„µğ•‹ğ”½Ã®Ï€Ï„â–¡âˆ…âˆá¦")

register("VAR_SPEC", var_spec)
register("KW", kw)
register("KW_PFX", kw_pfx)
register("KW_SPEC", kw_spec)
register("KW_PFX_COLON", kw_pfx_colon)

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« OPERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

;á´º ,á´ºá´¾ó°œ
=á´º â®‚á´¾
â ¤á´¾ó°œ â ¶á´¾ó°œ :á´º
â€1á´µá´® Â¿á´º â¸˜á´º Â¡á´º
â¨³á´®á´¾ó°€’á´º
âŠ»á´®á´ºó°– â‰ âˆ¨á´®á´ºó°œó°€·
âŠ¼á´®á´ºó°– â‰ âˆ§á´®á´ºó°œó°€·
==á´®á´ºó°– !=á´®á´ºó°– â‰œá´®á´ºó°– â‰¡á´®á´ºó°– â‰ á´®á´ºó°– â‰®á´®á´ºó°– <á´®á´ºó°– â‰¤á´®á´ºó°– â‰¥á´®á´ºó°– >á´®á´ºó°– â‰¯á´®á´ºó°– â›
      âˆˆá´®á´ºó°– âˆ‰á´®á´ºó°– âˆŒá´®á´ºó°– âˆ‹á´®á´ºó°– âŠˆá´®á´ºó°– âŠ†á´®á´ºó°– âŠ„á´®á´ºó°– âŠ‚á´®á´ºó°– âŠƒá´®á´ºó°– âŠ…á´®á´ºó°– â›
      âŠ‡á´®á´ºó°– âŠ‰á´®á´ºó°–
á´á´®á´º Å¿á´®á´º Î£á´®á´¾ó°€’á´º Î á´®á´¾ó°€’á´º ó°ˆ²á´®á´¾ó°€’á´º ó°ˆ³á´®á´¾ó°€’á´º
á¹á´®á´º Î¶á´®á´º
|á´®á´ºó°€· â‰ ^á´®á´ºó°€· â‰ &á´®á´ºó°€·
<<á´®á´ºó°€· >>á´®á´ºó°€·
+á´¾á´®á´ºó°€· -á´¾á´®á´ºó°€·
âˆ˜á´®á´º â—‹á´®á´º â‹„á´®á´º
â—„á´®á´º â–ºá´®á´º
âˆªá´®á´º â‰ âˆ©á´®á´º â‰ â¨‰á´®á´º âˆ–á´®á´º
//á´®á´ºó°€· /á´®á´ºó°€· Ã·á´®á´ºó°€·  %á´®á´ºó°€·  @á´®á´¾á´ºó°€·ó°œ *á´®á´ºá´¾ó°€·ó°œ â‹…á´®á´ºó°€· !ó°€’á´º  â›
      â­¥á´¾ó°€’á´º â†¨á´¾ó°€’á´º  â¤‰á´®á´¾ó°€’á´º â¤ˆá´®á´¾ó°€’á´º  ó·¹„á´®á´¾ó°€’á´º  â˜¾á´¾ó°€’á´º ğŸƒŒá´¾ó°€’á´º â›
      á’á´®á´º  ó°›”á´®á´¾ó°€’á´º ó°˜¬á´®á´¾ó°€’á´º â›¶á´¾ó°€’á´º   â‰á´¾ó°€’á´º   á´™á´¾ó°€’á´º â›
      â‹€á´¾ó°€’á´º â‹á´¾ó°€’á´º
Â¬á´¾á´ºó°€· Â¯á´¾ó°€·
â€¦á´® âŒƒá´µá´®ó°€· **á´µá´®á´¾ó°€·ó°œ
.á´µá´®ó°œ

 .ï½œ:=á´µá´®ó°œï½œâ€1
 .ï½œ â‰”á´µá´®ó°œï½œâ€1
  ï½œ  â†á´¾ó°œï½œâ€1
â€1ï½œ  â†’ó°€’ó°œï½œ

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GRAMMAR Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

parser_main = exprs
parser_comment = (str / comment / ~"."s)*

exprs = W? (_expr W?)*
_expr = kw_pfx_colon_expr / kw_pfx_expr / norm_expr

        norm_expr = _norm_expr_atom+
      kw_pfx_expr = _kw_pfx norm_expr
kw_pfx_colon_expr = _kw_pfx_colon __E? expr_not_colon? ':' __E? _expr?

expr_not_colon = (!':' _norm_expr_atom)+

_kw_pfx_colon = (&kw_spec kw_pfx_colon) / (kw_pfx_colon __text_breaker)
_kw_pfx       = (&kw_spec kw_pfx      ) / (kw_pfx       __text_breaker)
_kw           = (&kw_spec kw          ) / (kw           __text_breaker)

_norm_expr_atom = (lamb / _gen_expr_atom) __E?
_gen_expr_atom = group / str / var_spec / oper / _kw / _script / variable_
variable_ = (!W !oper !var_spec !_script ~"[^ğ—®-ğ˜‡â›ğš²â¥Œâ†¦â‘ â‘¡â‘¢â‘£ó°…‚\\\"\\' \\[\\](){}â…â†ã€šã€›âŸ¨âŸ©â€¹â€º]")+

group = ~"[\\[({â…âŸ¨ã€š]" exprs ~"[\\])}â†âŸ©ã€›]"

oper = oper_mod_l oper_lit oper_mod_r
oper_mod_l = ~"[âŸ¥]*"
oper_mod_r = ~"[Â´êœ áµœâŸ¤]*"

_script = supscript / subscript
supscript = ~"[áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–î ‡Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»á´¬á´®ó°€‚á´°á´±ó°€…á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾ó°€á´¿ó°€’áµ€áµâ±½áµ‚ó°€—ó°€˜ó°€™ó°Œó°ó°ó°ó°ó°‘ó°’ó°“â—Œó°”ó°•ó°–ó°—ó°˜ó°™ó°›ó°œó°ó°ó°Ÿó° ó°¡ó°¢ó°£ó°¤â—Œâ—Œó°€¶ó°€·â—Œó°€»ó°ó°ƒó°…ó°ˆó°Šó°‹â°Â¹Â²Â³â´âµâ¶â·â¸â¹â—Œó°±ó°‚‚ó°‚ó°²â—Œêœâºâ»áŸî â¼â½â¾â—Œâ—Œâ—ŒËœ]+"
subscript = ~"[â‚î …î î â‚‘î î ‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™ó°‚¼â‚šî †áµ£â‚›â‚œáµ¤áµ¥î ’â‚“î “î ”ó°‚“ó°‚”ó°‚•ó°‚–ó°‚—ó°‚˜ó°‚™ó°‚šó°‚›ó°‚œó°‚ó°‚ó°‚Ÿó°‚ ó°‚¡ó°‚¢ó°‚£ó°‚¤ó°‚¥ó°‚¦ó°‚§ó°‚¨ó°‚©ó°‚ªó°‚«ó°‚¬ó°ƒ¤ó°ƒ¥ó°ƒ¦ó°ƒ§ó°ƒ¨ó°ƒ©ó°ƒªó°ƒ«â—Œó°ƒ¬ó°ƒ­ó°ƒ®ó°ƒ¯ó°ƒ°ó°ƒ±ó°ƒ³ó°ƒ´ó°ƒµó°ƒ¶ó°ƒ·ó°ƒ¸ó°ƒ¹ó°ƒºó°ƒ»ó°ƒ¼â—Œâ—Œó°ƒó°ƒâ—Œó°ƒ“ó°ƒ™ó°ƒ›ó°ƒó°ƒ ó°ƒ¢ó°ƒ£â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰ï¹•ó°„ó°„Ÿó°„ó°„ï¹–â—Œâ‚Šâ‚‹â¸î ‰â‚Œâ‚â‚ï¹ ï¹©ï¹ªâ—Œ]+"

lamb = lamb_h __E? lamb_b
lamb_h = lamb_h_py / lamb_h_normal / lamb_h_implicit / lamb_h_preset
lamb_b = (exprs 'ó°…‚') / _expr
lamb_h_preset   = ~"[ğš²â‘ â‘¡â‘¢â‘£]"
lamb_h_implicit = variable_ 'â†¦'
lamb_h_normal   = 'â¥Œ' lamb_h_exprs 'â†¦'
lamb_h_py       = "lambda" __text_breaker expr_not_colon? ':'
lamb_h_exprs = W? (_lamb_h_expr W?)+
_lamb_h_expr = (!lamb_h_implicit lamb) / _gen_expr_atom

str = str_cpy / str_py / str_escape / str_spec_char
str_cpy = ('â€¹' (str_escape / str_sub / str_spec_char / str_guts)* 'â€º')
str_sub = 'ã€š' exprs 'ã€›'
str_guts = !str_spec_char ~"[^â›ã€šâ€º]+"
str_escape = ~"â›."
str_spec_char = ~"[ğ—®-ğ˜‡]"
str_py = (('"' (str_py_sub / ~"[^\\\\\"]+")* '"')
       /  ("'" (str_py_sub / ~"[^\\\\\']+")* "'"))
str_py_sub = ~"\\\\."

w = ~"[ \t]+"
W = ~"[ \t\n]+"
__w = w
__text_breaker = __E / &kw_spec / &var_spec / !variable_
__E = __w / __escaped_newline
__escaped_newline = "â›\n"

comment = ~"([î¬¦|#][^\\n]*(\\n|\\Z))|(ğŸŸ‘[^ğŸŸ‘]*(ğŸŸ‘|\\Z))|(Ö[^Ö]*(Ö|\\Z))"s

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GENERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

# Â§ tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

@reduction("supscript", order=-1)
def supscript(n): return [OP.sym_to_node("."), Node("variable_", n.txt)]
@replacement("subscript", recurse_children='A', order=-1)
def subscript(n): return Åƒ("group", '[', parse_as("exprs", n.c), ']')

replacement("parser_main", order=0, recurse_children='A')(whitespace_parser)
@replacement("norm_expr", "expr_not_colon", recurse_children='B', order=0)
def expr_not_colon(n): return n.copy("expr")

OP_NORMER = inv(rmk(SWAP_TABLE, SWAP_NO))
@replacement(*KEYWORD_NODE_NAMES, order=0)
def kw(n): return OP.sym_to_node(h) if (h := OP_NORMER.get(n.txt)) else n
@replacement(*KEYWORD_NODE_NAMES, order=49)
def rep_keyword(n): return n.copy(c=OP_NORMER.get(n.txt, n.txt))

@replacement("expr", recurse_children='B', order=50)
def expr(n): return into_expr(parse_expr(á–µ(lambda x: x.t != 'w', n.C)))

@reduction("op_call", recurse_children='B', order=50.1)
def op_call(n):
    if 'Î»' in op_man[n.C[1]] and \
            n.C[0] != NULL and n.C[2] != NULL:
        return [*n.C[0].C, n.C[1], *n.C[2].C]
    return [n]

@replacement("expr", recurse_children='B', order=50.2)
def expr(n):
    C = á’ª(split_at(n.C,
        lambda x: OP.is_op(x) and 'Î»' in (k:=op_man[x]) and k.B,
        keep_separator=â´³))
    if âµŒ(C) <= 3: return n
    r = â´´
    
    for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
        v = Åƒ("op_call",
            mkexp(*(a if H else [mkvar("tmp")])),
            b,
            mkexp(*(c if T else [mkgxp(("op_call",
                    mkvar("tmp"),
                    OP.sym_to_node('â‰”'),
                    mkgxp(*c)))])))
        r = mkgxp(("op_call", mkexp(r), OP.sym_to_node('âˆ§'), mkexp(v))) if r else v
    return n.copy(c=[r])

# replacement("exprs", order=50.3)(exit)

demodp = lambda o: (o.C[0].txt, o.C[1], o.C[2].txt)

@replacement("op_call", recurse_children='A', order=51)
def op_call(n):
    l, op_, r = n.C
    op = op_man[op_]
    t = fmtop(op.t)
    m_l, op_l, m_r = demodp(op_)
    L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
    
    if 'Ï' in op and not (m_l or m_r):
        match t:
            case 'â†’': return L
            case 'â†': return R
            case ',': return mkexp(   op_l, r)
            case '.': return mkexp(l, op_l, r)
            case 'â‰”': return mkgxp(l, op_l, R)
            case ('Â¬') if R:
                      return mkgxp(op_l, R)
            case ('âˆ¨'|'âˆ§') if L and R:
                      return mkgxp(L, op_l, R)
            case ('@'|'â ¤'|'â ¶'|'*'|'**') if not L and R:
                      return mkexp(op_l, R)
    
    def mkbltnop(op_l): # format builtins if needed
        t = op_l.txt
        if SWAP_TABLE.get(t,t) not in OPS_BUILTIN['A']:
            return op_l
        return mkgxp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
    
    def transform_oper(op_): # apply modifiers to op
        m_l, op_l, m_r = demodp(op_)
        if not (m_l or m_r):
            return op_l
        op_n = mkbltnop(op_l)
        mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
        if 'âŸ¥' in m_l: op_n = mkmod(op_n, "LNULL")
        if 'âŸ¤' in m_r: op_n = mkmod(op_n, "RNULL")
        if 'áµœ' in m_r: op_n = mkmod(op_n, "SWAPA")
        if 'êœ ' in m_r: op_n = mkmod(op_n, "DUPER")
        return op_n
    
    def try_builtin(m, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
        if m_l or m_r:
            return
        t_ = SWAP_TABLE.get(t, t)
        if t_ not in OPS_BUILTIN[m]:
            return
        return mkgxp(*Îµ(L), op_l, *Îµ(R))
    
    op_l = transform_oper(op_)
    COMMA = ("oper_lit", ',')
    
    A = (L, m_l, t, m_r, R)
    if op.S and L and not (op.P or R):
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(L))
    if op.P and R and not (op.S or L):
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(R))
    if op.B and L and R:
        return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA,    R))
    if op.S and L:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA, NULL))
    if op.P and R:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    R))
    return mkbltnop(op_)

@replacement("oper", recurse_children='A', order=52)
def rep_oper(n): return transform_oper(*(x.c for x in n.C)) if 'Â´' in n.C[2].txt else n

@replacement(*KEYWORD_NODE_NAMES, "oper_lit", order=52)
def rep_keyword(n): return n.copy(c=SWAP_TABLE.get(n.txt, n.txt))

replacement("parser_main", order=100, recurse_children='A')(whitespace_unparser)
@reduction("BLOCK", recurse_children='B', order=100)
def BLOCK(n): return n.C
@replacement("expr", recurse_children='B', order=100)
def expr(n): return n.copy(c=JÌ(n.C, Node('w', Å›)))

# Â§ node transpilers
@generator("oper_lit", *KEYWORD_NODE_NAMES)
def gen_oper_lit     (n): return SWAP_TABLE.get(n.txt, n.txt) + Å›
@generator("variable_", "op_spec")
def gen_variable     (n): return py_escape_var(n.txt)

# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt[1:]) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[1]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("str_cpy")
def gen_special_str(n, *, r='"'):
    for c in n.c[1:-1]:
        match c.t:
            case "str_escape"   : r += py_escape_string(c.txt[1:])
            case "str_spec_char": r += py_special_mapper(c.txt)
            case _              : r += gen(c)
    return r + '"'

# lambdas
@generator("lamb")
def gen_lamb(n):
    h, b = n.C
    h = h.C[0]
    if h.t == "lamb_h_preset":
        H = á¦.join(x+',' for x in [*"xyzw"[:"ğš²â‘ â‘¡â‘¢â‘£".index(h.txt)]])
        H = f"{H}*{PY_ARGS},**{PY_KWARGS}"
    elif h.t == "lamb_h_implicit":
        H = f"{h.C[0].txt},*{PY_ARGS},**{PY_KWARGS}"
    elif h.t in ("lamb_h_normal", "lamb_h_py"):
        h = h.C[1]
        expr = split_at(h.C, lambda x: x.txt == ',')
        has_a = has_k = â´´
        for e in expr:
            if not (t := âµ(á’(á¦, (k.txt for k in e)))): continue
            if t[:2] == '**': has_k = â´³
            elif t[0] == '*': has_a = â´³
        
        H = gen(h)
        if has_a and has_k: pass
        elif has_a: H += f',**{PY_KWARGS}'
        elif has_k: H += f',*{PY_ARGS}'
        else      : H += f',*{PY_ARGS},**{PY_KWARGS}'
    else:
        assert â´´
    return f"(lambda {H}: {gen(b.C[0])})"