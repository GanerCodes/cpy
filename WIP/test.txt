î¬¦ Â¿ x+2: yield y+2
î¬¦ if x+2: yield y+2

î¬¦ class Node:
î¬¦     __slots__ = ('t', 'c')
    
î¬¦     t = x Â¿ y > 2 Â¡ z
    
î¬¦     âŠ¢ __init__(ğ•Š, t=á¦, c=á—œ):
î¬¦         ğ•Š.t, ğ•Š.c = t, c or []
    
î¬¦     âŠ¢ __eq__(ğ•Š, n):
î¬¦         if á¹(n, á”):
î¬¦             return ğ•Š.t == n
î¬¦         assert n á¹ Node
î¬¦         return ğ•Š.t == n.t and ğ•Š.c == n.c

î¬¦ # whitespace stuff
calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
î¬¦ def p_indent_stack(S, n=0):
î¬¦     r = []
î¬¦     while S:
î¬¦         indent, *exprs = S[0]
î¬¦         if indent > n:
î¬¦             r.append(p_indent_stack(S, indent))
î¬¦         elif indent < n:
î¬¦             break
î¬¦         else:
î¬¦             S.pop(0)
î¬¦             r.extend(exprs)
î¬¦     return Node("BLOCK", r)

î¬¦ aÎ£b

î¬¦ calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0
î¬¦ âŠ¢ p_indent_stack(S, n=0):
î¬¦     r = []
î¬¦     â° S:
î¬¦         indent, â ¤exprs = Sâ‚€
î¬¦         Â¿ indent > n:
î¬¦             r.append(p_indent_stack(S, indent))
î¬¦         â¸˜ indent < n:
î¬¦             break
î¬¦         Â¡:
î¬¦             S.pop(0)
î¬¦             r.extend(exprs)
î¬¦     â†ª Node("BLOCK", r)
