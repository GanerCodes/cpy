x = 2

î¬¦ â®Œ functools â¨¡ reduce
î¬¦ â®Œ inspect â¨¡ currentframe, getframeinfo
î¬¦ â¨¡ traceback, sys

î¬¦ NULL = object()

î¬¦ LITERAL_OPS_ = {
î¬¦     â›âˆ§: â‘¡xâˆ§y, â›âˆ¨: â‘¡xâˆ¨y,
î¬¦     â›+: â‘¡x+y, â›-: â‘¡x-y,
î¬¦     â›*: â‘¡xâ‹…y, â›/: â‘¡x/y,
î¬¦     â›Â¬: â‘¡ Â¬x,
î¬¦   '//': â‘¡x//y }

î¬¦ ğ‘,ğ‘™ = bool, list
î¬¦ ğ•‹,ğ”½,â–¡ = True, False, None

î¬¦ ğ• = â‘ [*ğ”¸]Â¿xâ‰…NULLÂ¡[x]
î¬¦ ó°ˆ² = â‘ ğ‘™(filter(*ğ•(*ğ”¸,â–¡),x))
î¬¦ ğ•£ = â‘ xó°ˆ²â‘ xâ‰‡NULL

î¬¦ á¹ = isinstance
î¬¦ â˜¾ = ğš²print(â ¤ğ”¸,â ¶ğ•‚)âˆ¨ğ”¸â‚€
î¬¦ â­¥ = â‘ ğ‘™(range(x))
î¬¦ â€¦ = â‘¡ğ‘™(range(x,y))
î¬¦ Å¿ = â‘¡reduce(y,x,â ¤ğ•£(ğ”¸))
î¬¦ Î  = â‘ Å¿Â´(x,â‹…,â ¤ğ•£(ğ”¸))
î¬¦ á´ = â‘¡ğ‘™(map(y,x))
î¬¦ âˆˆ = â‘¡x in y
î¬¦ âˆ‹ = â‘¡y âˆˆ x
î¬¦ â¨ = â‘¡ğ‘(x) â‰¡ ğ‘(y)
î¬¦ âŠ» = â‘¡ğ‘(x) ^ ğ‘(y)  âˆ§â†xâˆ¨y
î¬¦ âŠ¼ = â‘¡ğ‘(x) âˆ§ ğ‘(y)â†’Â¬âˆ§â†xâˆ¨y
î¬¦ â›¶ = â‘ [x]
î¬¦ ! = â‘ 1â€¦â†x+1â†’Î 1
î¬¦ â‹„ = â‘¡(xÂ¿xá¹ğ‘™Â¡â›¶xâ†’+[y])

î¬¦ 10!â˜¾
î¬¦ 3>2>1 â¨ 1<2<3 â†’ â˜¾
î¬¦ 0 âŠ» 1 âŠ» 0 â†’ â˜¾
î¬¦ 1 âŠ» 0 âŠ» 1 â†’ â˜¾
î¬¦ 1 âŠ» 1 âŠ» 1 â†’ â˜¾
î¬¦ 0 âŠ» 0 âŠ» 0 â†’ â˜¾

î¬¦ [x for x in â­¥10]
î¬¦ [x âˆ€ x in â­¥10]

î¬¦ â†‘ header stuff

î¬¦ from traceback_with_variables import activate_by_import
î¬¦ print(ğ•£([1]))
    

î¬¦ {1,2}âˆ‹1âˆˆ{3,2} â˜¾
î¬¦ {1,2}âˆ‹1âˆˆ{3,2}
î¬¦ def op_call(n):
î¬¦     l, op_, r = n.C
î¬¦     op = op_man[op_]
î¬¦     t = KEYWORDS_TO_CPY.get(op.t, op.t)
î¬¦     m_l, op_l, m_r = demodp(op_)
î¬¦     L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
    
î¬¦     if 'Ï' in op and not (m_l or m_r):
î¬¦         match t:
î¬¦             case 'â†’': return L
î¬¦             case 'â†': return R
î¬¦             case 'â‰”': return mkgxp(l, op_l, R)
î¬¦             case '.'|'âˆ€': return mkexp(l, op_l, r)
î¬¦             case ':'|'Â¿'|'â¸˜'|'Â¡':
î¬¦                       return mkexp(op_l, r)
î¬¦             case ','|'â®‚'|'â†º'|'â‡¥'|'â†ª':
î¬¦                       return mkexp(op_l, r)
î¬¦             case ('Â¬') if R:
î¬¦                       return mkgxp(op_l, R)
î¬¦             case ('âˆ¨'|'âˆ§') if L and R:
î¬¦                       return mkgxp(L, op_l, R)
î¬¦             case ('@') if not L and R:
î¬¦                       return mkexp(op_l, R)
î¬¦             case ('â ¤'|'â ¶'|'*'|'**') if not L and R:
î¬¦                       return mkexp(op_l, r)
    
î¬¦     op_l = transform_oper(op_)
î¬¦     COMMA = ("oper_lit", ',')
    
î¬¦     A = (op_l, L, m_l, t, m_r, R)
î¬¦     if op.S and L and not op.B:
î¬¦         return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(L))
î¬¦     if op.P and R and not op.B:
î¬¦         return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(R))
î¬¦     if op.B and L and R:
î¬¦         return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA,    R))
î¬¦     if op.S and L:
î¬¦         return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA, NULL))
î¬¦     if op.P and R:
î¬¦         return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    R))
î¬¦     return mkbltnop(op_)
î¬¦ replacement("op_call", recurse_children='B', order=(53, "Refactor op calls"))(op_call)

î¬¦ # lambdas
î¬¦ @generator("lamb")
î¬¦ def gen_lamb(n):
î¬¦     h, b = n.C
î¬¦     h = h.C[0]
î¬¦     if h.t == "lamb_h_preset":
î¬¦         H = á¦.join(x+',' for x in [*"xyzw"[:"ğš²â‘ â‘¡â‘¢â‘£".index(h.txt)]])
î¬¦         H = f"{H}*{PY_ARGS},**{PY_KWARGS}"
î¬¦     elif h.t == "lamb_h_implicit":
î¬¦         H = f"{h.C[0].txt},*{PY_ARGS},**{PY_KWARGS}"
î¬¦     elif h.t in ("lamb_h_normal", "lamb_h_py"):
î¬¦         h = h.C[1]
î¬¦         expr = split_at(h.C, lambda x: x.txt == ',')
î¬¦         has_a = has_k = â´´
î¬¦         for e in expr:
î¬¦             if not (t := âµ(á’(á¦, (k.txt for k in e)))): continue
î¬¦             if t[:2] == '**': has_k = â´³
î¬¦             elif t[0] == '*': has_a = â´³
        
î¬¦         H = gen(h)
î¬¦         if has_a and has_k: pass
î¬¦         elif has_a: H += f',**{PY_KWARGS}'
î¬¦         elif has_k: H += f',*{PY_ARGS}'
î¬¦         else      : H += f',*{PY_ARGS},**{PY_KWARGS}'
î¬¦     else:
î¬¦         assert â´´
î¬¦     return f"(lambda {H}:{gen(b.C[0])})"

î¬¦ î¬¦ â‘ â˜¾xâ˜¾ó°…‚á´'hello'



î¬¦ î¬¦ î¬¦ 1âˆˆ{2,3}â†’â˜¾
î¬¦ î¬¦ î¬¦ â˜¾â†’â˜¾

î¬¦ î¬¦ ğŸŸ‘ğŸŸ‘ğŸŸ‘
î¬¦ î¬¦ x âˆˆ Y âŠ‚ z
î¬¦ î¬¦ (x âˆˆ Y) âˆ§ (Y âŠ‚ z)
î¬¦ î¬¦ âŠ»(a âˆ§ b, c âˆˆ D)
î¬¦ î¬¦ aâˆ¨b âŠ» câˆ¨d ; aâˆ¨b âŠ» câˆ¨d
î¬¦ î¬¦ aâˆ¨b âŠ» c âŠ» d
î¬¦ î¬¦ (aâˆ¨b)âŠ»(_:=c) âˆ§ (_âŠ»d)
î¬¦ î¬¦ âŠ»(aâˆ¨b,_:=c) âˆ§ âŠ»(_,d)

î¬¦ î¬¦ a âŠ» câˆ§(câŠ»d)

î¬¦ î¬¦ â€¹d"dâ€º

î¬¦ î¬¦ egg = â€¹che"eseã€š2+aáµ‡ã€›â€º

î¬¦ î¬¦ a âˆ§ b âŠ» c
î¬¦ î¬¦ aâŠ»bâŠ»c
î¬¦ î¬¦ aâŠ»(bâˆ¨c)
î¬¦ î¬¦ a âˆ§ b âŠ» c âˆˆ D
î¬¦ î¬¦ class AbsoluteWrapper:
î¬¦ î¬¦     def __init__(ğ•Š, *a, **k):
î¬¦ î¬¦         (ğ•Š.f, *ğ•Š.a), ğ•Š.k = a, k
î¬¦ î¬¦     def __call__(ğ•Š, *a, **k):
î¬¦ î¬¦         return type(ğ•Š)(ğ•Š.f, *a, **k)


î¬¦ î¬¦ x âˆˆ Y âŠ‚ z
î¬¦ î¬¦ (x âˆˆ Y) âˆ§ (Y âŠ‚ z)
î¬¦ î¬¦ âŠ»(a âˆ§ b, c âˆˆ D)
î¬¦ î¬¦ aâˆ¨b âŠ» câˆ¨d ; aâˆ¨b âŠ» câˆ¨d
î¬¦ î¬¦ aâˆ¨b âŠ» c âŠ» d
î¬¦ î¬¦ (aâˆ¨b)âŠ»(_:=c) âˆ§ (_âŠ»d)
î¬¦ î¬¦ âŠ»(aâˆ¨b,_:=c) âˆ§ âŠ»(_,d)

î¬¦ î¬¦ class Node:
î¬¦ î¬¦     __slots__ = ('t', 'c')
î¬¦ î¬¦     t = x Â¿ y > 2 Â¡ z
î¬¦ î¬¦     âŠ¢ __init__(ğ•Š, t=á¦, c=á—œ):
î¬¦ î¬¦         ğ•Š.t, ğ•Š.c = t, c or []
î¬¦ î¬¦     âŠ¢ __eq__(ğ•Š, n):
î¬¦ î¬¦         if á¹(n, á”):
î¬¦ î¬¦             return ğ•Š.t == n
î¬¦ î¬¦         assert n á¹ Node
î¬¦ î¬¦         â†ª ğ•Š.t == n.t and ğ•Š.c == n.c

î¬¦ î¬¦ calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0
î¬¦ î¬¦ calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0

î¬¦ î¬¦ (a, *b, â ¤c, **d, â ¶e)
î¬¦ î¬¦ a<b+2<c
î¬¦ î¬¦ 1<aâˆˆb
î¬¦ î¬¦ +
î¬¦ î¬¦ <
î¬¦ î¬¦ <êœ 
î¬¦ î¬¦ î¬¦ a + 2â‹…b + c

î¬¦ î¬¦ â¨³a<b<câ¨³

î¬¦ î¬¦ z < b < c
î¬¦ î¬¦ a < b
î¬¦ î¬¦ b < c

î¬¦ î¬¦ aâ‹…b+câ‹…d

î¬¦ î¬¦ 2+(aâˆ¨b)
î¬¦ î¬¦ a âŠ» bâˆ¨c âŠ» d

î¬¦ î¬¦ 2+êœ 

î¬¦ î¬¦ á´êœ 
î¬¦ î¬¦ á´êœ  x
î¬¦ î¬¦ a á´áµœ b

î¬¦ î¬¦ 2+2
î¬¦ î¬¦ +êœ 

î¬¦ î¬¦ 10â­¥á´â­¥êœ Â´


î¬¦ î¬¦ calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
î¬¦ î¬¦ î¬¦ â­¥10á´â‘ xâ‹…xó°…‚â†’Î¶â›aâ‹…10â†’+â†2
î¬¦ î¬¦ aÎ£b
î¬¦ î¬¦ a
î¬¦ î¬¦     b
î¬¦ î¬¦         c
î¬¦ î¬¦ d
î¬¦ î¬¦     e
î¬¦ î¬¦         f
î¬¦ î¬¦     g
î¬¦ î¬¦ h
î¬¦ î¬¦ if x+2: yield y+2
î¬¦ î¬¦ Â¿ x+2: yield y+2

î¬¦ î¬¦ Â¿ 2: â˜¾ 1
î¬¦ î¬¦ h = aÂ¿bÂ¡c

î¬¦ î¬¦ î¬¦ def p_indent_stack(S, n=0):
î¬¦ î¬¦ î¬¦     r = []
î¬¦ î¬¦ î¬¦     while S:
î¬¦ î¬¦ î¬¦         indent, *exprs = S[0]
î¬¦ î¬¦ î¬¦         if indent > n:
î¬¦ î¬¦ î¬¦             r.append(p_indent_stack(S, indent))
î¬¦ î¬¦ î¬¦         elif indent < n:
î¬¦ î¬¦ î¬¦             break
î¬¦ î¬¦ î¬¦         else:
î¬¦ î¬¦ î¬¦             S.pop(0)
î¬¦ î¬¦ î¬¦             r.extend(exprs)
î¬¦ î¬¦ î¬¦     return Node("BLOCK", r)

î¬¦ î¬¦ î¬¦ âŠ¢ p_indent_stack(S, n=0):
î¬¦ î¬¦ î¬¦     r = []
î¬¦ î¬¦ î¬¦     â° S:
î¬¦ î¬¦ î¬¦         indent, â ¤exprs = Sâ‚€
î¬¦ î¬¦ î¬¦         Â¿ indent > n:
î¬¦ î¬¦ î¬¦             r.append(p_indent_stack(S, indent))
î¬¦ î¬¦ î¬¦         â¸˜ indent < n:
î¬¦ î¬¦ î¬¦             break
î¬¦ î¬¦ î¬¦         Â¡:
î¬¦ î¬¦ î¬¦             S.pop(0)
î¬¦ î¬¦ î¬¦             r.extend(exprs)
î¬¦ î¬¦ î¬¦     â†ª Node("BLOCK", r)
