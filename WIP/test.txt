def op_call(n):
    l, op_, r = n.C
    op = op_man[op_]
    t = KEYWORDS_TO_CPY.get(op.t, op.t)
    m_l, op_l, m_r = demodp(op_)
    L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
    
    if 'Ï' in op and not (m_l or m_r):
        match t:
            case 'â†’': return L
            case 'â†': return R
            case '.': return mkexp(l, op_l, r)
            case 'â‰”': return mkgxp(l, op_l, R)
            case ':'|'Â¿'|'â¸˜'|'Â¡':
                      return mkexp(op_l, r)
            case ','|'â®‚'|'â†º'|'â‡¥'|'â†ª':
                      return mkexp(op_l, r)
            case ('Â¬') if R:
                      return mkgxp(op_l, R)
            case ('âˆ¨'|'âˆ§') if L and R:
                      return mkgxp(L, op_l, R)
            case ('@') if not L and R:
                      return mkexp(op_l, R)
            case ('â ¤'|'â ¶'|'*'|'**') if not L and R:
                      return mkexp(op_l, r)
    
    op_l = transform_oper(op_)
    COMMA = ("oper_lit", ',')
    
    A = (op_l, L, m_l, t, m_r, R)
    if op.S and L and not op.B:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(L))
    if op.P and R and not op.B:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(R))
    if op.B and L and R:
        return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA,    R))
    if op.S and L:
        return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   L, COMMA, NULL))
    if op.P and R:
        return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    R))
    return mkbltnop(op_)
replacement("op_call", recurse_children='B', order=(53, "Refactor op calls"))(op_call)

î¬¦ î¬¦ ğ‘,ğ‘™ = bool, list
î¬¦ î¬¦ ğ•‹,ğ”½ = True, False
î¬¦ î¬¦ á¹ = isinstance
î¬¦ î¬¦ â˜¾ = ğš²print(â ¤ğ”¸,â ¶ğ•‚)âˆ¨ğ”¸â‚€
î¬¦ î¬¦ á´ = ğš²ğ‘™(map(â ¤ğ”¸,â ¶ğ•‚))
î¬¦ î¬¦ âˆˆ = â‘¡x in y
î¬¦ î¬¦ âŠ» = â‘¡ğ‘(x) ^ ğ‘(y)
î¬¦ î¬¦ âŠ¼ = â‘¡Â¬(ğ‘(x) âˆ§ ğ‘(y))
î¬¦ î¬¦ â›¶ = â‘ [x]

î¬¦ î¬¦ â‹„ = â‘¡(xÂ¿xá¹ğ‘™Â¡â›¶xâ†’+[y])
î¬¦ î¬¦ LITERAL_OPS_ = {
î¬¦ î¬¦     â›âˆ§: â‘ xâˆ§y, â›âˆ¨: â‘ xâˆ¨y,
î¬¦ î¬¦     â›+: â‘ x+y, â›-: â‘ x+y,
î¬¦ î¬¦     â›*: â‘ x+y, â›/: â‘ x/y,
î¬¦ î¬¦     â›Â¬: â‘  Â¬x,
î¬¦ î¬¦     '//': â‘ x//y }

î¬¦ î¬¦ î¬¦ â†‘ header stuff

î¬¦ â‘ â˜¾xâ˜¾ó°…‚á´'hello'



î¬¦ î¬¦ 1âˆˆ{2,3}â†’â˜¾
î¬¦ î¬¦ â˜¾â†’â˜¾

î¬¦ ğŸŸ‘ğŸŸ‘ğŸŸ‘
î¬¦ x âˆˆ Y âŠ‚ z
î¬¦ (x âˆˆ Y) âˆ§ (Y âŠ‚ z)
î¬¦ âŠ»(a âˆ§ b, c âˆˆ D)
î¬¦ aâˆ¨b âŠ» câˆ¨d ; aâˆ¨b âŠ» câˆ¨d
î¬¦ aâˆ¨b âŠ» c âŠ» d
î¬¦ (aâˆ¨b)âŠ»(_:=c) âˆ§ (_âŠ»d)
î¬¦ âŠ»(aâˆ¨b,_:=c) âˆ§ âŠ»(_,d)

î¬¦ a âŠ» câˆ§(câŠ»d)

î¬¦ â€¹d"dâ€º

î¬¦ egg = â€¹che"eseã€š2+aáµ‡ã€›â€º

î¬¦ a âˆ§ b âŠ» c
î¬¦ aâŠ»bâŠ»c
î¬¦ aâŠ»(bâˆ¨c)
î¬¦ a âˆ§ b âŠ» c âˆˆ D
î¬¦ class AbsoluteWrapper:
î¬¦     def __init__(ğ•Š, *a, **k):
î¬¦         (ğ•Š.f, *ğ•Š.a), ğ•Š.k = a, k
î¬¦     def __call__(ğ•Š, *a, **k):
î¬¦         return type(ğ•Š)(ğ•Š.f, *a, **k)


î¬¦ x âˆˆ Y âŠ‚ z
î¬¦ (x âˆˆ Y) âˆ§ (Y âŠ‚ z)
î¬¦ âŠ»(a âˆ§ b, c âˆˆ D)
î¬¦ aâˆ¨b âŠ» câˆ¨d ; aâˆ¨b âŠ» câˆ¨d
î¬¦ aâˆ¨b âŠ» c âŠ» d
î¬¦ (aâˆ¨b)âŠ»(_:=c) âˆ§ (_âŠ»d)
î¬¦ âŠ»(aâˆ¨b,_:=c) âˆ§ âŠ»(_,d)

î¬¦ class Node:
î¬¦     __slots__ = ('t', 'c')
î¬¦     t = x Â¿ y > 2 Â¡ z
î¬¦     âŠ¢ __init__(ğ•Š, t=á¦, c=á—œ):
î¬¦         ğ•Š.t, ğ•Š.c = t, c or []
î¬¦     âŠ¢ __eq__(ğ•Š, n):
î¬¦         if á¹(n, á”):
î¬¦             return ğ•Š.t == n
î¬¦         assert n á¹ Node
î¬¦         â†ª ğ•Š.t == n.t and ğ•Š.c == n.c

î¬¦ calc_indent = â¥Œn â†¦ náµ— â‰¡ â›W âˆ§ n.c.split('\n')â‚‹â‚.count(' ') // 4 âˆ¨ 0
î¬¦ calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0

î¬¦ (a, *b, â ¤c, **d, â ¶e)
î¬¦ a<b+2<c
î¬¦ 1<aâˆˆb
î¬¦ +
î¬¦ <
î¬¦ <êœ 
î¬¦ î¬¦ a + 2â‹…b + c

î¬¦ â¨³a<b<câ¨³

î¬¦ z < b < c
î¬¦ a < b
î¬¦ b < c

î¬¦ aâ‹…b+câ‹…d

î¬¦ 2+(aâˆ¨b)
î¬¦ a âŠ» bâˆ¨c âŠ» d

î¬¦ 2+êœ 

î¬¦ á´êœ 
î¬¦ á´êœ  x
î¬¦ a á´áµœ b

î¬¦ 2+2
î¬¦ +êœ 

î¬¦ 10â­¥á´â­¥êœ Â´


î¬¦ calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
î¬¦ î¬¦ â­¥10á´â‘ xâ‹…xó°…‚â†’Î¶â›aâ‹…10â†’+â†2
î¬¦ aÎ£b
î¬¦ a
î¬¦     b
î¬¦         c
î¬¦ d
î¬¦     e
î¬¦         f
î¬¦     g
î¬¦ h
î¬¦ if x+2: yield y+2
î¬¦ Â¿ x+2: yield y+2

î¬¦ Â¿ 2: â˜¾ 1
î¬¦ h = aÂ¿bÂ¡c

î¬¦ î¬¦ def p_indent_stack(S, n=0):
î¬¦ î¬¦     r = []
î¬¦ î¬¦     while S:
î¬¦ î¬¦         indent, *exprs = S[0]
î¬¦ î¬¦         if indent > n:
î¬¦ î¬¦             r.append(p_indent_stack(S, indent))
î¬¦ î¬¦         elif indent < n:
î¬¦ î¬¦             break
î¬¦ î¬¦         else:
î¬¦ î¬¦             S.pop(0)
î¬¦ î¬¦             r.extend(exprs)
î¬¦ î¬¦     return Node("BLOCK", r)

î¬¦ î¬¦ âŠ¢ p_indent_stack(S, n=0):
î¬¦ î¬¦     r = []
î¬¦ î¬¦     â° S:
î¬¦ î¬¦         indent, â ¤exprs = Sâ‚€
î¬¦ î¬¦         Â¿ indent > n:
î¬¦ î¬¦             r.append(p_indent_stack(S, indent))
î¬¦ î¬¦         â¸˜ indent < n:
î¬¦ î¬¦             break
î¬¦ î¬¦         Â¡:
î¬¦ î¬¦             S.pop(0)
î¬¦ î¬¦             r.extend(exprs)
î¬¦ î¬¦     â†ª Node("BLOCK", r)
