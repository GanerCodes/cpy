calc_indent = ⥌n ↦ nᵗ ≡ ␛W ∧ n.c.split('\n')₋₁.count(' ') // 4 ∨ 0
calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0

(a, *b, ⠤c, **d, ⠶e)
a<b+2<c
1<a∈b
+
<
<꜠
 a + 2⋅b + c
🟑🟑🟑
⨳a<b<c⨳

a < b < c
a < b
b < c

a⋅b+c⋅d

2+(a∨b)
a ⊻ b∨c ⊻ d

2+꜠

ᴍ꜠
ᴍ꜠ x
a ᴍᵜ b

2+2
+꜠

10⭥ᴍ⭥꜠´


calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
 ⭥10ᴍ①x⋅x󰅂→ζ␛a⋅10→+←2
aΣb
a
    b
        c
d
    e
        f
    g
h
if x+2: yield y+2
¿ x+2: yield y+2

¿ 2: ☾ 1
h = a¿b¡c

class Node:
    __slots__ = ('t', 'c')
    t = x ¿ y > 2 ¡ z
    ⊢ __init__(𝕊, t=ᐦ, c=ᗜ):
        𝕊.t, 𝕊.c = t, c or []
    ⊢ __eq__(𝕊, n):
        if ᐹ(n, ᔐ):
            return 𝕊.t == n
        assert n ᐹ Node
        ↪ 𝕊.t == n.t and 𝕊.c == n.c

class AbsoluteWrapper:
    def __init__(𝕊, *a, **k):
        (𝕊.f, *𝕊.a), 𝕊.k = a, k
    def __call__(𝕊, *a, **k):
        if len(a) == 1 and callable(a[0]):
            return 𝕊.f(a[0], *𝕊.a, **𝕊.k)
        return type(𝕊)(𝕊.f, *a, **k)

 def p_indent_stack(S, n=0):
     r = []
     while S:
         indent, *exprs = S[0]
         if indent > n:
             r.append(p_indent_stack(S, indent))
         elif indent < n:
             break
         else:
             S.pop(0)
             r.extend(exprs)
     return Node("BLOCK", r)

 ⊢ p_indent_stack(S, n=0):
     r = []
     ➰ S:
         indent, ⠤exprs = S₀
         ¿ indent > n:
             r.append(p_indent_stack(S, indent))
         ⸘ indent < n:
             break
         ¡:
             S.pop(0)
             r.extend(exprs)
     ↪ Node("BLOCK", r)
