 ¿ x+2: yield y+2
 if x+2: yield y+2

 class Node:
     __slots__ = ('t', 'c')
    
     t = x ¿ y > 2 ¡ z
    
     ⊢ __init__(𝕊, t=ᐦ, c=ᗜ):
         𝕊.t, 𝕊.c = t, c or []
    
     ⊢ __eq__(𝕊, n):
         if ᐹ(n, ᔐ):
             return 𝕊.t == n
         assert n ᐹ Node
         return 𝕊.t == n.t and 𝕊.c == n.c

 # whitespace stuff
calc_indent = lambda n: n.t == "W" and n.c.split('\n')[-1].count(' ') // 4 or 0
 def p_indent_stack(S, n=0):
     r = []
     while S:
         indent, *exprs = S[0]
         if indent > n:
             r.append(p_indent_stack(S, indent))
         elif indent < n:
             break
         else:
             S.pop(0)
             r.extend(exprs)
     return Node("BLOCK", r)

 aΣb

 calc_indent = ⥌n ↦ nᵗ ≡ ␛W ∧ n.c.split('\n')₋₁.count(' ') // 4 ∨ 0
 ⊢ p_indent_stack(S, n=0):
     r = []
     ➰ S:
         indent, ⠤exprs = S₀
         ¿ indent > n:
             r.append(p_indent_stack(S, indent))
         ⸘ indent < n:
             break
         ¡:
             S.pop(0)
             r.extend(exprs)
     ↪ Node("BLOCK", r)
