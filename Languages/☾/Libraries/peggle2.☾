󰋺(␛𝐍, *)
⨡ regex as re
⮌ pickle ⨡ loads, dumps

show_cache_table = ⥌𝑅,ℭ↦↨ℭꟿ⥌i,v↦ℵ(v)󰒼→ꟿ󰲣☾‹⟦i⟧,⟦x⟧𝘁⟦𝑅ₓ⟧𝘁⟦y⟧›

⮌ time ⨡ time
𝓽_ = □
⊢ 𝓣(s=ᐦ):
     ↪  󰤱
    global 𝓽_
    ¿𝓽_≅□:
        ‹Starting timer›☾
        𝓽_ = time
        ↪
    ‹⟦s⟧ took ⟦time-𝓽_⟧s›☾
    𝓽_ = □

🟑⊢ parse(𝐷, 𝑅, start_rule=□):
    ℭ, χ = 𝐷🃌+1→⭥ᴍ󰲡{}, 0
    𝓢 = [(□, 𝑅🃌-1 ¿start_rule≅□¡ start_rule)]
    χ = 0
    ➰𝓢:
        Χ, ι = 𝓢.pop(¯1)
        ¿Χ≇□: χ=Χ
        Γ = χ, ι
        γ, ⠤𝐶 = 𝑅󰃬
        𝔠 = ℭ󰃺
        match γ:
            case ␛ᔐ:
                ¿𝐶₀≡𝐷󰃺﹕􊸴􊮝󰃺₊􊳵􊬣􊹳: 𝔠󰃬 = ✓, 𝝌
                ¡             : 𝔠󰃬 = ✗, χ
            case ␛~:
                ¿m≔𝐶₀.match(𝐷, χ):
                    𝔠󰃬 = ✓, χ + m.group(0)🃌, m
                ¡:  𝔠󰃬 = ✗, χ
            case ␛∧:
                n, 𝝌 = 𝔠󰃬 ¿ι∈𝔠¡ (0, χ)
                ➰✓:
                    ¿𝜾≔𝐶ₙ →∉← 𝑐≔ℭ􊸴:
                        𝓢.extend([Γ, (𝝌, 𝜾)])
                        𝔠󰃬 = n, 𝝌 ; ⇥
                    𝑔, 𝝌 = ℭ􊸴 􊸧 ﹕₂
                    n += 1
                    ¿    𝑔¬: 𝔠󰃬 = ✗, χ ; ⇥
                    ¿n ≡ 𝐶🃌: 𝔠󰃬 = ✓, 𝝌 ; ⇥
            case ␛∨:
                n = 𝔠󰃬 ¿ι∈𝔠¡ 0
                ➰✓:
                    ¿𝜾≔𝐶ₙ →∉← 𝑐≔ℭ󰃺:
                        𝓢.extend([Γ, (χ, 𝜾)])
                        𝔠󰃬 = n ; ⇥
                    𝑔, 𝝌 = ℭ󰃺 􊸧 ﹕₂
                    ¿    𝑔 : 𝔠󰃬 = ✓, 𝝌, n ; ⇥
                    n += 1
                    ¿n ≡ 𝐶🃌: 𝔠󰃬 = ✗, χ    ; ⇥
            case ␛*|␛+:
                c = 𝔠.setdefault(ι, [χ])
                𝜾, 𝝌 = 𝐶₀, c₋₁
                ➰✓:
                    ¿𝜾 →∉← 𝑐≔ℭ􊸴:
                        𝓢.extend([Γ, (𝝌, 𝜾)])
                        ⇥
                    𝑔, Χ = ℭ􊸴 􊸧 ﹕₂
                    ¿¬𝑔:
                        ¿γ≡␛* ∨ c🃌>1:
                            𝔠󰃬 = ✓, 𝝌, c﹕₋₁
                        ¡:
                            𝔠󰃬 = ✗, χ
                        ⇥
                    c.append(𝝌≔Χ)
            case ␛✓: 𝔠󰃬 = ✓, χ
            case ␛✗: ✗⨳‹Hit an ✗›
            case ␛←:
                ¿𝐶₁∉𝔠:
                    𝓢.extend([Γ, (χ, 𝐶₁)])
                ¡:
                    𝑔, 𝝌 = 𝔠􊳵􊬤 ﹕₂
                    𝔠󰃬 = 𝑔, 𝝌, 𝐶₁
            case _:
                ¿𝐶₀∉𝔠:
                    𝓢.extend([Γ, (χ, 𝐶₀)])
                ¡:
                    𝑔, 𝝌 = 𝔠􊳵􊬣 ﹕₂
                    match γ:
                        case ␛⮞: 𝔠󰃬 = 𝑔 , χ
                        case ␛¬: 𝔠󰃬 = 𝑔¬, χ
                        case ␛❗: 𝔠󰃬 = 𝑔⨳, 𝝌
                        case ␛?: 𝔠󰃬 = ✓ , 𝝌, 𝑔
                        case  _: 𝔠󰃬 = 𝑔 , 𝝌
    ↪ ℭ🟑

 Optimized version
⊢ parse(𝐷, 𝑅, start_rule=□):
    ℭ, χ = 𝐷🃌+1→⭥ᴍ󰲡{}, 0
    𝓢 = [(None, 𝑅🃌-1 ¿start_rule≅None¡ start_rule)]
    χ = 0
    ➰𝓢:
        Χ, ι = 𝓢.pop(¯1)
        ¿Χ is not None: χ=Χ
        γ, ⠤𝐶 = 𝑅󰃬
        𝔠 = ℭ󰃺
        match γ:
            case ␛ᔐ:
                ¿𝐶₀≡𝐷󰃺﹕􊸴􊮝󰃺₊ₗₑₙ₍􊳵􊬣₎: 𝔠󰃬 = ✓, 𝝌
                ¡                 : 𝔠󰃬 = ✗, χ
            case ␛~:
                ¿m≔𝐶₀.match(𝐷, χ):
                    𝔠󰃬 = ✓, m.span()[1], m
                ¡:  𝔠󰃬 = ✗, χ
            case ␛∧:
                n, 𝝌 = 𝔠󰃬 ¿ι∈𝔠¡ (0, χ)
                ➰✓:
                    𝜾, 𝑐 = 𝐶ₙ, ℭ􊸴
                    ¿𝜾 not in 𝑐:
                        𝓢.extend([(χ, ι), (𝝌, 𝜾)])
                        𝔠󰃬 = n, 𝝌 ; ⇥
                    𝑔, 𝝌 = ℭ􊸴 􊸧 ﹕₂
                    n += 1
                    ¿    not 𝑔 : 𝔠󰃬 = ✗, χ ; ⇥
                    ¿n ≡ len(𝐶): 𝔠󰃬 = ✓, 𝝌 ; ⇥
            case ␛∨:
                n = 𝔠󰃬 ¿ι∈𝔠¡ 0
                ➰✓:
                    𝜾, 𝑐 = 𝐶ₙ, ℭ󰃺
                    ¿𝜾 not in 𝑐:
                        𝓢.extend([(χ, ι), (χ, 𝜾)])
                        𝔠󰃬 = n ; ⇥
                    𝑔, 𝝌 = ℭ󰃺 􊸧 ﹕₂
                    ¿𝑔: 𝔠󰃬 = ✓, 𝝌, n ; ⇥
                    n += 1
                    ¿n ≡ len(𝐶): 𝔠󰃬 = ✗, χ ; ⇥
            case ␛*|␛+:
                ¿ι∈𝔠: c = 𝔠󰃬
                ¡   : c = 𝔠󰃬 = [χ]
                𝜾, 𝝌 = 𝐶₀, c₋₁
                ➰✓:
                    𝑐 = ℭ􊸴
                    ¿𝜾 not in 𝑐:
                        𝓢.extend([(χ, ι), (𝝌, 𝜾)])
                        ⇥
                    𝑔, Χ = 𝑐􊸧 ﹕₂
                    ¿¬𝑔:
                        ¿γ≡␛* ∨ len(c)>1:
                            𝔠󰃬 = ✓, 𝝌, c﹕₋₁
                        ¡:
                            𝔠󰃬 = ✗, χ
                        ⇥
                    c.append(𝝌≔Χ)
            case ␛✓: 𝔠󰃬 = ✓, χ
            case ␛✗: assert ✗, ⨳‹Hit an ✗›
            case ␛←:
                ¿𝐶₁∉𝔠:
                    𝓢.extend([(χ, ι), (χ, 𝐶₁)])
                ¡:
                    𝑔, 𝝌 = 𝔠􊳵􊬤 ﹕₂
                    𝔠󰃬 = 𝑔, 𝝌, 𝐶₁
            case _:
                ¿𝐶₀∉𝔠:
                    𝓢.extend([(χ, ι), (χ, 𝐶₀)])
                ¡:
                    𝑔, 𝝌 = 𝔠􊳵􊬣 ﹕₂
                    match γ:
                        case ␛⮞: 𝔠󰃬 =     𝑔, χ
                        case ␛¬: 𝔠󰃬 = not 𝑔, χ
                        case ␛❗:
                            assert 𝑔
                            𝔠󰃬 = 𝑔, 𝝌
                        case ␛?: 𝔠󰃬 = ✓, 𝝌, 𝑔
                        case  _: 𝔠󰃬 = 𝑔, 𝝌
    ↪ ℭ

⊢ make_rules(r):
     󰤱 add option to skip jumping to declarations
    nmp = ℵ(r⁻ζr⭥)
    r = r ꟿᴷ 󰲣␛_+x
    𝐂 = ℵ(r⁻ζ𝐑≔r⁻ ᴍ ⛶ᵀ)
    ⊢ 𝕊(r):
        ¿r🃌≡1 ∧ r₀ ₀≡␛_: ↪(r₀, )
        ¿r∈𝐂: ↪ 𝐂ᵣ
        ¿r₀ᐹ𝑖: r = (𝐑􊵬􊮝ᵣ􊬣 ₀, ⠤r₁﹕)
        ¡    : 𝐑.append(𝔦≔𝐑🃌)
        ¿r₀  ≡␛←  : r = (r₀, r₁, 𝕊(r₂))
        ⸘r₀  ∈␛✓␛✗: r = (r₀, 𝔦)
        ⸘r₀  ∉␛ᔐ␛~: r = (r₀, ⠤r₁﹕ ᴍ 𝕊)
         𝐑􊳁􊬁􊮝􊵬≔r  BROKEN 󰤱 FIX ☾
        𝐑􊳁􊬁􊮝􊵬=r
        ↪ 𝔦
    𝕊(("T_root", ⠤nmp⁺ζr⁺ ᴍ 𝑡))
    𝐑 = 𝐑 ᴍ 󰲡(x₀, ⠤x₁﹕ ᴍ󰲡 (r⁻󰑅ᴵ(≡(x₀)))¿xᐹ𝑡¡x)
    ↪ ℵ􋆒|nmp
⊢ parse_to_tree(𝑅, ℭ, χ, ι, show_table=✗, raise_failed=✓):
     rec = parse_to_tree(𝑅, ℭ, raise_failed=raise_failed)
    rec = 𝚲parse_to_tree(𝑅, ℭ, ⠤𝔸, raise_failed=raise_failed)
    γ, ⠤C = 𝑅󰃬
    ¿ι∉𝔠≔ℭ󰃺: ↪ γ, ‹‼∄‼›
    𝑔, 𝝌, ⠤𝐴 = 𝔠󰃬
    ¿raise_failed: 𝑔⨳‹Failed to parse tree!›
    
    ¿γ≡␛∧:
        o = []
        ∀r∈C:
            o.append(rec(χ, r))
            ¿r∉𝔠≔ℭ󰃺: ⇥
            χ = 𝔠ᵣ ₁
        ↪ γ, ⠤o
    ¿γ≡␛ᔐ: ↪ γ, C₀
    ¿γ≡␛?: ↪ γ, ⠤(𝐴 ∧ (𝐴₀ ∧ rec(χ, C₀)⛶ᵀ) ∨ ())
    ¿¬𝐴 ∧ γ∈{⠤"∨*+~←"}: ↪ γ, ‹‼∅‼›
    ¿γ≡␛~: ↪ γ, 𝐴₀.group(0)
    ¿γ≡␛∨: ↪ γ, rec(χ, C􊳳􊬣)
    ¿γ≡␛←: ↪ γ, C₀, rec(χ, 𝐴₀)
     ¿γ∈{⠤"*+"}: ↪ γ, ⠤𝐴₀ ᴍ rec(⬤, C₀)
    ¿γ∈{⠤"*+"}: ↪ γ, ⠤(rec(x, C₀) ∀x∈𝐴₀)
    ¿γ∈{⠤"✓✗⮞¬"}: ↪ γ, 
    ↪ γ.removeprefix(␛_), rec(χ, C₀)

⊢ chop_tree(󱁕, 𝐷, remove_trashes=✓,
             remove_failed_questions=✓,
             remove_lookaheads=✓):
    
    pops = ‹∧∨*+❗⠶?›
    removes = 𝑠(␛󰆴⋅remove_trashes+␛⮞␛¬⋅remove_lookaheads)
    
    ⊢ reform_str(󱁕):
        ¿󱁕ᵗ≡␛ᔐ ∨ 󱁕ᵗ≡␛~:
            󱁕ᵗ, 󱁕ᶜ, 󱁕ᵉ ᵀ = 󱁕ᶜ₀ᵗ, [], ✓
        ¡:
            ∀c∈󱁕: reform_str(c)
        ↪ 󱁕
    𝓣 ; reform_str(󱁕) ; 𝓣("Reform_str")
     󱁕.ftrp(␛ᔐ␛~, f)
    
    ⊢ ƒ(󱁕):
        ¿󱁕ᵉ ᵀ: ↪ True
        ¿󱁕ᵗ∈removes: ↪
        ¿remove_failed_questions ∧ 󱁕ᵗ≡␛?:
            ¿¬󱁕ᶜ: ↪
            󱁕ᶜ = list(filter(ƒ, 󱁕ᶜ))
            ¿¬󱁕ᶜ: ↪
            ↪ True
        󱁕ᶜ = list(filter(ƒ, 󱁕ᶜ))
        ↪ True
    𝓣 ; ƒ(󱁕) ; 𝓣("Removes")
     ¿removes:                 󱁕 = Ń.filter(󱁕, 󰲡xᵉ ᵀ ∨ xᵗ∉removes)
     ¿remove_failed_questions: 󱁕 = Ń.filter(󱁕, 󰲡xᵉ ᵀ ∨ xᵗ≠␛? ∨ xᶜ)
    
    ⊢ splat(󱁕):
        C = []
        ∀c∈󱁕:
            ¿cᵉ ᵀ:
                C.append(c) ; ↺
            v = splat(c)
            ¿isinstance(v, list):
                C.extend(v)
            ⸘cᵗ∈pops:
                C.extend(cᶜ) ; ↺
            C.append(c)
        ¿󱁕ᵗ≡␛⠶: ↪C
        󱁕ᶜ = C
    𝓣 ; splat(󱁕) ; 𝓣("Splats")
     ⊢ splat(󱁕):
         ƒ = 󰲡(xᴍ󰲡xᶜ󰅂Σ[]) ¿xᵗ≡␛⠶¡ xᶜ
         󱁕ᶜ = 󱁕 ᴍ󰲡ƒ(x) ¿xᐹŃ∧¬xᵉ ᵀ∧xᵗ∈pops¡ x⛶󰅂 Σ[]
         ↪ 󱁕
     𝓣 ; 󱁕.frp(󰲡¬xᵉ ᵀ, splat, pre=✓) ; 𝓣("Splats")
    
    ⊢ get_txt(󱁕):
        ¿󱁕ᵗ ≡ ␛ƨ:
            l = ''
            ⊢ ƒ(󱁕):
                nonlocal l
                ¿󱁕ᵉ ᵀ: l += 󱁕ᵗ
                ∀c∈󱁕 : ƒ(c)
            ƒ(󱁕)
            󱁕ᵗ, 󱁕ᶜ, 󱁕ᵉ = l, [], ℵ(T=✓)
            ↪
        ∀c∈󱁕: get_txt(c)
    𝓣 ; get_txt(󱁕) ; 𝓣("Get_txt")
     󱁕.ftrp(␛ƨ, 󰲡Ń(get_txt(x), e=ℵ(T=✓)))
    
    ⊢ set_arrows(󱁕):
        ¿󱁕ᵉ ᵀ: ↪
        ∀i,c ∈ 󱁕↨:
            ¿cᵉ ᵀ: ↺
            ¿cᵗ≡␛←:
                󱁕ᵉ􊬣􊫼 = 󱁕ᵢ = c₁
            set_arrows(c)
    𝓣 ; set_arrows(󱁕) ; 𝓣("Set arrows")
    ↪ 󱁕

 parse_to_node = 󱁕↦(ƒ ≔ 󰲡Ń(x, ⠤𝔸ᴍ󰲡ƒ(⠤x¿xᐹ𝑡¡x⛶ᵀ)))(⠤󱁕)
⊢ parse_to_node(󱁕):
    ⊢ ƒ(x, ⠤𝔸):
        ↪ Ń(x, ⠤(ƒ(⠤x ¿isinstance(x,tuple)¡ (x,)) ∀x∈𝔸))
    ↪ ƒ(⠤󱁕)

Ω Peggle2:
    __slots__ = ‹rules R›⍭
    ⊢ __init__(𝕊, g): 𝕊ʳᵘˡᵉˢ, 𝕊ᴿ = gʳᵘˡᵉˢ⋄gᴿ ¿gᐹPeggle2¡ g⋄make_rules(g)
    ⊢ __repr__(𝕊): ↪ ‹⟦ᐹ𝕊→.__name__⟧[⟦𝕊ʳᵘˡᵉˢ🃌⟧ Rules, ⟦𝕊ᴿ ᵀ􋕟ʳᵒᵒᵗ🃌⟧ Normalized]›
    ⊢ __contains__(𝕊, x): ↪ x∈𝕊ʳᵘˡᵉˢ
    ⊢ __or__(𝕊, h, allow_conflict=✗):
        ¿hᐹ𝕊: h = hʳᵘˡᵉˢ
        conflict = (𝕊ʳᵘˡᵉˢ.keys)∩(h.keys)
        ¬(allow_conflict ∧ conflict)⨳‹Conflicting rules! ⟦conflict⟧›
        ↪ (ᐹ𝕊)(Peggle2(𝕊ʳᵘˡᵉˢ | h))
    ⊢ __call__(𝕊, content, rule="main", DEBUG=✗, chop=✓, ⠶𝓚):
        DEBUG¬⨳"Not implemented."
        c, r = content, rule
        root, rule = 𝕊ᴿ ᵀ􋕟ʳᵒᵒᵗ, 𝕊ᴿᵣ
        
        𝓣 ; ℭ = parse(c, root, rule) ; 𝓣("Parse")
        
        𝓣 ; 󱁕 = parse_to_tree(root, ℭ, 0, rule) ; 𝓣("Convert")
        
        𝓣 ; 󱁕 = parse_to_node(󱁕) ; 𝓣("Nodeing")
        
        𝒸 = 𝚲chop_tree(󱁕, c, ⠶𝓚|𝕂)
        ↪ 𝒸 ¿chop¡ ℵ(table=ℭ, tree=󱁕, chop=𝒸)
    ⊢ print_rules(𝕊):
        𝕊ʳᵘˡᵉˢ.itemsꟿ󰲣(‹⟦x⟧:›☾, y☾)
    ⊢ print_normalized(𝕊):
        𝕊ᴿ ᵀ􋕟ʳᵒᵒᵗ↨ ꟿ󰲣 ☾‹⟦x⟧𝘁⟦𝘀.join(yᴍᔐ)⟧›

GRANDMA_RULES = ŕ≔(⠤map(re.compile, (('[\ueb26#][^\\n]*'), ('[⯅⯆△▽↷]'), ('"(␛.|[^"])*"'), ("'(␛.|[^'])*'"), ('‹(␛.|[^›])*›'), ('[^⯅⯆△▽↷󰆴()?❗⮞.:⠶ƨ✗+*=¬∨∧~‹#\'" \\t\\n]+|✗'), ('[󰆴❗⮞⠶ƨ~¬]'), ('[*+?]'), ('([ \\t]|␛\\n)+'), ('([ \\t\\n]|␛\\n)+'))),) →►← ℵ∘{'statements':('∨',('∧',('?',('_W',)),('*',('∧',('∨',('_comment',),('_elm_o',)),('?',('_W',)))))),'comment':('∨',('~',ŕ[0])),'elm_o':('∨',('∧',('_elm_a',),('*',('∧',('?',('_W',)),('ᔐ','∨'),('?',('_W',)),('_elm_a',))))),'elm_a':('∨',('∧',('_elm_j',),('*',('∧',('∨',('∧',('?',('_W',)),('ᔐ','∧'),('?',('_W',))),('?',('_w',))),('_elm_j',))))),'elm_j':('∨',('__elm_j',),('_elm',)),'_elm_j':('∨',('∧',('_elm',),('?',('_W',)),('~',ŕ[1]),('?',('_W',)),('∨',('__elm_j',),('_elm',)))),'elm':('∨',('∧',('_prefix',),('∨',('_assign_eql',),('_assign_cln',),('_group',),('_str',),('_rname',)),('_suffix',))),'assign_eql':('∨',('∧',('_rname',),('?',('_W',)),('ᔐ','='),('?',('_W',)),('_elm_o',))),'assign_cln':('∨',('∧',('_rname',),('?',('_W',)),('ᔐ',':'),('?',('_W',)),('_elm_j',))),'group':('∨',('∧',('ᔐ','('),('?',('_W',)),('_group_inner',),('ᔐ',')'))),'group_inner':('∨',('*',('∧',('_elm_o',),('?',('_W',))))),'str1':('∨',('~',ŕ[2])),'str2':('∨',('~',ŕ[3])),'str3':('∨',('~',ŕ[4])),'str':('∨',('_str1',),('_str2',),('_str3',)),'rname':('∨',('~',ŕ[5])),'prefix':('∨',('∧',('?',('_w',)),('+',('∧',('~',ŕ[6]),('?',('_W',))))),('?',('_w',))),'suffix':('∨',('∧',('+',('∧',('?',('_W',)),('~',ŕ[7]))),('?',('_w',))),('?',('_w',))),'w':('∨',('~',ŕ[8])),'W':('∨',('~',ŕ[9]))}
BOOTSTRAP = Peggle2(GRANDMA_RULES)

__exports__ = "Peggle2",

¿ __name__≡"__main__":
    RULE = "statements"
    CONTENT = 󰦥󰦥󰦥󰦥󰦥
    main    = 󰆴W? (entry 󰆴W?)*
    entry   = (
        ƨ(section=󰆴'[' wrd 󰆴']') 󰆴W?
        (pair = (
            (bruh:key = ⠶wrd) 󰆴(w? ↷ '=')
            (value = (wrd ∨ str)+) 󰆴W? ) )* )
    str     = ~‹"[^"]+"›
    wrd     = ~‹[-\w]+›
    w       = ~‹[ \t]+›
    W       = ~‹[ \t\n]+›
    󰦥󰦥󰦥󰦥󰦥⋅2

    BOOTSTRAP☾
    󱁕 = BOOTSTRAP(CONTENT, RULE)
    "FINISHED"☾
    󱁕ᴾ☾

⊢ Peggle1Bootstrap(c=ℵ()):
    ¿"BOOTSTRAP_PEGGLE1"∈c:
        ↪ c.ForcefeedPeggle1Peggle2, c.BOOTSTRAP_PEGGLE1
    
    ⊢ peggle122(rules):
        ⊢ ƒ(x):
            ¿xᵗ≡␛←: ↪ (xᵗ, x₀ᶜ, ƒ(x₁))
            ¿xᵗ≡"rname": ↪ (␛_⋅(xᶜ∉␛✓␛✗)+xᶜ, )
            ↪ xᵗ, ⠤((xᶜ ᴍ ƒ) ¿xᴸ¡ (xᶜ, ))
        ↪ ℵ(rules) ꟿⱽ 󰲣ƒ(y)
    ⊢ peggle221(󱁕):
        ⮌ node ⨡ Node
        ⊢ ƒ(󱁕):
            s = ℵ()
            ∀k,v ∈ 󱁕ᵉ:
                ¿k≡␛T: ↪Node(c=󱁕ᵗ)
                s􋑺􊬄􋕜ᵢₙₑₓ₍ᵥ₎ = k
            c = 󱁕ᴍƒ
            ∀i,v∈s: cᵢᵉ = v
            ↪Node(󱁕ᵗ, c)
        ↪ ƒ(󱁕).find_replace(󰲡x🃌≡1 ∧ xᶜ₀ᐹNode ∧ ¬xᶜ₀ᵗ, 󰲡x.copy(c=xᵗˣᵗ))

    Ω ForcefeedPeggle1Peggle2(Peggle2):
        ⊢ __init__(𝕊, x):
            ¿xᐹPeggle2: super().__init__(x)
            ¡         : super().__init__(peggle122(x))
        ⊢ __call__(𝕊, ⠤𝔸, ⠶𝕂):
            ↪ peggle221(super().__call__(⠤𝔸, ⠶𝕂))
        ⊢ __or__(𝕊, x):
            ↪ super().__or__(peggle122(x))
        ⊢ dump_gram(𝕊):
            ↪ dumps((𝑑∘𝕊ʳᵘˡᵉˢ, 𝑑∘𝕊ᴿ, 𝕊ᴿ.getdef))
        @𝒞ℳ
        ⊢ load_gram(ℂ, gram):
            𝕊 = ℂ.__new__(ℂ)
            rules, R, d = loads(gram)
            𝕊ʳᵘˡᵉˢ, 𝕊ᴿ = ℵ(rules), ℵᵈ(R)
            ↪ 𝕊

    c.ForcefeedPeggle1Peggle2 = ForcefeedPeggle1Peggle2
    c.BOOTSTRAP_PEGGLE1 = ForcefeedPeggle1Peggle2(BOOTSTRAP)
    ↪ c.ForcefeedPeggle1Peggle2, c.BOOTSTRAP_PEGGLE1