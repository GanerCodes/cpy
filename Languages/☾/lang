# I: Include self in group (right asoc.)
# Î±: basic concat
# Î´: x <op>= y doesn't make sense
# Ï: *special*

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« HEADERS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

from whitespace_tools import *
from string import digits, ascii_uppercase
from unicodedata import is_normalized

py_special_mapper  = lambda c, m={'ğ—»':'\\n','ğ˜€':' ','ğ˜':'\\t'}: m[c]
py_bad_string_chr  = lambda s, bad="\n\t\\\"'{}": s in bad
py_escape_char     = lambda c, u='\\u': u+HXO(c) if py_bad_string_chr(c) else c
py_escape_string   = lambda s: á¦.join(py_escape_char(c) for c in s)
py_ok_identifier   = lambda x: x in digits or is_normalized("NFKC", x) and x.isidentifier()
py_escape_var      = lambda s: á’(á¦, (c if ord(c)<127 and c!='!' or py_ok_identifier(c) else 'á§'+HXO(c) for c in s)) \
                                    if 'NOVAR' not in CONST and s != '!=' else s

mkgrp = lambda *X, b="()": Åƒ("group", b[0], âµŒ(X)==1 and X[0] or X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkexp = lambda *X: Åƒ("expr", *X)
mkstr = lambda x: Åƒ("str", '"', x, '"')
mkvar = lambda x: Node("var", x)
mkexp_ = lambda *n: Node("expr_", á’ª(n))
mkgxp_ = lambda *n: mkgrp(mkexp_(*n))
fcall_ = lambda f,*n: mkexp_(f, mkgxp_(*JÌ(n, COMMA)))
mknex_ = lambda a, b: mkexp_(a, EQCLN, b)

sst = lambda x: set(á–µ(á—œ,á´(âµ,âµ‰(á–‡(x,'â‰',Å„),Å„))))
mdt = lambda y: á–±(á´(âµ,âµ‰(x,Å›,1)) for x in sst(y))
inv = lambda z: {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

COMMA, COLON, EQCLN = (Node("oper_lit", x) for x in âµ‰(", : :=", Å›))
Ã¾0, Ã¾1, Ã¾2, Ã¾Ã¾ = á´(mkvar, âµ‰("Ã¾0 Ã¾1 Ã¾2 Ã¾Ã¾", Å›))

OPS_BUILTIN = {
    'S': á¦,
    'N': """; â‰ : â‰ , â‰ if â‰ elif â‰ else â‰ for""",
    'P': """+ â‰ - â‰ * â‰ ~  â‰   ** â‰  not â‰ yield""",
    'B': """+ â‰ - â‰ * â‰ @  â‰   ** â‰   // â‰  < â‰ > â‰ % â‰ .
            & â‰ ^ â‰ | â‰ /  â‰   != â‰   == â‰ << â‰ >>â‰>= â‰ <=
           in â‰ not inâ‰ is â‰is notâ‰   or â‰ and""" }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

OPS_COMP = á–µ(á—œ, ({s for s in l if 'Î»' in lang.ops[s]} for l in lang.op_orders.values()))

SWAP_TABLE = mdt("""
    â‹…   * â‰ âŒƒ    ** â‰ â‰¡     == â‰ â‰¤ <= â‰ â‰” := â‰ Â¯ -
    â ¤   * â‰ â ¶    ** â‰ â‰      != â‰ â‰¥ >= â‰ Ã· / â‰ â¹ //
    âˆ¨  or â‰ â‰…    is â‰ ó°†´    del â‰ Î© class
    Â¬ not â‰ Â¿    if â‰ âŠ¢    def â‰ â° while
    âˆ§ and â‰ â¸˜  elif â‰ â®‚  yield â‰ â†ª return
    âˆ€ for â‰ Â¡  else â‰ â‡¥  break â‰ â†º continue
    âˆˆ  in â‰ â®Œ  from â‰ â¨¡ import â‰ â‰‡ is not â‰ âˆ‰ not in""")
KEYWORDS_TO_CPY=rmk(inv(SWAP_TABLE), sst("* â‰ **"))

merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in SWAP_TABLE.items() if y in z}

kw_pfx_colon = merge_shorthands("""
    if â‰ elif â‰ else â‰ for â‰ while
    try â‰ except â‰ finally â‰ class
    match â‰ case â‰ def â‰ with""")
kw_pfx = merge_shorthands("""
    return â‰ continue â‰ break â‰ pass
    import â‰ global â‰ nonlocal
    raise â‰ assert â‰ del â‰ async""")
kw_neverswouce = merge_shorthands("""if â‰ elif â‰ else â‰ for â‰ yield""")
kw_inline = merge_shorthands("""in â‰ is â‰ is not â‰ not in â‰ or â‰ and â‰ not""") | kw_neverswouce
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("â„µğ•‹ğ”½â´³â´´âœ“âœ—Ã®Ï€Ï„â–¡âˆ…âˆá¦")

register("kw", kw)
register("kw_pfx", kw_pfx)
register("kw_spec", kw_spec)
register("kw_pfx_colon", kw_pfx_colon)
register("var_spec", var_spec)

L = {'.'}
sel = [(v.t+'=', v) for v in lang.ops.values() if v.B and 'Î´' not in v] \
    + [(":=", lang.ops['â‰”']), ('â‰”', lang.ops.pop('â‰”'))]
new_ops = {}
for k, v in sel:
    new_ops[k] = OP(k, "B=", L, lang.ops["â€ASGN_MRK"].R, v.f)
lang.ops |= new_ops

for k, v in lang.ops.items():
    if k in L: continue
    v.R |= set(new_ops)

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« OPERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

â¨¡á´ºá´¾ó°”
;á´ºá´¾ó°” ,á´ºá´¾ó°”
=á´ºá´¾ó°” â®‚á´ºá´¾ó°” â†ªá´ºá´¾ó°” â®Œá´ºá´¾ó°” â†ºá´ºó°” â‡¥á´ºó°” â°á´ºá´¾ó°” âˆ€ â›
â ¤á´¾ó°”ó° â ¶á´¾ó°”ó° :á´®á´¾á´ºó°ó°”
â€1á´µá´® Â¿á´ºá´¾ó°” â¸˜á´ºá´¾ó°” Â¡á´ºá´¾ó°”
â€ASGN_MRKá´® â‰”á´®ó°œ
â¨³á´®á´¾ó°€’á´º
âŠ»á´®á´ºó°– â‰ â¨á´®á´ºó°– â‰ âˆ¨á´®á´ºó°œ â‰ âŠ¼á´®á´ºó°– â‰ âˆ§á´®á´ºó°œ
â‰¡á´®á´ºó°ó°– â‰ á´®á´ºó°ó°– â‰¤á´®á´ºó°ó°– â‰¥á´®á´ºó°ó°– âˆˆá´®á´ºó°– âˆ‰á´®á´ºó°– âˆŒá´®á´ºó°– âˆ‹á´®á´ºó°– â›
      <=á´®á´ºó°ó°– >=á´®á´ºó°ó°– <á´®á´ºó°–ó° >á´®á´ºó°–ó° â›
      âŠŠá´®á´ºó°– âŠ„á´®á´ºó°– âŠ‚á´®á´ºó°– âŠƒá´®á´ºó°– âŠ…á´®á´ºó°–  âŠ‹á´®á´ºó°–
êŸ¿á´®á´º á´á´®á´º   Å¿á´®á´º   Ïœá´®á´º  Î£á´®á´¾ó°€’á´º Î á´®á´¾ó°€’á´º ó°ˆ²á´®á´¾ó°€’á´º ó°ˆ³á´®á´¾ó°€’á´º ó°’¼á´®á´¾ó°€’á´º ó°’½á´®á´¾ó°€’á´º â›
    á™á´®ó°€’á´º  á™¡á´®ó°€’á´º  á—¢á´®ó°€’á´º á™§á´®ó°€’á´º
á¹á´®á´º Î¶á´®á´º
|á´®á´º â‰ ^á´®á´º â‰ &á´®á´º
<<á´®á´º >>á´®á´º
âˆ“á´¾á´®á´º Â±á´¾á´®á´º +á´¾á´®á´º -á´¾á´®á´º
â‰…á´®á´ºó° â‰‡á´®á´ºó°
á£†á´®á´¾ó°€’á´º âˆ˜á´®á´º â—‹á´®á´º
â—„á´®á´ºó° â–ºá´®á´ºó°
â‹„á´®á´º
ó°‘…á´®á´º ó°‘á´®á´º ó°‘ƒá´®á´º
âˆªá´®á´º â‰ âˆ©á´®á´º â‰ â¨‰á´¾ó°€’á´®á´º âˆ–á´®á´º
//á´®á´º â¹á´®á´º   /á´®á´º   Ã·á´®á´º   %á´®á´º   @á´®á´¾á´ºó° *á´®á´ºá´¾ó° â‹…á´®á´º  âˆšá´¾á´º â›
     !ó°€’á´º   â‹€á´¾ó°€’á´º  â‹á´¾ó°€’á´º  â«°á´¾ó°€’á´º  â«¯á´¾ó°€’á´º â›
     â­¥á´¾ó°€’á´º  â†¨á´¾ó°€’á´º  â¤‰á´®á´¾ó°€’á´º â¤ˆá´®á´¾ó°€’á´º ó·¹„á´®á´¾ó°€’á´º â˜¾á´¾ó°€’á´º  ğŸƒŒá´¾ó°€’á´º â–¢á´®á´¾ó°€’á´º â›
     â¬„á´®á´¾ó°€’á´º á’á´®á´º   ó°›”á´®á´¾ó°€’á´º ó°˜¬á´®á´¾ó°€’á´º â›¶á´¾ó°€’á´º  â‰á´¾ó°€’á´º  á´™á´¾ó°€’á´º â´µá´¾ó°€’á´º â›
     â­á´¾ó°€’á´º
Â¬á´¾ó°€’á´ºó°œ Â¯á´¾á´º
**á´µá´®á´¾ó° â€¦á´®á´º âŒƒá´µá´®
î®¦á´ºó°€’
.á´®ó°ó°”
...á´º

  ï½œ  â†á´¾ó°ó°œï½œâ€1
â€1ï½œ  â†’ó°€’ó°ó°œï½œ
â€1ï½œ  â¥‰á´®ó°ó°œï½œâ€1

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GRAMMAR Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

parser_main = exprs
parser_comment = (â ¶str âˆ¨ ó°†´comment âˆ¨ ~â€¹.|\nâ€º)*

exprs = W? (â ¶expr W?)*
expr = (
    (kw_pfx_colon_expr =  â ¶vkw_pfx_colon ó°†´Ã†? (expr_not_colon? ó°†´Ã†? ó°†´':') M:âœ“ ó°†´E? expr?)
        âˆ¨ (kw_pfx_expr =  â ¶vkw_pfx ó°†´E? expr?)
          âˆ¨ (norm_expr = (â ¶norm_expr_atom)+))

expr_not_colon = (Â¬':' â ¶norm_expr_atom)+
expr_not_comma = (Â¬',' â ¶norm_expr_atom)+

vkw_pfx_colon = â®kw_spec kw_pfx_colon âˆ¨ kw_pfx_colon â®text_breaker
vkw_pfx       = â®kw_spec kw_pfx       âˆ¨ kw_pfx       â®text_breaker
vkw           = â®kw_spec kw           âˆ¨ kw           â®text_breaker

norm_expr_atom = (lamb âˆ¨ â ¶gen_expr_atom) ó°†´E?
gen_expr_atom = group âˆ¨ â ¶str âˆ¨ var_spec âˆ¨ number âˆ¨ oper âˆ¨ â ¶vkw âˆ¨ â ¶script âˆ¨ var
number = Æ¨(~â€¹\.[0-9]+|0[obOB][0-9]+|0[xX][0-9a-fA-F]+|[0-9]+e[0-9]+|[0-9]+(\.([0-9]+))?â€º)
var = Æ¨(Â¬W Â¬oper Â¬var_spec Â¬script ~â€¹[^ğ—®-ğ˜‡ğš²â¥Œâ†¦ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°…‚"'\[\](){}â…â†âŸ¦âŸ§âŸ¨âŸ©â€¹ â›â›â›â€º]â€º)+

group = ~â€¹[\[({â…âŸ¨âŸ¦]â€º (W? â†· exprs) ~â€¹[\])}â†âŸ©âŸ§]â€º

script = (
    (supscript = Æ¨(SUPSCRIPT+))
  âˆ¨ (subscript = Æ¨(SUBSCRIPT+)))

oper = (
    (oper_mod_l = ~â€¹[âŸ¥â‰º]*â€º)
     oper_lit
    (oper_mod_r = Æ¨((~â€¹[Â´êœ áµœâŸ¤]+â€º âˆ¨ supscript)*)))

lamb = (
    (   (lamb_h_py = ó°†´"lambda" â®text_breaker ó°†´Ã† â ¶expr_not_colon ó°†´':')
      âˆ¨ (lamb_h_normal = (
            ó°†´('â¥Œ' Ã†?)
            â ¶((Â¬lamb_h_implicit lamb) âˆ¨ â ¶gen_expr_atom ó°†´Ã†?)*
            ó°†´'â†¦' ))
      âˆ¨ (lamb_h_preset = ~"[ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©]")
      âˆ¨ (lamb_h_implicit = var ó°†´(Ã†? 'â†¦'))) ó°†´Ã†?
    (lamb_b = â ¶((exprs ó°†´'ó°…‚') âˆ¨ expr_not_comma)))

str = str_star âˆ¨ str_cpy âˆ¨ str_py âˆ¨ str_escape âˆ¨ str_spec_char
str_star = "ó°¦¥"
str_cpy = ó°†´'â€¹' (str_escape âˆ¨ str_sub âˆ¨ str_spec_char âˆ¨ str_guts)* ó°†´'â€º'
str_sub = ó°†´'âŸ¦' exprs ó°†´'âŸ§'
str_spec_char = ~â€¹[ğ—®-ğ˜‡]â€º
str_guts = ~"[^ğ—®-ğ˜‡âŸ¦â›â›â€º]+"
str_escape = ó°†´"â›â›" ~â€¹.â€º
str_py = ((â€¹"â€º (str_py_sub âˆ¨ ~â€¹[^"\\]+â€º)* â€¹"â€º)
       âˆ¨  (â€¹'â€º (str_py_sub âˆ¨ ~â€¹[^'\\]+â€º)* â€¹'â€º))

str_py_sub = ~â€¹\\.â€º

w = ~â€¹([ \t]*â›â›\n[ \t]*)+â€º âˆ¨ ~â€¹[ \t]+â€º
W = ~â€¹[ \t\n]+â€º
text_breaker = â®(E âˆ¨ kw_spec âˆ¨ var_spec âˆ¨ Â¬var)
E = w âˆ¨ ~â€¹â›â›\nâ€º
Ã† = W âˆ¨ ~â€¹â›â›\nâ€º

comment = ~â€¹((î¬¦|#)[^\n]*(?=\n|\Z))|(ğŸŸ‘[^ğŸŸ‘]*(ğŸŸ‘|\Z))|(Ö[^Ö]*(Ö|\Z))â€º

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GENERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

# ó°¤± Æ¨((ó°†´"ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥") (((Â¬ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥) ~â€¹.....â€º)*) (ó°†´"ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥")?)

# Â§ tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

def Ïƒ_00():
    @(yield replacement(
        *KEYWORD_NODE_NAMES,
        n="Lang keywords â†’ cpy keywords"))
    def _(n):
        if n.txt in kw_inline: # keyword that are just ops
            return OP.TND(KEYWORDS_TO_CPY.get(n.txt, n.txt))
        else:
            return n.copy(c=KEYWORDS_TO_CPY.get(n.txt, n.txt))
    
    ((yield reduction(
        "supscript",
        n="Swap Superscripts"))
    (lambda n: [OP.TND('.'), mkvar(n.txt)]))
    
    ((yield replacement(
        "subscript",
        rec='A',
        n="Subscripts to brackets"))
    (lambda n: mkgrp(gram(n.c, "exprs"), b="[]")))
    
    ((yield replacement(
        "norm_expr", "expr_not_colon", "expr_not_comma",
        rec='B',
        n="Normalize expression types"))
    (lambda n: n.copy("expr")))
    
    ((yield replacement(
        "W",
        n="Trim whitespace"))
    (lambda n: n.copy(c=Å„ in n.c and Å„+âµ‰(n.c,Å„)[-1] or n.c)))

def Ïƒ_05():
    op_chk = lambda n, o: n.t == "oper" and n.txt == o
    hs_op = lambda C, o: â´¸(op_chk(c, o) for c in C)

    @(yield replacement(
        "expr",
        rec='A',
        n="Detect for_expr"))
    def _(N):
        if not hs_op(C := N.C, 'âˆ€'): return N
        
        Î±, _, Î² = part(C, Ï(op_chk, o='âˆ€'))
        Î², _, Î³ = part(Î², Ï(op_chk, o='âˆˆ'))
        if hs_op(Î³, 'Â¿'):
            Î³, _, Ïƒ = part(Î³, Ï(op_chk, o='Â¿'))
        else:
            Ïƒ = None
        
        cc = [Node("expr", Î±), Node("expr", Î²), Node("expr", Î³)]
        if Ïƒ: cc.append(Node("expr", Ïƒ, e="cond"))
        return N.copy("for_expr", c=cc)
    
    @(yield replacement(
        "kw_pfx_colon_expr",
        rec='A',
        n="Detect for_stmt"))
    def _(N):
        if not op_chk(N.C[0], 'âˆ€'): return N
        Î±, _, Î² = part(N.C[1].C, Ï(op_chk, o='âˆˆ'))
        return N.copy("for_stmt", c=[Node("expr", Î±), Node("expr", Î²), *N.C[2:]])

def Ïƒ_10():
    ((yield replacement(
        "parser_main", rec='A', n="Build whitespace blocks"))
    (whitespace_parser))

ARG_A = mkexp(("oper_lit", "â ¤"), mkvar('ğ”¸'))
ARG_K = mkexp(("oper_lit", "â ¶"), mkvar('ğ•‚'))
def Ïƒ_15():
    yield "Refactor lambdas"
    ((yield replacement(
        "lamb_h_preset"))
    (lambda n: Åƒ("lamb_h",
            *á´(lambda t: mkexp(mkvar(t)), "xyzwv"[:"ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©".index(n.c)]),
            ARG_A, ARG_K)))
    
    ((yield replacement(
        "lamb_h_implicit"))
    (lambda n: Åƒ("lamb_h", mkexp(n.C[0]), ARG_A, ARG_K)))
    
    @(yield replacement(
        "lamb_h_normal", "lamb_h_py"))
    def _(n):
        C = á´(Node.strip,
              á´s(mkexp,
                 split_at(
                    n.C,
                    lambda x: OP.is_op(x) and (k:=op_man[x]).t == ',')))
        has_a = has_k = â´´
        
        C = á–µ(lambda x: x.txt, C) # b/c â¥Œâ†¦ has empty an expr
        for c in C:
            if not c.C or (o:=c.C[0]) != "oper": continue
            k = o.C[1].c
            if   k in ( "*", "â ¤"): has_a = â´³
            elif k in ("**", "â ¶"): has_k = â´³
        if not has_a: C.append(ARG_A)
        if not has_k: C.append(ARG_K)
        return Åƒ("lamb_h", *C)
    
    ((yield replacement(
        "lamb_b",
        rec='A'))
    (lambda n: n.copy(t="expr")))

def Ïƒ_20():
    ((yield replacement(
        "expr",
        rec='B',
        n="Parse expressions"))
    (lambda n: n.copy(c=into_expr(parse_expr(n.C)).c)))

def Ïƒ_21():
    def split_target(l):
        l, t = l.copy(), []
        while l:
            Î± = l.pop()
            if Î± == '.':
                return '.', l, t[0]
            if Î±.t == "op_call":
                assert Î±.C[1].txt == '.'
                l = l + [*Î±.C[0], '.', *Î±.C[2]]
                continue
            if Î±.t == "group" and (Î±.C[0].txt, Î±.C[2].txt) == ('[', ']'):
                return 'l', l, Î±.C[1]
            t.insert(0, Î±)
        assert âµŒ(t) == 1
        return á¦, á—œ, t[0]

    def make_inline_asgn(Î±, Î£, Î²):
        Ï„, Îº, Ï‡ = split_target(Î±.C)
        
        if Ï„ == á¦: return \
            mkgrp(mknex_(Ï‡, mkgxp(Î£ and ("op_call", mkexp(Ï‡), Î£, Î²) or Î²)))
        
        Îº = mkgxp(*(Node("expr_", '.') if i == '.' else i for i in Îº))
        Ï‡ = mkgxp(Ï„ == '.' and ("str_", f'"{py_escape_var(Ï‡.txt)}"') or Ï‡)
        Ï = Ï„ == '.' and "attr" or "item"
        Î³ = Î£ and Node("op_call", [fcall_(mkvar("get"+Ï), Ã¾1, Ã¾2), Î£, Ã¾0]) or Ã¾0
        return fcall_(
            mkvar("set"+Ï+"_ret_"),
            *á´s(mknex_, ([Ã¾0,Î²],[Ã¾1,Îº],[Ã¾2,Ï‡])), Î³)
    
    @(yield replacement(
        "op_call",
        rec='A',
        n="Refactor assignment infix opertators"))
    def _(n):
        Î±, Î£, Î² = n.C
        if Î£.c[0].txt or Î£.c[2].txt: return n
        if Î£.txt in ('â‰”', ':='): return make_inline_asgn(Î±, None, Î²)
        if '=' not in lang.ops[Î£.txt]: return n
        Î£ = OP.TND(Î£.txt[:-1])
        return make_inline_asgn(Î±, Î£, Î²)

def Ïƒ_25():
    @(yield reduction(
        "op_call",
        rec='B',
        n="Flatten cmp ops"))
    def _(n):
        if 'Î»' in op_man[n.C[1]] and \
                n.C[0] != NULL and n.C[2] != NULL:
            return [*n.C[0].C, n.C[1], *n.C[2].C]
        return [n]

def Ïƒ_30():
    def make_cmp_chain(n, layers=á—œ):
        layers = layers or OPS_COMP
        layer, *layers = layers
        
        rec = lambda n: layers and make_cmp_chain(n, layers=layers) or n
        mkexp_rec = lambda N: rec(mkexp(*N))
        
        C = á’ª(split_at(n.C,
            lambda x: OP.is_op(x) and (k:=op_man[x]).t in layer and k.B,
            keep_separator=â´³))
        if âµŒ(C) < 3:
            return rec(n)
        r = â´´
        
        for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
            c = mkexp_rec(c)
            v = mkexp(("op_call",
                H and mkexp_rec(a) or Ã¾Ã¾,
                b,
                T and c or mknex_(Ã¾Ã¾, c)))
            r = mkexp(("op_call", r, OP.TND('âˆ§'), v)) if r else v
        return n.copy(c=[r])
    
    ((yield replacement(
        "expr",
        rec='B',
        n="Generate comparison chains"))
    (make_cmp_chain))

demodp = lambda o: (o.C[0].txt, o.C[1], o.C[2].txt)
def mkbltnop(op_l): # format builtins if needed
    t = op_l.txt
    if (t := SWAP_TABLE.get(t,t)) not in OPS_BUILTIN['A']:
        return op_l
    return mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
def transform_oper(op_): # apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    if not (m_l or m_r): return op_l
    op_n = mkbltnop(op_l)
    mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
    
    if 'â‰º' in m_l: op_n = mkmod(op_n, "BSTAR")
    if 'âŸ¥' in m_l: op_n = mkmod(op_n, "LNULL")
    
    rmods = á¦
    for m in m_r:
        if m in "âŸ¥âŸ¤áµœêœ Â´":
            match m:
                case 'âŸ¤': op_n = mkmod(op_n, "RNULL")
                case 'áµœ': op_n = mkmod(op_n, "SWAPA")
                case 'êœ ': op_n = mkmod(op_n, "DUPER")
        else:
            rmods += m
    if rmods:
        rmods = á’(',', (f'"{x}"' if FS(x).issubset(ascii_uppercase) else lang(x) \
                    for x in SCRIPT.sup2nrm(rmods).split('ğ‘')))
        op_n = mkexp(op_n, Node("expr_", f'[{rmods}]'))
    return op_n

def Ïƒ_35():
    hnul = lambda x: x.copy("NULL_") if x == "NULL" else x
    
    def try_builtin(m, op_l, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
        if m_l or m_r:
            return
        t_ = SWAP_TABLE.get(t, t)
        if t_ not in OPS_BUILTIN[m]:
            return
        return mkgxp(*Îµ(L), op_l, *Îµ(R))

    @(yield replacement(
        "op_call",
        rec='B',
        n="Refactor op calls"))
    def _(n):
        l, op_, r = n.C
        op = op_man[op_]
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
        
        if not (m_l or m_r):
            if 'Î²' in op and     L and R: return mkgxp(L, op_l, R)
            if 'Ïƒ' in op and not L and R: return mkexp(op_l, r)
            if 'Î¹' in op: return mkexp(hnul(l), op_l, hnul(r))
            if 'Ï' in op:
                match t:
                    case 'â†’': return L
                    case 'â†': return R
                    case 'â¥‰': return mkgxp(R, L)
                    case 'â‰”': return mkgxp(l, op_l, R)
                    case ('Â¬') if L or R:
                            return mkgxp(op_l, L or R)
        
        op_l = transform_oper(op_)
        
        A = (op_l, L, m_l, t, m_r, R)
        if op.S and L and not op.B:
            return try_builtin('S', *A) or mkexp(mkbltnop(op_), L)
        if op.P and R and not op.B:
            return try_builtin('P', *A) or mkexp(mkbltnop(op_), R)
        if op.B and L and R:
            return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA,    r))
        if op.S and L:
            return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA, NULL))
        if op.P and R:
            return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    r))
        return mkbltnop(op_)

def Ïƒ_40():
    @(yield replacement(
        "oper",
        rec='A',
        n="Refactor sitting ops"))
    def _(n):
        if n.C[1].txt in kw_neverswouce:
            return n
        if not (n.C[2].txt or n.C[0].txt):
            n = n.copy(c=[n.C[0], n.C[1], n.C[2].copy(c="Â´")])
        return transform_oper(n)
    
    ((yield replacement(
        *KEYWORD_NODE_NAMES, "oper_lit",
        n="Lang keywords â† cpy keywords"))
    (lambda n: n.copy(c=py_escape_var(SWAP_TABLE.get(n.txt, n.txt)))))
    
    ((yield replacement(
        "lamb",
        rec='B',
        n="Format lambda"))
    (lambda n: mkgxp(n.C[0], mkgrp(n.C[1]))))
    
    ((yield replacement(
        "lamb_h",
        rec='B',
        n="Format lambda header"))
    (lambda n: Åƒ("lamb_h", ("kw", "lambda"), *JÌ(n.C, COMMA), ("oper_lit", ":"))))

def Ïƒ_45():
    ((yield replacement(
        "parser_main",
        rec='A',
        n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((yield reduction(
        "BLOCK",
        rec='B',
        n="Flatten blocks"))
    (lambda n: n.C))

def Ïƒ_48():
    ((yield replacement(
        "for_expr",
        rec='B',
        n="Build for exprs"))
    (lambda n: Åƒ(
        "expr",
        n.C[0], ("kw", "for"), n.C[1], ("kw", "in"), n.C[2],
        *([("kw", "if"), n.C[3]] if n['cond'] else []))))
    
    ((yield replacement(
        "for_stmt",
        rec='B',
        n="Build for stmt"))
    (lambda n: Åƒ(
        "kw_pfx_colon_expr",
        Node("kw_pfx_colon", "for"),
        ("expr", n.C[0], ("kw", "in"), n.C[1]),
        *n.C[2:])))

def Ïƒ_50():
    ((yield replacement(
        "kw_pfx_colon_expr",
        rec='B',
        n="Add colons"))
    (lambda n: n.insert_after_marker('M', COLON)))
    
    ((yield replacement(
        "parser_main",
        rec='B',
        n="Insert spaces"))
    (Ï(add_spaces, ignore_nodes=("str_cpy", "str_py"))))

# Â§ node transpilers
@generator(*KEYWORD_NODE_NAMES, "oper_lit")
def gen_oper_lit     (n): return py_escape_var(n.txt) # n.txt
@generator("var", "var_spec")
def gen_variable     (n): return py_escape_var(n.txt)
@generator("NULL")
def gen_variable     (n): return "NULL"
@generator("group")
def gen_group        (n):
    if n.C[0].txt == 'âŸ¦':
        content = next(filter(âµ, á´(gen, n.C[1:-1])))
        return f'''(exec("def _EXE():\\n{py_escape_string(force_indent(content))}",globals(),locals()),_EXE)[1]()'''
    return n.C[0].txt + á’(á¦, á´(gen, n.C[1:-1])) + n.C[-1].txt

# strings
@generator("str_guts")
def gen_str_guts     (n): return py_escape_string(n.txt)
@generator("str_escape")
def gen_str_escape   (n): return "'" + py_escape_string(n.txt) + "'"
@generator("str_sub")
def gen_str_sub      (n): return "{" + gen(n.C[0]) + "}"
@generator("str_spec_char")
def gen_str_spec_char(n): return "'" + py_special_mapper(n.txt) + "'"
@generator("str_cpy")
def gen_special_str(n):
    r='f"""'
    for c in n.c:
        if   c.t == "str_escape"   : r += py_escape_string(c.txt)
        elif c.t == "str_spec_char": r += py_special_mapper(c.txt)
        else                       : r += gen(c)
    return r + '"""'