# P/S/B/N: prefix/suffix/binary/nullary
# I: Include self in group (right asoc.)
# α: basic concat
# δ: x <op>= y doesn't make sense
# ν: NULL version self-calls
# χ: <op>󰀂 with C: capital letter doesn't do anything special
# ρ: *special*

«««««««««««««««««««««««««««««««««« HEADERS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

from whitespace_tools import *
from string import ascii_uppercase
from py_naming_tools import *
py_escape_var = lambda x, f=py_escape_var: f(x, ⴳ)

mkexp = lambda *X: Ń("expr", *X)
mkgrp = lambda *X, b="()": Ń("group", b[0], X[0] if ⵌ(X)==1 else X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkstr = lambda x: Ń("str", '"', x, '"')
mkvar = lambda x: Node("var", x)
mkexp_ = lambda *n: Node("expr_", ᒪ(n))
mkgxp_ = lambda *n: mkgrp(mkexp_(*n))
fcall_ = lambda f,*n,E=[]: mkexp_(f, mkgxp_(*J́(n, COMMA)), *E)
mknex_ = lambda a, b     : mkexp_(a, EQCLN, b)

sst = lambda x  : set(ᖵ(ᗜ,ᴍ(ⵐ,ⵉ(ᖇ(x,'␉',ń),ń))))
mdt = lambda y  : ᖱ(ᴍ(ⵐ,ⵉ(x,ś,1)) for x in sst(y))
inv = lambda z  : {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

NUM_M3, NUM_M2, NUM_M1, NUM_P0, NUM_P1 = (Node("number", ᔐ(x)) for x in range(-3,2))
COMMA, COLON, EQCLN = (Node("oper_lit", x) for x in ⵉ(", : :=", ś))
ARG_A = mkexp(("oper_lit", "⠤"), mkvar('𝔸'))
ARG_K = mkexp(("oper_lit", "⠶"), mkvar('𝕂'))
TACTACK_L, TACTACK_R = mkvar('⟞'), mkvar('⟝')
TRUE, FALSE = mkvar("True"), mkvar("False")
þPSH, þPOP = mkvar("þPSH"), mkvar("þPOP")
þPOP_M3, þPOP_M2, þPOP_M1 = fcall_(þPOP, NUM_M3), fcall_(þPOP, NUM_M2), fcall_(þPOP, NUM_M1)

þPOPNR = fcall_(mkvar("þPOPNR"))
þþ = mkvar("þþ") # sus

OPS_BUILTIN = {
    'S': """""",
    'N': """; ␉ : ␉ , ␉ if ␉ elif ␉ else ␉ for""",
    'P': """+ ␉ - ␉ * ␉ ~ ␉ ** ␉not ␉ yield""",
    'B': """+ ␉ - ␉ * ␉ @ ␉ ** ␉ // ␉< ␉ > ␉ % ␉ . ␉ & ␉ ^ ␉ | ␉ / ␉ != ␉ == ␉ << ␉ >> ␉ >= ␉ <= ␉ in ␉ not in␉ is ␉is not␉ or ␉ and""" }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

OPS_COMP = ᖵ(ᗜ, ({s for s in l if 'λ' in lang.ops[s]} for l in lang.op_orders.values()))

SWAP_TABLE = mdt("""
    ⋅   * ␉ ⌃    ** ␉ ≡     == ␉ ≤ <= ␉ ≔ := ␉ ¯ -
    ⠤   * ␉ ⠶    ** ␉ ≠     != ␉ ≥ >= ␉ ÷ / ␉ ⹏ //
    ␀CAT *␉
    ∨  or ␉ ≅    is ␉ 󰆴    del ␉ Ω class ␉ 󱀘 class
    ¬ not ␉ ¿    if ␉ ⊢    def ␉ ➰ while
    ∧ and ␉ ⸘  elif ␉ ⮂  yield ␉ ↪ return
    ∀ for ␉ ¡  else ␉ ⇥  break ␉ ↺ continue
    ∈  in ␉ ⮌  from ␉ ⨡ import ␉ ≇ is not ␉ ∉ not in""")
KEYWORDS_TO_CPY=rmk(inv(SWAP_TABLE), sst("* ␉ **"))

merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in SWAP_TABLE.items() if y in z}

kw_pfx_colon   = merge_shorthands("""if ␉ elif ␉ else ␉ for ␉ while ␉ try ␉ except ␉ finally ␉ class ␉ match ␉ case ␉ def ␉ with""")
kw_neverswouce = merge_shorthands("""if ␉ elif ␉ else ␉ for ␉ yield""")
kw_inline      = merge_shorthands("""in ␉ is ␉ is not ␉ not in ␉ or ␉ and ␉ not""") | kw_neverswouce
kw_pfx         = merge_shorthands("""return ␉ continue ␉ break ␉ pass ␉ import ␉ global ␉ nonlocal ␉ raise ␉ assert ␉ del ␉ async""")
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("ⴳⴴ✓✗□ᐦ󰮈⬤îĵ󷺈ℇτπ󷺍󷺏∞󷱪󷱽󷱾󷱫󷱬󷱭󷱮󷱯󷱰󷱩↉½⅓¼⅕⅙⅐⅛⅑⅒⅔⅖¾⅗⅜⅘⅚⅝⅞") # forced to be one char, will not act as object or attr-getter when superscript
escaped_var_specs = {*ᴍ(py_escape_var, var_spec)}

register("kw", kw)
register("kw_pfx", kw_pfx)
register("kw_spec", kw_spec)
register("kw_pfx_colon", kw_pfx_colon)
register("var_spec", var_spec)

IG = {'.'}
sel = [(v.t+'=', v) for v in lang.ops.values() if v.B and 'δ' not in v] \
    + [(":=", lang.ops['≔']), ('≔', lang.ops.pop('≔')),
       (":=", lang.ops['󷸉']), ('󷸉', lang.ops.pop('󷸉')),
       (":=", lang.ops['󷸊']), ('󷸊', lang.ops.pop('󷸊')),
       (":=", lang.ops['󷸋']), ('󷸋', lang.ops.pop('󷸋'))]
new_ops = {}
for k, v in sel:
    new_ops[k] = OP(k, "B=", IG, lang.ops["␀ASGN_MRK_R"].R, v.f)
lang.ops |= new_ops
for k, v in lang.ops.items():
    if k in IG: continue
    v.R |= set(new_ops)
lang.ops["≕"] = OP(k, "B=", lang.ops["␀ASGN_MRK_L"].L, IG, v.f)
lang.ops["󷸎"] = OP(k, "B=", lang.ops["␀ASGN_MRK_L"].L, IG, v.f)
lang.ops["󷸌"] = OP(k, "B=", lang.ops["␀ASGN_MRK_L"].L, IG, v.f)
lang.ops["󷸍"] = OP(k, "B=", lang.ops["␀ASGN_MRK_L"].L, IG, v.f)

# janky? we need test cases broooo
lang.ops["⬅"].R |= {"→", "⭢"}
lang.ops["←"].R |= {"⭢"}

«««««««««««««««««««««««««««««««««« OPERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

⨡ᴺᴾ󰁔
;ᴺᴾ󰁔 ,ᴺᴾ󰁔
=ᴺᴾ󰁔 ⮂ᴺᴾ󰁔 ↪ᴺᴾ󰁔 ⮌ᴺᴾ󰁔 ↺ᴺ󰁔 ⇥ᴺ󰁔 ➰ᴺᴾ󰁔 ∀ ␛
     ⠤ᴾ󰁔󰁞 ⠶ᴾ󰁔󰁞 :ᴮᴾᴺ󰁏󰁔
␀ARW_1ᴵᴮ
⭝ᴺᴮᴵ󰁜 ␉ ⭜ᴮᴵ󰁜
␀ARW_2ᴵᴮ
¡ᴮᴵ󰁜 ␉ ⸘ᴺᴾ󰁔 ¿ᴺᴮᴵ󰁜
␀ASGN_MRK_Lᴮ ≔ᴮ󰁜 󷸉ᴮ󰁜 󷸊ᴮ󰁜 󷸋ᴮ󰁜 ␀ASGN_MRK_Rᴮ ␛
             ≕ᴮ󰁜 󷸎ᴮ󰁜 󷸌ᴮ󰁜 󷸍ᴮ󰁜
␀ARW_3ᴵᴮ
⨳ᴮᴾ󰀒ᴺ
∨ᴮᴺ ⩔ᴮᴺ 󷺥ᴮᴺ 󷺫ᴮᴺ 󷺤ᴮᴺ 󷺦ᴮᴺ
∧ᴮᴺ ⩓ᴮᴺ 󷺒ᴮᴺ 󷺬ᴮᴺ
≡ᴮᴺ󰁖󰁍 ==ᴮᴺ󰁖󰁍 !=ᴮᴺ󰁖󰁍 ≠ᴮᴺ󰁖󰁍 ∣ᴮᴺ󰁖  ∤ᴮᴺ󰁖         ␛
      <=ᴮᴺ󰁖󰁍  ≤ᴮᴺ󰁖󰁍 <ᴮᴺ󰁖󰁏 >ᴮᴺ󰁖󰁏 ≥ᴮᴺ󰁖󰁍 >=ᴮᴺ󰁖󰁍 ␛
       ⊄ᴮᴺ󰁖   ⊊ᴮᴺ󰁖  ⊂ᴮᴺ󰁖  ⊃ᴮᴺ󰁖  ⊋ᴮᴺ󰁖   ⊅ᴮᴺ󰁖  ␛
       ∉ᴮᴺ󰁖   ∈ᴮᴺ󰁖  ∋ᴮᴺ󰁖  ∌ᴮᴺ󰁖
␀TACᴮ
ꟿᴮᴺ ᴍᴮᴺ    ᴮᴾ󰀒ᴺ󰁢 ſᴮᴺ󰁢   Ϝᴮᴺ󰁢   ⨀ᴮᴾ󰀒ᴺ󰁢 ⨁ᴮᴾ󰀒ᴺ󰁢 ␛
    󰈲ᴮᴾ󰀒ᴺ󰁢 󰈳ᴮᴾ󰀒ᴺ󰁢 󰒼ᴮᴾ󰀒ᴺ󰁢 󰒽ᴮᴾ󰀒ᴺ󰁢 ᴮᴾ󰀒ᴺ         ␛
    ᙎᴮ󰀒ᴺ󰁢  ᙡᴮ󰀒ᴺ󰁢  ᗢᴮ󰀒ᴺ󰁢  ᙧᴮ󰀒ᴺ󰁢 
∘ᴮᴺ ○ᴮᴺ ⍜ᴮᴺ 󰬫ᴮᴺ 󰬩ᴮᴺ 󱖚ᴮᴺ 󱖘ᴮᴺ 󰀒ᴺ   ᣆᴮᴾ󰀒ᴺ ␛
    ⊚ᴮᴾ󰀒ᴺ ⊛ᴮᴾ󰀒ᴺ ⍟ᴮᴾ󰀒ᴺ ⊜ᴮᴾ󰀒ᴺ 🟕ᴮᴾ󰀒ᴺ 🟖ᴮᴾ󰀒ᴺ ␛
    ᴮᴾ󰀒ᴺ 󰔶ᴮᴾ󰀒ᴺ ᴮᴾ󰀒ᴺ
ᐹᴮᴾ󰀒ᴺ󰁖 ᐴᴮᴾ󰀒ᴺ󰁖 󷹵ᴮᴺ󰁖 󷹴ᴮᴺ󰁖 󱑼ᴮᴾ󰀒ᴺ󰁢 󷹅ᴮᴾ󰀒ᴺ󰁢 ᴮᴾ󰀒ᴺ󰁘󰁢 󱅏ᴮᴾ󰀒ᴺ󰁘󰁢 ᴮᴾ󰀒ᴺ󰁘󰁢
|ᴮᴺ ␉ ^ᴮᴺ ␉ &ᴮᴺ
<<ᴮᴺ >>ᴮᴺ ⪡ᴾ󰀒ᴮᴺ ⪢ᴾ󰀒ᴮᴺ
∓ᴾᴮᴺ ±ᴾᴮᴺ +ᴾᴮᴺ -ᴾᴮᴺ
◄ᴮᴺ󰁏 ►ᴮᴺ󰁏
⋄ᴮᴺ
∪ᴮᴺ ␉ ∩ᴮᴺ ␉ ⨉ᴾ󰀒ᴮᴺ ⊞ᴾ󰀒ᴮᴺ ∖ᴮᴺ
//ᴮᴺ /ᴮᴺ    *ᴮᴺᴾ󰁞 ␛
     ≅ᴮᴺ󰁍   ≇ᴮᴺ󰁍   ⋅ᴮᴺ    ÷ᴮᴺ   ⹏ᴮᴺ    %ᴮᴺ  ␛
     ⋀ᴾ󰀒ᴺ   ⋁ᴾ󰀒ᴺ   ⫰ᴾ󰀒ᴺ   ⫯ᴾ󰀒ᴺ  @ᴮᴾᴺ󰁞  √ᴾᴺ  ␛
     ⟕ᴮᴾ󰀒ᴺ  ⨝ᴮᴾ󰀒ᴺ  ⟗ᴮᴾ󰀒ᴺ  ⟖ᴮᴾ󰀒ᴺ !󰀒ᴺ󰁏   ☾ᴾ󰀒ᴺ ␛
     󷸹ᴮᴾ󰀒ᴺ  󷸸ᴮᴾ󰀒ᴺ  󷸻ᴮᴾ󰀒ᴺ  󷸺ᴮᴾ󰀒ᴺ ⍭ᴾ󰀒ᴺ   ⍉ᴾ󰀒ᴺ ␛
     󷹓ᴮᴺ󰀒   󰑅ᴮᴺ󰀒   󷹔ᴮᴺ󰀒   󷹕ᴮᴺ󰀒󰁢 󷹖ᴮᴺ󰀒󰁢  ⛶ᴾ󰀒ᴺ ␛
     ⬓ᴾ󰀒ᴺ   ▢ᴮᴾ󰀒ᴺ  ⬒ᴾ󰀒ᴺ   󰸵ᴮᴺ   󰸷ᴮᴺ    🃌ᴾ󰀒ᴺ ␛
     ⤈ᴮᴾ󰀒ᴺ󰁢 󷹄ᴮᴾ󰀒ᴺ󰁢 ⤉ᴮᴾ󰀒ᴺ󰁢 ↨ᴾ󰀒ᴺ  ⭥ᴾ󰀒ᴺ   ⴵᴾ󰀒ᴺ ␛
     󷹌ᴮᴾ󰀒ᴺ  󷹍ᴮᴾ󰀒ᴺ  󷹎ᴮᴾ󰀒ᴺ  𝌂ᴮᴾ󰀒ᴺ ᴙᴾ󰀒ᴺ   ᚤᴮᴾ󰀒ᴺ␛
     ⬄ᴮᴾ󰀒ᴺ  󰌷ᴮᴾ󰀒ᴺ  󰛔ᴮᴾ󰀒ᴺ󰁢 󷹝ᴾ󰀒ᴺ󰁢 󷹜ᴮᴾ󰀒ᴺ󰁢      ␛
     󷸚ᴾ󰀒ᴺ   󷸛ᴾ󰀒ᴺ   󷸙ᴾ󰀒ᴺ   󷸘ᴾ󰀒ᴺ  󷸜ᴾ󰀒ᴺ   󷸗ᴾ󰀒ᴺ 󷸖ᴾ󰀒ᴺ 󷸕ᴾ󰀒ᴺ 
¬ᴾ󰀒ᴺ󰁜 ¯ᴾᴺ
␀CATᴮᴺ
**ᴵᴮᴾ󰁞 …ᴮᴺ ⌃ᴵᴮᴺ
ᴵᴾᴺ ∾ᴵᴾᴺ ᴺ󰀒
󰻾ᴺ ℵᴺ ℶᴺ ∅ᴺ󰁘 ⍁ᴺ󰁘
.ᴮ󰁏󰁔
...ᴺ

      ｜  ␀TACITᴺ󰀒󰁏󰁜  ｜
␀TAC  ｜ ␀TACITLᴺ󰀒󰁏󰁜  ｜
      ｜ ␀TACITRᴺᴾ󰁏󰁜  ｜␀TAC
␀TAC  ｜␀TACITLRᴺᴾ󰀒ᴮ󰁏󰁜｜␀TAC
      ｜          ⬅ᴾ󰁏󰁜｜␀ARW_1
␀ARW_1｜          ➡󰀒󰁏󰁜｜
      ｜          ←ᴾ󰁏󰁜｜␀ARW_2
␀ARW_2｜          ⥉ᴮ󰁏󰁜｜␀ARW_2
␀ARW_2｜          →󰀒󰁏󰁜｜
      ｜          ⭠ᴾ󰁏󰁜｜␀ARW_3
␀ARW_3｜          ⭢󰀒󰁏󰁜｜

«««««««««««««««««««««««««««««««««« GRAMMAR »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

parser_main = exprs
parser_comment = (⠶str ∨ 󰆴comment ∨ ~‹.|\n›)*

exprs = 𝗪? (⠶expr 𝗪?)*
expr = (
    (kw_pfx_colon_expr =  ⠶vkw_pfx_colon 󰆴Æ? (expr_not_colon? 󰆴Æ? 󰆴':') M:✓ 󰆴E? expr?)
        ∨ (kw_pfx_expr =  ⠶vkw_pfx 󰆴E? expr?)
          ∨ (norm_expr = (⠶norm_expr_atom)+))

expr_not_colon = (¬':' ⠶norm_expr_atom)+
expr_not_comma = (¬',' ⠶norm_expr_atom)+

vkw_pfx_colon = ⮞kw_spec kw_pfx_colon ∨ kw_pfx_colon ⮞text_breaker
vkw_pfx       = ⮞kw_spec kw_pfx       ∨ kw_pfx       ⮞text_breaker
vkw           = ⮞kw_spec kw           ∨ kw           ⮞text_breaker

norm_expr_atom = (⠶lambs ∨ ⠶gen_expr_atom) 󰆴E?
gen_expr_atom = group ∨ ⠶str ∨ var_spec ∨ number ∨ oper ∨ ⠶vkw ∨ ⠶script ∨ var
number = pos_num ∨ neg_num
pos_num = ƨ(~‹0([bB][01]+|[oO][0-7]+|[xX][0-9a-fA-F]+)|([0-9]+(\.[0-9]*)?|[0-9]*\.[0-9]+)(e[+\-]?[0-9]+)?›)
neg_num = ƨ(~‹󷰽([󷱈󷱐][󷰽󷰾]+|[󷱍󷱕][󷰽-󷱄]+|[󷱎󷱖][󷰽-󷱆󷱇-󷱌󷱏-󷱔]+)|([󷰽-󷱆]+(\.[󷰽-󷱆]*)?|[󷰽-󷱆]*\.[󷰽-󷱆]+)(󷱋[+\-]?[󷰽-󷱆]+)?›)

var = ƨ(¬𝗪 ¬oper ¬var_spec ¬script ¬(~‹󰦥{5}›) ~‹[^⟥⟤⭡⭣𝗮-𝘇󷺗ᐸᐳᑅᑀᐘᐒᑈᐵᐛᐖ󷺹-󷻀𝚲⥌↦󰲡󰲣󰲥󰲧󰲩󰲫󰅂$"'\[\](){}⁅⁆⟦⟧⟨⟩‹ ␛␛␛›]›)+

group = ~‹[\[({⁅⟦]› (𝗪? ↷ exprs) ~‹[\])}⁆⟧]›

script = ((supscript = ƨ(SUPSCRIPT)) ∨ (subscript = ƨ(SUBSCRIPT)))

oper = (
    (oper_mod_l = ~‹[⟥≺]*›)
     oper_lit
    (oper_mod_r = ƨ((~‹[´꜠ᵜ𐞑⟤]+› ∨ supscript)*)))

lambs = lamb_tacit ∨ lamb
lamb = (
    (   (lamb_h_py = 󰆴"lambda" ⮞text_breaker 󰆴Æ ⠶expr_not_colon 󰆴':')
      ∨ (lamb_h_normal = (
            󰆴('⥌' Æ?)
            ((¬lamb_h_implicit lamb) ∨ ⠶gen_expr_atom 󰆴Æ?)*
            󰆴'↦' ))
      ∨ (lamb_h_preset = ~"[𝚲󰲡󰲣󰲥󰲧󰲩󰲫]")
      ∨ (lamb_h_implicit = var 󰆴(Æ? '↦'))) 󰆴Æ?
    (lamb_b = ((exprs 󰆴'󰅂') ∨ expr_not_comma)))
lamb_tacit = (
      (⠶LTL exprs ⠶LTR)
    ∨ (⠶LTL expr_not_comma ✓ ✓))
LTL = (‹⟥›∨✓) ~‹[ᐳᑀᐒᐵᐖ󷺹󷺻󷺺󷺼]› 󰆴Æ?
LTR = ~‹[ᐸᑅᐘᑈᐛ󷺽󷺿󷺾󷻀]› (‹⟤›∨✓)

str = str_star ∨ Ʀsection ∨ str_cpy ∨ str_$ ∨ str_py ∨ str_escape ∨ str_spec_char
str_$ = 󰆴('$' 𝘄?) (ƨ(supscript) ∨ ✓) 󰆴𝘄? (⠶str_cpy_inner ∨ '›')* 󰆴(𝘄? '󷹹')
str_star = (󰆴(~‹󰦥{5}›)) ~‹((?!󰦥{5})(.|\n))*› 󰆴((~‹󰦥{5}›) ∨ ✓)
str_cpy = 󰆴'‹' (⠶str_cpy_inner ∨ '󷹹')* 󰆴'›'
str_cpy_inner = (str_escape ∨ str_sub ∨ str_spec_char ∨ str_guts)
str_sub = 󰆴'⟦' exprs 󰆴'⟧'
str_spec_char = ~‹[𝗮-𝘇󷺗]›
str_guts = ~"[^𝗮-𝘇󷺗⟦␛␛›󷹹]+"
str_escape = 󰆴"␛␛" ~‹.›
str_py = ((‹"› (str_py_sub ∨ ~‹[^"\\]+›)* ‹"›)
       ∨  (‹'› (str_py_sub ∨ ~‹[^'\\]+›)* ‹'›))

str_py_sub = ~‹\\.›

Ʀexpr = (⠶Ʀatom ∨ Ʀop ∨ 󰆴𝗪)*
Ʀatom = Ʀsection ∨ Ʀrange ∨ ƦESC ∨ ƦCHR

Ʀrange   = 󰆴(‹⁅› 𝗪?) (Ʀcharset ∨ Ʀrchar)+ 󰆴(𝗪? ‹⁆›)
Ʀsection = 󰆴(‹⟨› 𝗪?) Ʀmat_name (󰆴𝗪? ↷ Ʀmat_body) Ʀmat_func 󰆴(𝗪? ‹⟩›)

Ʀmat_name = ƨ((󰆴𝗪 ∨ ƦESC ∨ ƦCHR)*) 󰆴‹⭡› ∨ ✓
Ʀmat_body = Ʀexpr
Ʀmat_func = 󰆴‹⭣› exprs ∨ ✓

Ʀcharset = ⠶Ʀrchar ↷ 󰆴(𝗪? ↷ "…")
Ʀrchar = ⠶ƦESC ∨ ~‹[^…⁆]›

Ʀop = Ʀrrepeat ∨ ~‹[→¿⌐⨁⨀∨]›
Ʀrrepeat = (  󰆴(‹⟮› 𝗪?) (
                ((ƦINT∨✓) ↷ 󰆴(𝗪? ↷ ‹,›))
                ∨ ƦINT
           ) 󰆴(𝗪? ‹⟯›) )

ƦESC = 󰆴"␐" ~‹.›
ƦINT = ~‹[0-9]+›
ƦCHR = ~‹[^ \n\t⭣⭡⁅⁆⟨⟩⟮⟯∨→⌐¿⨁⨀]›

𝘄 = ~‹([ \t]*␛␛\n[ \t]*)+|[ \t]+›
𝗪 = ~‹[ \t\n]+›
text_breaker = ⮞(E ∨ kw_spec ∨ var_spec ∨ ¬var)
E = 𝘄 ∨ ~‹␛␛\n›
Æ = 𝗪 ∨ ~‹␛␛\n›

comment = ~‹((|#)[^\n]*(?=\n|\Z))|(🟑[^🟑]*(🟑|\Z))|(֎[^֎]*(֎|\Z))›

«««««««««««««««««««««««««««««««««« GENERATORS »»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»»

# § tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

def σ_00():
    TL, TR = ᔐ.maketrans("󷺹󷺺󷺻󷺼","ᑀᐵᐒᐖ"), ᔐ.maketrans("󷺽󷺾󷺿󷻀","ᑅᑈᐘᐛ")
    
    @(yield replacement("lamb_tacit", rec='A', n="Reform tacit exprs"))
    def _(n):
        bl, l, λ, r, br = n
        bl, l,    r, br = bl.as_txt(), l.as_txt(), r.as_txt(), br.as_txt()
        if λ.t in {"exprs", "expr", "expr_norm"}:
            α, β = λ[0].c, λ[-1].c 
        else:
            α = β = λ.c
        
        if l in "󷺹󷺻󷺺󷺼": bl, l = ⴳ, l.translate(TL)
        if r in "󷺽󷺿󷺾󷻀": br, r = ⴳ, r.translate(TR)
        
        l, r = l or (r and "ᐳ" or "ᑀ"), r or "ᐸ"
        
        args, targs = [], [NUM_M1, NUM_M1]
        OP_NAME = "␀TACIT"
        
        if l and l in "ᑀᐵᐒᐖ":
            if not bl: OP_NAME += "L"
            if l in "ᑀᐵ": α.insert(0, TACTACK_L)
            targs[0] = NUM_P1 if (l in "ᐵᐖ") else NUM_P0
            args.append(TACTACK_L)
        if r and r in "ᑅᑈᐘᐛ":
            if not br: OP_NAME += "R" 
            if r in "ᑅᑈ": β.append(   TACTACK_R)
            targs[1] = NUM_P1 if (r in "ᑈᐛ") else NUM_P0
            args.append(TACTACK_R)
        
        COM = OP.TND(',')
        args, targs = J́(args, COM), J́(targs, COM, l=ⴳ)
        
        if args: args.append(COM)
        args.extend([OP.TND("⠤"), mkvar("𝓐"), COM,
                     OP.TND("⠶"), mkvar("𝓚")])
        
        return Ń("oper",
            ("oper_mod_l", ᐦ), ("oper_lit", OP_NAME),
            ("oper_mod_r", mkgxp(
                ("lamb", ("lamb_h_normal", *args),
                         ("lamb_b", ("norm_expr", λ))),
                *targs)))

def σ_03():
    @(yield replacement(*KEYWORD_NODE_NAMES, n="Lang keywords → cpy keywords"))
    def _(n):
        txt = n.as_txt()
        # keyword that are just ops:
        if txt in kw_inline: return OP.TND(KEYWORDS_TO_CPY.get(txt, txt))
        return n.copy(c=KEYWORDS_TO_CPY.get(txt, txt))
    
    @(yield reduction("supscript", n="Swap Superscripts"))
    def _(n):
        t = gram(SCRIPT.nrm(n.as_txt()), "exprs")
        txt = t.as_txt()
        T = lang(txt.strip())
        if not T.isidentifier() or T in escaped_var_specs:
            return [OP.TND('⌃'), mkgxp_(Node(c=lang(txt)))]
        return [OP.TND('.'), t]
    
    ((yield replacement("subscript", rec='A', n="Subscripts to brackets"))
    (lambda n: mkgrp(tree_transform(gram(SCRIPT.nrm(n.c), "exprs"), 3+1), b="[]")))
    
    ((yield replacement("norm_expr", "expr_not_colon", "expr_not_comma", rec='B',
                        n="Normalize expression types"))
    (lambda n: n.copy("expr")))
    
    ((yield replacement("W", n="Trim whitespace"))
    (lambda n: n.copy(c=ń in n.c and ń+ⵉ(n.c,ń)[-1] or n.c)))

def σ_05():
    op_chk = lambda n, o: n.t == "oper" and n.as_txt() == o
    hs_op = lambda C, o: ⴸ(op_chk(c, o) for c in C)

    @(yield replacement("expr", rec='A', n="Detect for_expr"))
    def _(N):
        if not hs_op(C := N.C, '∀'): return N
        
        α, _, β = part(C, ρ(op_chk, o='∀'))
        β, _, γ = part(β, ρ(op_chk, o='∈'))
        if hs_op(γ, '¿'):
            γ, _, σ = part(γ, ρ(op_chk, o='¿'))
        else:
            σ = None
        
        cc = [Node("expr", α), Node("expr", β), Node("expr", γ)]
        if σ: cc.append(Node("expr", σ, e="cond"))
        return N.copy("for_expr", c=cc)
    
    @(yield replacement("kw_pfx_colon_expr", rec='A', n="Detect for_stmt"))
    def _(N):
        if not op_chk(N.C[0], '∀'): return N
        α, _, β = part(N.C[1].C, ρ(op_chk, o='∈'))
        return N.copy("for_stmt", c=[Node("expr", α), Node("expr", β), *N.C[2:]])

def σ_10():
    ((yield replacement("parser_main", rec='A', n="Build whitespace blocks"))
    (whitespace_parser))

def σ_15():
    yield "Refactor lambdas"
    ((yield replacement("lamb_h_preset"))
    (lambda n: Ń("lamb_h",
            *ᴍ(lambda t: mkexp(mkvar(t)), "xyzwvutsr"[:"𝚲󰲡󰲣󰲥󰲧󰲩󰲫󰲭󰲯󰲱".index(n.c)]),
            ARG_A, ARG_K)))
    
    ((yield replacement("lamb_h_implicit"))
    (lambda n: Ń("lamb_h", mkexp(n.C[0]), ARG_A, ARG_K)))
    
    @(yield replacement("lamb_h_normal", "lamb_h_py"))
    def _(n):
        C = ᴍ(Node.strip,
              ꟿ(mkexp,
                 split_at(
                    n.C,
                    lambda x: OP.is_op(x) and (k:=op_man[x]).t == ',')))
        has_a = has_k = ⴴ
        
        C = ᖵ(lambda x: x.as_txt(), C) # b/c ⥌↦ has empty an expr
        for c in C:
            if not c.C or (o:=c.C[0]) != "oper": continue
            k = o.C[1].c
            if   k in ( "*", "⠤"): has_a = ⴳ
            elif k in ("**", "⠶"): has_k = ⴳ
            else                 : continue
            if len(c) == 1:
                c.C[0] = Ń("expr_", '*'+'*'*(k=="**" or k=='⠶'))
        if not has_a: C.append(ARG_A)
        if not has_k: C.append(ARG_K)
        return Ń("lamb_h", *C)
    
    ((yield replacement("lamb_b", rec='A'))
    (lambda n: n.copy(t="expr")))

def σ_18():
    @(yield replacement("expr", rec='B', n="Implicit Multiplication"))
    def _(n):
        if not n.C: return n
        cc, s = [], peekable(n.C)
        while True:
            α = next(s)
            if not s: break
            β = s.peek()
            cc.append(α)
            
            S = { "number": {"var", "group", "var_spec", "number"},
                  "var_spec": {"number", "var", "var_spec"} }
            # 󰤱 condition for 2√2
            if    α.t in S and β.t in S[α.t] \
               or β.t in S and α.t in S[β.t] \
               or α.t == "group" and β.t == "var_spec": # 󰤱 this is weird
                    cc.append(OP.TND("␀CAT"))
        cc.append(α)
        return n.copy(c=cc)

def σ_19():
    @(yield replacement("expr", rec='B', n="Add dummy variables"))
    def _(n):
        c, i = n.c, 0
        while i < len(c):
            x = c[i]
            if x.t == "oper":
                txt = x.c[1].as_txt()
                if   txt in "󷸊󷸋": c[i+1:i+1] = [mkvar("␀DUM")]
                elif txt in "󷸌󷸍": c[i  :i  ] = [mkvar("␀DUM")]
                else:
                    i += 1
                    continue
                i += 1
            i += 1
        return n

def σ_20():
    ((yield replacement("expr", rec='B', n="Parse expressions"))
    (lambda n: n.copy(c=into_expr(parse_expr(n.C)).c)))

def σ_21():
    def split_target(l):
        l, t = l.copy(), []
        while l:
            α = l.pop()
            if α == '.':
                return '.', l, t[0]
            if α.t == "op_call":
                assert α.C[1].as_txt() == '.'
                l.extend([*α.C[0], '.', *α.C[2]])
                continue
            if α.t == "group" and (α.C[0].as_txt(), α.C[2].as_txt()) == ('[', ']'):
                return 'l', l, α.C[1]
            t.insert(0, α)
        assert ⵌ(t) == 1
        return ᐦ, ᗜ, t[0]

    # x󷸊🃌 ⟶ ►(GI(x↑,y↑)↑, SI(↓􍧞,↓􍧰,🃌↓))
    # 🃌󷸌x ⟶ ►(GI(x↑,y↑)↑, SI(↓􍧞,↓􍧰,↓🃌))
    # x󷸋🃌 ⟶ ◄(GI(x↑,y↑)↑, SI(↓􍧞,↓􍧰,🃌↓))
    # 🃌󷸍x ⟶ ◄(GI(x↑,y↑)↑, SI(↓􍧞,↓􍧰,↓🃌))
    
    def make_inline_asgn(α, Σ, β): # optimization: pull out some constant nodes
        # 󰤱􊽨 ≕ and stuff should do eval b4 var ref?
        (τ, κ, χ), σ = split_target(α.C), Σ.as_txt()
        if τ:
            ρ = "ATTR" if τ == '.' else "ITEM"
            κ = mkgxp(*(Node("expr_", '.') if i == '.' else i for i in κ))
            χ = mkgxp(("str_", f'"{py_escape_var(χ.as_txt())}"') if ρ == "ATTR" else χ)
            ST, GT = mkvar("SET"+ρ), mkvar("GET"+ρ)
        
        # https://ganer.xyz/s/b92fe70c1a9eb090 https://ganer.xyz/s/584893fc23aafb70
        if σ in "󷸊󷸋󷸌󷸍":
            outer = mkvar("RET_"+('L' if σ in "󷸋󷸍" else 'R'))
            find_dum = lambda n: n.t == "var" and n.as_txt() == "␀DUM"
            if τ:
                larg = fcall_(þPSH, fcall_(GT, fcall_(þPSH, κ), fcall_(þPSH, χ)))
                rarg = fcall_(ST, þPOP_M3, þPOP_M2, β.find_replace(find_dum, lambda n: þPOP_M1), NUM_P0)
                return fcall_(outer, larg, rarg)
            v = mkgrp(mknex_(χ, mkgxp(β.find_replace(find_dum, lambda n: χ))))
            return fcall_(outer, χ, v) if σ in "󷸋󷸍" else v
        if σ in "󷸉󷸎": # https://ganer.xyz/s/bd0de51c7f02dac6
            if not τ:
                larg = fcall_(ST, þPOP_M3, þPOP_M2, β, NUM_P0)
                rarg = fcall_(þPSH, fcall_(GT, fcall_(þPSH, κ), fcall_(þPSH, χ)))
                return fcall_(mkvar("RET_L"), larg, rarg)
            return fcall_(ST, κ, χ, β, NUM_P0)
        
        if not τ:
            v = β if σ in {*"≔≕", ":="} else ("op_call", mkexp(χ), Σ, β)
            return mkgrp(mknex_(χ, mkgxp(v)))
        
        if σ in {*"≔≕", ":="}:
            return fcall_(ST, κ, χ, β, NUM_P0)

        return fcall_(ST, # +=, ſ=, etc…
            fcall_(þPSH, κ),
            fcall_(þPSH, χ),
            Node("op_call", [
                fcall_(GT, þPOP_M2, þPOP_M1), Σ, β]),
            NUM_P0)
        
    
    @(yield replacement("op_call", rec='A', n="Refactor assignment infix opertators"))
    def _(n):
        α, Σ, β = n.C
        if Σ.c[0].as_txt() or Σ.c[2].as_txt(): return n # 󰤱 allow mods
        
        σ = Σ.as_txt()
        if σ in {*"≔󷸊󷸋", ":="}: return make_inline_asgn(α, Σ, β)
        if σ in {*"≕󷸌󷸍"      }: return make_inline_asgn(β, Σ, α)
        if '=' not in lang.ops[σ]: return n
        Σ = OP.TND(σ[:-1])
        return make_inline_asgn(α, Σ, β)

def σ_25():
    @(yield reduction("op_call", rec='B', n="Flatten cmp ops"))
    def _(n):
        if 'λ' in op_man[n.C[1]] and \
                n.C[0] != NULL and n.C[2] != NULL:
            return [*n.C[0].C, n.C[1], *n.C[2].C]
        return [n]

def σ_30():
    def make_cmp_chain(n, layers=ᗜ):
        layers = layers or OPS_COMP
        layer, *layers = layers
        
        rec = lambda n: layers and make_cmp_chain(n, layers=layers) or n
        mkexp_rec = lambda N: rec(mkexp(*N))
        
        C = ᒪ(split_at(n.C,
            lambda x: OP.is_op(x) and (k:=op_man[x]).t in layer and k.B,
            keep_separator=ⴳ))
        if ⵌ(C) < 3: return rec(n)
        r = ⴴ
        
        for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
            # if b[1].c == '∨' and ⵌ(C) > 3:
            #     b[1].c = '⩔'
            c = mkexp_rec(c)
            v = mkexp(("op_call",
                H and mkexp_rec(a) or þþ,
                b,
                T and c or mknex_(þþ, c)))
            r = mkexp(("op_call", r, OP.TND('∧'), v)) if r else v
        return n.copy(c=[r])
    ((yield replacement("expr", rec='B', n="Generate comparison chains"))
    (make_cmp_chain))

demodp = lambda o: (o.C[0].as_txt(), o.C[1], o.C[2].as_txt() if o.C[2].S else o.C[2])
def mkbltnop(op_l): # format builtins if needed
    t = SWAP_TABLE.get(t := op_l.as_txt(), t)
    if t not in OPS_BUILTIN['A']: return op_l
    return mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
def transform_oper(op_): # apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    # if op_l in "¿¡⭜⭝": # 󰤱
    if not (m_l or m_r): return op_l
    op_n = mkbltnop(op_l)
    mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
    
    if '≺' in m_l: op_n = mkmod(op_n, "BSTAR")
    if '⟥' in m_l: op_n = mkmod(op_n, "LNULL")
    
    if isinstance(m_r, Node): return mkexp(op_n, mkgxp(m_r, b="[]"))
    rmods = ᐦ
    for m in m_r:
        if m in "⟤ᵜ꜠´":
            match m:
                case '⟤': op_n = mkmod(op_n, "RNULL")
                case 'ᵜ': op_n = mkmod(op_n, "SWAPA")
                case '꜠': op_n = mkmod(op_n, "DUPER")
        else:
            rmods += m
    if rmods:
        o = set() if 'χ' in op_man[op_] else ascii_uppercase
        rmods = ᒍ(',', (f'"{x}"' if frozenset(x).issubset(o) else lang(x) \
                    for x in SCRIPT.nrm(rmods).split('𐞑')))
        op_n = mkexp(op_n, Node("expr_", f'[{rmods}]'))
    return op_n

def σ_35():
    hnul = lambda x: x.copy("NULL_") if x == "NULL" else x
    
    def try_builtin(m, op_l, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
        if m_l or m_r: return
        if SWAP_TABLE.get(t, t) not in OPS_BUILTIN[m]: return
        return mkgxp(*ε(L), op_l, *ε(R))

    def make_if(t, l, r, m_l, m_r):
        return Ń(t, l, r, m_l, m_r)
    def make_el(t, l, r, m_l, m_r):
        assert l[0].t in "⭜¿"
        if t=='⭝': return mkgxp(l[0][1], OP.TND('¿'), l[0][0], OP.TND('¡'), r)
        if t=='¡': return mkgxp(l[0][0], OP.TND('¿'), l[0][1], OP.TND('¡'), r)

    @(yield replacement("op_call", rec='B', n="Refactor op calls"))
    def _(n):
        l, op_, r = n.C
        op = op_man[op_]
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
        
        if not (m_l or m_r):
            if 'β' in op and     L and R: return mkgxp(L, op_l, R)
            if 'σ' in op and not L and R: return mkexp(op_l, r)
            if 'ι' in op: return mkexp(hnul(l), op_l, hnul(r))
            if 'ρ' in op:
                if t in '➡→⭢'           : return L
                if t in '⬅←⭠'           : return R
                if t in '≔󷸉'            : return mkgxp(l, op_l, R)
                if t in '≕󷸎'            : return mkgxp(l, op_l, R)
                if t == '⥉'             : return mkgxp(R, L)
                if t == '¬' and (L or R): return mkgxp(op_l, L or R)
        if t in '⭜¿'            : return make_if(t, l, r, m_l, m_r)
        if t in '⭝¡'            : return make_el(t, l, r, m_l, m_r)
        if t == "󷺥": # x⭜✗⭝y⭜x⭝✓
            return mkgxp(
                FALSE,
                    OP.TND('¿'),
                fcall_(þPSH, 𝓛),
                    OP.TND('¡'),
                mkgxp(
                    þPOP_M1,
                        OP.TND('¿'),
                    𝓡,
                        OP.TND('¡'),
                    mkgxp(þPOPNR, Ń("oper_lit", '∨'), TRUE)))
        if t == "󷺒": # x⭜(y⭜✗⭝x)⭝✓
            return mkgxp(
                mkgxp(
                    mkgxp(þPOPNR, Ń("oper_lit", '∨'), FALSE),
                        OP.TND('¿'),
                    𝓡,
                        OP.TND('¡'),
                    þPOP_M1
                ),  OP.TND('¿'),
                fcall_(þPSH, 𝓛),
                    OP.TND('¡'),
                TRUE)
        
        A = (transform_oper(op_), L, m_l, t, m_r, R)
        tb, mblo = try_builtin, mkbltnop
        if op.S and L       and not op.B: return tb('S', *A) or mkexp(mblo(op_), L)
        if op.P       and R and not op.B: return tb('P', *A) or mkexp(mblo(op_), R)
        if op.B and L and R             : return tb('B', *A) or mkexp(mblo(op_), mkgxp(   l, COMMA,    r))
        if op.S and L                   : return tb('S', *A) or mkexp(mblo(op_), mkgxp(   l, COMMA, NULL))
        if op.P       and R             : return tb('P', *A) or mkexp(mblo(op_), mkgxp(NULL, COMMA,    r))
        if op.N and 'ν' in op           : return mkexp(mblo(op_), mkgxp())
        return mkbltnop(op_)

def σ_36():
    @(yield replacement("⭜", rec='B', n="Refactor elseless ⭜"))
    def _(n):
        return mkgxp(n[1], OP.TND("¿"), n[0], OP.TND("¡"), mkvar("None"))

def σ_40():
    @(yield replacement("oper", rec='A', n="Refactor sitting ops"))
    def _(n):
        if n.C[1].as_txt() in kw_neverswouce: return n
        if not (n.C[2].as_txt() or n.C[0].as_txt()):
            n = n.copy(c=[n.C[0], n.C[1], n.C[2].copy(c="´")])
        return transform_oper(n)
    
    ((yield replacement(*KEYWORD_NODE_NAMES, "oper_lit",
                        n="Lang keywords ← cpy keywords"))
    (lambda n: n.copy(c=py_escape_var(SWAP_TABLE.get(txt:=n.as_txt(), txt)))))
    
    ((yield replacement("lamb", rec='B', n="Format lambda"))
    (lambda n: mkgxp(n.C[0], mkgrp(n.C[1]))))
    
    ((yield replacement("lamb_h", rec='B', n="Format lambda header"))
    (lambda n: Ń("lamb_h", ("kw", "lambda"), *J́(n.C, COMMA), ("oper_lit", ":"))))

def σ_45():
    ((yield replacement("parser_main", rec='A', n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((yield reduction("BLOCK", rec='B', n="Flatten blocks"))
    (lambda n: n.C))

def σ_48():
    ((yield replacement("for_expr", rec='B', n="Build for exprs"))
    (lambda n: Ń(
        "expr",
        n.C[0], ("kw", "for"), n.C[1], ("kw", "in"), n.C[2],
        *([("kw", "if"), n.C[3]] if n['cond'] else []))))
    
    ((yield replacement("for_stmt", rec='B', n="Build for stmt"))
    (lambda n: Ń(
        "kw_pfx_colon_expr",
        ("kw_pfx_colon", "for"),
        ("expr", n.C[0], ("kw", "in"), n.C[1]),
        *n.C[2:])))

def σ_50():
    ((yield replacement("kw_pfx_colon_expr", rec='B', n="Add colons"))
    (lambda n: n.insert_after_marker('M', COLON)))
    
    ((yield replacement("parser_main", rec='B', n="Insert spaces"))
    (ρ(add_spaces, ignore_nodes=("str_cpy", "str_py", "str_star", "str_$"))))

# §§§ node transpilers §§§
generator(*KEYWORD_NODE_NAMES, "oper_lit", "var", "var_spec")(lambda n: py_escape_var(n.as_txt()))
generator("NULL")(lambda n: "NULL")

@generator("group")
def gen_group        (n):
    txt = n.C[0].as_txt()
    if txt == '⟦': # broken mostly
        content = next(filter(ⵐ, ᴍ(gen, n.C[1:-1])))
        return f'''(exec("def _EXE():\\n{py_escape_string(force_indent(content))}",globals(),locals()),_EXE)[1]()'''
    return txt + ᒍ(ᐦ, ᴍ(gen, n.C[1:-1])) + n.C[-1].as_txt()

generator("str_guts"              )(lambda n: py_escape_string(n.as_txt()))
generator("str_escape", "str_star")(lambda n: "'" + py_escape_string(n.as_txt()) + "'")
generator("str_sub"               )(lambda n: "{" + gen(n.C[0]) + "}")
generator("str_spec_char"         )(lambda n: "'" + py_special_mapper(n.as_txt()) + "'")

def make_str_cpy(n):
    r='""f"'
    for c in n.c:
        if   c.t == "str_escape"   : r += py_escape_string(c.as_txt())
        elif c.t == "str_spec_char": r += py_special_mapper(c.as_txt())
        else                       : r += gen(c)
    return r + '"'

generator("neg_num")(lambda n: f"(-{UPSIDEDOWNSYNDROME.flip(n.as_txt())})")
generator("str_cpy")(make_str_cpy)

@generator("str_$")
def make_str_money(n):
    s, *C = n.c
    return f'SUBPROCA({make_str_cpy(n.copy(c=C))},"{py_escape_string(SCRIPT.nrm(s.as_txt()))}")'