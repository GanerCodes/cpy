# P/S/B/N: prefix/suffix/binary/nullary
# I: Include self in group (right asoc.)
# Î±: basic concat
# Î´: x <op>= y doesn't make sense
# Î½: NULL version self-calls
# Ï: *special*

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« HEADERS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

from whitespace_tools import *
from string import ascii_uppercase
from py_naming_tools import *
py_escape_var = lambda x, f=py_escape_var: f(x, 'NOVAR' not in CONST)

mkgrp = lambda *X, b="()": Åƒ("group", b[0], âµŒ(X)==1 and X[0] or X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkexp = lambda *X: Åƒ("expr", *X)
mkstr = lambda x: Åƒ("str", '"', x, '"')
mkvar = lambda x: Node("var", x)
mkexp_ = lambda *n: Node("expr_", á’ª(n))
mkgxp_ = lambda *n: mkgrp(mkexp_(*n))
fcall_ = lambda f,*n,E=[]: mkexp_(f, mkgxp_(*JÌ(n, COMMA)), *E)
mknex_ = lambda a, b     : mkexp_(a, EQCLN, b)

sst = lambda x  : set(á–µ(á—œ,á´(âµ,âµ‰(á–‡(x,'â‰',Å„),Å„))))
mdt = lambda y  : á–±(á´(âµ,âµ‰(x,Å›,1)) for x in sst(y))
inv = lambda z  : {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

COMMA, COLON, EQCLN = (Node("oper_lit", x) for x in âµ‰(", : :=", Å›))
Ã¾Ã¾ = mkvar("Ã¾Ã¾")

OPS_BUILTIN = {
    'S': á¦,
    'N': """; â‰ : â‰ , â‰ if â‰ elif â‰ else â‰ for""",
    'P': """+ â‰ - â‰ * â‰ ~  â‰   ** â‰  not â‰ yield""",
    'B': """+ â‰ - â‰ * â‰ @  â‰   ** â‰   // â‰  < â‰ > â‰ % â‰ .
            & â‰ ^ â‰ | â‰ /  â‰   != â‰   == â‰ << â‰ >>â‰>= â‰ <=
           in â‰ not inâ‰ is â‰is notâ‰   or â‰ and""" }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

OPS_COMP = á–µ(á—œ, ({s for s in l if 'Î»' in lang.ops[s]} for l in lang.op_orders.values()))

SWAP_TABLE = mdt("""
    â‹…   * â‰ âŒƒ    ** â‰ â‰¡     == â‰ â‰¤ <= â‰ â‰” := â‰ Â¯ -
    â ¤   * â‰ â ¶    ** â‰ â‰      != â‰ â‰¥ >= â‰ Ã· / â‰ â¹ //
    âˆ¨  or â‰ â‰…    is â‰ ó°†´    del â‰ Î© class
    Â¬ not â‰ Â¿    if â‰ âŠ¢    def â‰ â° while
    âˆ§ and â‰ â¸˜  elif â‰ â®‚  yield â‰ â†ª return
    âˆ€ for â‰ Â¡  else â‰ â‡¥  break â‰ â†º continue
    âˆˆ  in â‰ â®Œ  from â‰ â¨¡ import â‰ â‰‡ is not â‰ âˆ‰ not in""")
KEYWORDS_TO_CPY=rmk(inv(SWAP_TABLE), sst("* â‰ **"))

merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in SWAP_TABLE.items() if y in z}

kw_pfx_colon = merge_shorthands("""
    if â‰ elif â‰ else â‰ for â‰ while
    try â‰ except â‰ finally â‰ class
    match â‰ case â‰ def â‰ with""")
kw_pfx = merge_shorthands("""
    return â‰ continue â‰ break â‰ pass
    import â‰ global â‰ nonlocal
    raise â‰ assert â‰ del â‰ async""")
kw_neverswouce = merge_shorthands("""if â‰ elif â‰ else â‰ for â‰ yield""")
kw_inline = merge_shorthands("""in â‰ is â‰ is not â‰ not in â‰ or â‰ and â‰ not""") | kw_neverswouce
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("â´³â´´âœ“âœ—â–¡âˆ…âˆÃ®â„‡Ï„Ï€ó·ºó·±ªó·±«ó·±¬ó·±­ó·±®á¦â†‰Â½â…“Â¼â…•â…™â…â…›â…‘â…’â…”â…–Â¾â…—â…œâ…˜â…šâ…â…")
# â†‘ force vars to be one char, will not act as object attribute getter when used as superscript

register("kw", kw)
register("kw_pfx", kw_pfx)
register("kw_spec", kw_spec)
register("kw_pfx_colon", kw_pfx_colon)
register("var_spec", var_spec)

escaped_var_specs = {*á´(py_escape_var, var_spec)}
L = {'.'}
sel = [(v.t+'=', v) for v in lang.ops.values() if v.B and 'Î´' not in v] \
    + [(":=", lang.ops['â‰”']), ('â‰”', lang.ops.pop('â‰”'))]
new_ops = {}
for k, v in sel:
    new_ops[k] = OP(k, "B=", L, lang.ops["â€ASGN_MRK"].R, v.f)
lang.ops |= new_ops
for k, v in lang.ops.items():
    if k in L: continue
    v.R |= set(new_ops)

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« OPERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

â¨¡á´ºá´¾ó°”
;á´ºá´¾ó°” ,á´ºá´¾ó°”
=á´ºá´¾ó°” â®‚á´ºá´¾ó°” â†ªá´ºá´¾ó°” â®Œá´ºá´¾ó°” â†ºá´ºó°” â‡¥á´ºó°” â°á´ºá´¾ó°” âˆ€ â›
â ¤á´¾ó°”ó° â ¶á´¾ó°”ó° :á´®á´¾á´ºó°ó°”
â€1á´µá´® Â¿á´ºá´¾ó°” â¸˜á´ºá´¾ó°” Â¡á´ºá´¾ó°”
â€ASGN_MRKá´® â‰”á´®ó°œ
â¨³á´®á´¾ó°€’á´º
âŠ»á´®á´ºó°– â‰ â¨á´®á´ºó°– â‰ âˆ¨á´®á´ºó°œ â‰ âŠ¼á´®á´ºó°– â‰ âˆ§á´®á´ºó°œ
â‰¡á´®á´ºó°ó°– â‰ á´®á´ºó°ó°– â‰¤á´®á´ºó°ó°–  â‰¥á´®á´ºó°ó°–  âˆˆá´®á´ºó°–  âˆ‰á´®á´ºó°– âˆŒá´®á´ºó°– âˆ‹á´®á´ºó°– â›
      <á´®á´ºó°–ó° >á´®á´ºó°–ó° <=á´®á´ºó°ó°– >=á´®á´ºó°ó°– âˆ£á´®á´ºó°– âˆ¤á´®á´ºó°– â›
      âŠŠá´®á´ºó°–  âŠ„á´®á´ºó°–   âŠ‚á´®á´ºó°–   âŠƒá´®á´ºó°–  âŠ…á´®á´ºó°– âŠ‹á´®á´ºó°–
êŸ¿á´®á´º á´á´®á´º   Å¿á´®á´º   Ïœá´®á´º  Î£á´®á´¾ó°€’á´º Î á´®á´¾ó°€’á´º ó°ˆ²á´®á´¾ó°€’á´º ó°ˆ³á´®á´¾ó°€’á´º â›
    ó°’¼á´®á´¾ó°€’á´º ó°’½á´®á´¾ó°€’á´º á™á´®ó°€’á´º á™¡á´®ó°€’á´º  á—¢á´®ó°€’á´º  á™§á´®ó°€’á´º  î®†á´®á´¾ó°€’á´º
á¹á´®á´¾ó°€’á´º Î¶á´®á´º î‰°á´®á´¾ó°€’á´ºó°˜ ó±…á´®á´¾ó°€’á´ºó°˜ ï´á´®á´¾ó°€’á´ºó°˜
|á´®á´º â‰ ^á´®á´º â‰ &á´®á´º
<<á´®á´º >>á´®á´º
âˆ“á´¾á´®á´º Â±á´¾á´®á´º +á´¾á´®á´º -á´¾á´®á´º
â‰…á´®á´ºó° â‰‡á´®á´ºó°
á£†á´®á´¾ó°€’á´º âˆ˜á´®á´º â—‹á´®á´º ïó°€’á´º ï±á´®á´¾ó°€’á´º ó°”¶á´®á´¾ó°€’á´º î©¬á´®á´¾ó°€’á´º
â—„á´®á´ºó° â–ºá´®á´ºó°
â‹„á´®á´º
ó°‘…á´®á´ºó°€’ ó°‘á´®á´ºó°€’ ó°‘ƒá´®á´ºó°€’
âˆªá´®á´º â‰ âˆ©á´®á´º â‰ â¨‰á´¾ó°€’á´®á´º âˆ–á´®á´º
//á´®á´º â¹á´®á´º   /á´®á´º   Ã·á´®á´º   %á´®á´º   @á´®á´¾á´ºó° *á´®á´ºá´¾ó° â‹…á´®á´º  âˆšá´¾á´º â›
     !ó°€’á´º   â‹€á´¾ó°€’á´º  â‹á´¾ó°€’á´º  â«°á´¾ó°€’á´º  â«¯á´¾ó°€’á´º â›
     â­¥á´¾ó°€’á´º  ó·¸¹á´®á´¾ó°€’á´º ó·¸¸á´®á´¾ó°€’á´º ó·¸»á´®á´¾ó°€’á´º ó·¸ºá´®á´¾ó°€’á´º â†¨á´¾ó°€’á´º  â¤‰á´®á´¾ó°€’á´º â›
     â¤ˆá´®á´¾ó°€’á´º ó·¹„á´®á´¾ó°€’á´º â˜¾á´¾ó°€’á´º  ğŸƒŒá´¾ó°€’á´º  â–¢á´®á´¾ó°€’á´º â¬„á´®á´¾ó°€’á´º á’á´®á´º   â›
     ó°›”á´®á´¾ó°€’á´º ó°˜¬á´®á´¾ó°€’á´º â›¶á´¾ó°€’á´º  â‰á´¾ó°€’á´º  á´™á´¾ó°€’á´º  â´µá´¾ó°€’á´º  â­á´¾ó°€’á´º  â›
     ó°¸µá´®á´º   ó°¸·á´®á´º
Â¬á´¾ó°€’á´ºó°œ Â¯á´¾á´º
**á´µá´®á´¾ó° â€¦á´®á´º âŒƒá´µá´®á´º
ï€…á´µá´¾á´º î®¦á´ºó°€’
ó°»¾á´º â„µá´º â„¶á´º
.á´®ó°ó°”
...á´º

  ï½œ  â†á´¾ó°ó°œï½œâ€1
â€1ï½œ  â†’ó°€’ó°ó°œï½œ
â€1ï½œ  â¥‰á´®ó°ó°œï½œâ€1

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GRAMMAR Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

parser_main = exprs
parser_comment = (â ¶str âˆ¨ ó°†´comment âˆ¨ ~â€¹.|\nâ€º)*

exprs = W? (â ¶expr W?)*
expr = (
    (kw_pfx_colon_expr =  â ¶vkw_pfx_colon ó°†´Ã†? (expr_not_colon? ó°†´Ã†? ó°†´':') M:âœ“ ó°†´E? expr?)
        âˆ¨ (kw_pfx_expr =  â ¶vkw_pfx ó°†´E? expr?)
          âˆ¨ (norm_expr = (â ¶norm_expr_atom)+))

expr_not_colon = (Â¬':' â ¶norm_expr_atom)+
expr_not_comma = (Â¬',' â ¶norm_expr_atom)+

vkw_pfx_colon = â®kw_spec kw_pfx_colon âˆ¨ kw_pfx_colon â®text_breaker
vkw_pfx       = â®kw_spec kw_pfx       âˆ¨ kw_pfx       â®text_breaker
vkw           = â®kw_spec kw           âˆ¨ kw           â®text_breaker

norm_expr_atom = (lamb âˆ¨ â ¶gen_expr_atom) ó°†´E?
gen_expr_atom = group âˆ¨ â ¶str âˆ¨ var_spec âˆ¨ number âˆ¨ oper âˆ¨ â ¶vkw âˆ¨ â ¶script âˆ¨ var
number = pos_num âˆ¨ neg_num
pos_num = Æ¨(~â€¹0([bB][01]+|[oO][0-7]+|[xX][0-9a-fA-F]+)|([0-9]+(\.[0-9]*)?|[0-9]*\.[0-9]+)(e[+\-]?[0-9]+)?â€º)
neg_num = Æ¨(~â€¹ó·°½([ó·±ˆó·±][ó·°½ó·°¾]+|[ó·±ó·±•][ó·°½-ó·±„]+|[ó·±ó·±–][ó·°½-ó·±†ó·±‡-ó·±Œó·±-ó·±”]+)|([ó·°½-ó·±†]+(\.[ó·°½-ó·±†]*)?|[ó·°½-ó·±†]*\.[ó·°½-ó·±†]+)(ó·±‹[+\-]?[ó·°½-ó·±†]+)?â€º)

var = Æ¨(Â¬W Â¬oper Â¬var_spec Â¬script Â¬"ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥" ~â€¹[^ğ—®-ğ˜‡ğš²â¥Œâ†¦ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«ó°…‚$"'\[\](){}â…â†âŸ¦âŸ§âŸ¨âŸ©â€¹ â›â›â›â€º]â€º)+

group = ~â€¹[\[({â…âŸ¨âŸ¦]â€º (W? â†· exprs) ~â€¹[\])}â†âŸ©âŸ§]â€º

script = ((supscript = Æ¨(SUPSCRIPT)) âˆ¨ (subscript = Æ¨(SUBSCRIPT)))

oper = (
    (oper_mod_l = ~â€¹[âŸ¥â‰º]*â€º)
     oper_lit
    (oper_mod_r = Æ¨((~â€¹[Â´êœ áµœğ‘âŸ¤]+â€º âˆ¨ supscript)*)))

lamb = (
    (   (lamb_h_py = ó°†´"lambda" â®text_breaker ó°†´Ã† â ¶expr_not_colon ó°†´':')
      âˆ¨ (lamb_h_normal = (
            ó°†´('â¥Œ' Ã†?)
            ((Â¬lamb_h_implicit lamb) âˆ¨ â ¶gen_expr_atom ó°†´Ã†?)*
            ó°†´'â†¦' ))
      âˆ¨ (lamb_h_preset = ~"[ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«]")
      âˆ¨ (lamb_h_implicit = var ó°†´(Ã†? 'â†¦'))) ó°†´Ã†?
    (lamb_b = ((exprs ó°†´'ó°…‚') âˆ¨ expr_not_comma)))

str = str_star âˆ¨ str_cpy âˆ¨ str_$ âˆ¨ str_py âˆ¨ str_escape âˆ¨ str_spec_char
str_$ = ó°†´('$' w?) (Æ¨(supscript) âˆ¨ âœ“) ó°†´w? (â ¶str_cpy_inner âˆ¨ 'â€º')* ó°†´(w? 'ó·¹¹')
str_star = (ó°†´"ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥") ~â€¹((?!(ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥))(.|\n))*â€º ó°†´("ó°¦¥ó°¦¥ó°¦¥ó°¦¥ó°¦¥" âˆ¨ âœ“)
str_cpy = ó°†´'â€¹' (â ¶str_cpy_inner âˆ¨ 'ó·¹¹')* ó°†´'â€º'
str_cpy_inner = (str_escape âˆ¨ str_sub âˆ¨ str_spec_char âˆ¨ str_guts)
str_sub = ó°†´'âŸ¦' exprs ó°†´'âŸ§'
str_spec_char = ~â€¹[ğ—®-ğ˜‡]â€º
str_guts = ~"[^ğ—®-ğ˜‡âŸ¦â›â›â€ºó·¹¹]+"
str_escape = ó°†´"â›â›" ~â€¹.â€º
str_py = ((â€¹"â€º (str_py_sub âˆ¨ ~â€¹[^"\\]+â€º)* â€¹"â€º)
       âˆ¨  (â€¹'â€º (str_py_sub âˆ¨ ~â€¹[^'\\]+â€º)* â€¹'â€º))

str_py_sub = ~â€¹\\.â€º

w = ~â€¹([ \t]*â›â›\n[ \t]*)+|[ \t]+â€º
W = ~â€¹[ \t\n]+â€º
text_breaker = â®(E âˆ¨ kw_spec âˆ¨ var_spec âˆ¨ Â¬var)
E = w âˆ¨ ~â€¹â›â›\nâ€º
Ã† = W âˆ¨ ~â€¹â›â›\nâ€º

comment = ~â€¹((î¬¦|#)[^\n]*(?=\n|\Z))|(ğŸŸ‘[^ğŸŸ‘]*(ğŸŸ‘|\Z))|(Ö[^Ö]*(Ö|\Z))â€º

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GENERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

# Â§ tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

def Ïƒ_00():
    @(yield replacement(*KEYWORD_NODE_NAMES, n="Lang keywords â†’ cpy keywords"))
    def _(n):
        if n.txt in kw_inline: # keyword that are just ops
            return OP.TND(KEYWORDS_TO_CPY.get(n.txt, n.txt))
        else:
            return n.copy(c=KEYWORDS_TO_CPY.get(n.txt, n.txt))
    
    @(yield reduction("supscript", n="Swap Superscripts"))
    def _(n):
        t = gram(SCRIPT.nrm(n.txt), "exprs")
        T = lang(t.txt.strip())
        if T.isidentifier() and T not in escaped_var_specs:
            return [OP.TND('.'), t]
        return [
            Node("oper", [
                Node("oper_mod_l",  á¦ ),
                Node("oper_lit"  , 'âŒƒ'),
                Node("oper_mod_r",  á¦ )]),
            mkgxp_(Node(c=lang(t.txt)))]
    
    ((yield replacement("subscript", rec='A', n="Subscripts to brackets"))
    (lambda n: mkgrp(gram(SCRIPT.nrm(n.c), "exprs"), b="[]")))
    
    ((yield replacement("norm_expr", "expr_not_colon", "expr_not_comma", rec='B',
                        n="Normalize expression types"))
    (lambda n: n.copy("expr")))
    
    ((yield replacement("W", n="Trim whitespace"))
    (lambda n: n.copy(c=Å„ in n.c and Å„+âµ‰(n.c,Å„)[-1] or n.c)))

def Ïƒ_05():
    op_chk = lambda n, o: n.t == "oper" and n.txt == o
    hs_op = lambda C, o: â´¸(op_chk(c, o) for c in C)

    @(yield replacement("expr", rec='A', n="Detect for_expr"))
    def _(N):
        if not hs_op(C := N.C, 'âˆ€'): return N
        
        Î±, _, Î² = part(C, Ï(op_chk, o='âˆ€'))
        Î², _, Î³ = part(Î², Ï(op_chk, o='âˆˆ'))
        if hs_op(Î³, 'Â¿'):
            Î³, _, Ïƒ = part(Î³, Ï(op_chk, o='Â¿'))
        else:
            Ïƒ = None
        
        cc = [Node("expr", Î±), Node("expr", Î²), Node("expr", Î³)]
        if Ïƒ: cc.append(Node("expr", Ïƒ, e="cond"))
        return N.copy("for_expr", c=cc)
    
    @(yield replacement("kw_pfx_colon_expr", rec='A', n="Detect for_stmt"))
    def _(N):
        if not op_chk(N.C[0], 'âˆ€'): return N
        Î±, _, Î² = part(N.C[1].C, Ï(op_chk, o='âˆˆ'))
        return N.copy("for_stmt", c=[Node("expr", Î±), Node("expr", Î²), *N.C[2:]])

def Ïƒ_10():
    ((yield replacement("parser_main", rec='A', n="Build whitespace blocks"))
    (whitespace_parser))

ARG_A = mkexp(("oper_lit", "â ¤"), mkvar('ğ”¸'))
ARG_K = mkexp(("oper_lit", "â ¶"), mkvar('ğ•‚'))
def Ïƒ_15():
    yield "Refactor lambdas"
    ((yield replacement("lamb_h_preset"))
    (lambda n: Åƒ("lamb_h",
            *á´(lambda t: mkexp(mkvar(t)), "xyzwvutsr"[:"ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«ó°²­ó°²¯ó°²±".index(n.c)]),
            ARG_A, ARG_K)))
    
    ((yield replacement("lamb_h_implicit"))
    (lambda n: Åƒ("lamb_h", mkexp(n.C[0]), ARG_A, ARG_K)))
    
    @(yield replacement("lamb_h_normal", "lamb_h_py"))
    def _(n):
        C = á´(Node.strip,
              á´s(mkexp,
                 split_at(
                    n.C,
                    lambda x: OP.is_op(x) and (k:=op_man[x]).t == ',')))
        has_a = has_k = â´´
        
        C = á–µ(lambda x: x.txt, C) # b/c â¥Œâ†¦ has empty an expr
        for c in C:
            if not c.C or (o:=c.C[0]) != "oper": continue
            k = o.C[1].c
            if   k in ( "*", "â ¤"): has_a = â´³
            elif k in ("**", "â ¶"): has_k = â´³
        if not has_a: C.append(ARG_A)
        if not has_k: C.append(ARG_K)
        return Åƒ("lamb_h", *C)
    
    ((yield replacement("lamb_b", rec='A'))
    (lambda n: n.copy(t="expr")))

def Ïƒ_20():
    ((yield replacement("expr", rec='B', n="Parse expressions"))
    (lambda n: n.copy(c=into_expr(parse_expr(n.C)).c)))

def Ïƒ_21():
    def split_target(l):
        l, t = l.copy(), []
        while l:
            Î± = l.pop()
            if Î± == '.':
                return '.', l, t[0]
            if Î±.t == "op_call":
                assert Î±.C[1].txt == '.'
                l = l + [*Î±.C[0], '.', *Î±.C[2]]
                continue
            if Î±.t == "group" and (Î±.C[0].txt, Î±.C[2].txt) == ('[', ']'):
                return 'l', l, Î±.C[1]
            t.insert(0, Î±)
        assert âµŒ(t) == 1
        return á¦, á—œ, t[0]

    def make_inline_asgn(Î±, Î£, Î²):
        Ï„, Îº, Ï‡ = split_target(Î±.C)
        
        if Ï„ == á¦: return \
            mkgrp(mknex_(Ï‡, mkgxp(Î£ and ("op_call", mkexp(Ï‡), Î£, Î²) or Î²)))
        
        Ï = Ï„ == '.' and "ATTR" or "ITEM"
        Îº = mkgxp(*(Node("expr_", '.') if i == '.' else i for i in Îº))
        Ï‡ = mkgxp(("str_", f'"{py_escape_var(Ï‡.txt)}"') if Ï=="ATTR" else Ï‡)
        if Î£: # optimization: pull out some constant nodes
            ST, GT = mkvar("SET"+Ï), mkvar("GET"+Ï)
            PS, PP = mkvar("Ã¾PSH" ), mkvar("Ã¾POP" )
            return fcall_(ST,
                fcall_(PS, Îº),
                fcall_(PS, Ï‡),
                Node("op_call", [
                        fcall_(GT,
                            fcall_(PP, Node("number", "-2")),
                            fcall_(PP, Node("number", "-1"))),
                    Î£, Î²]))
        return fcall_(mkvar("SET"+Ï), Îº, Ï‡, Î²)
    
    @(yield replacement("op_call", rec='A', n="Refactor assignment infix opertators"))
    def _(n):
        Î±, Î£, Î² = n.C
        if Î£.c[0].txt or Î£.c[2].txt: return n
        if Î£.txt in ('â‰”', ':='): return make_inline_asgn(Î±, None, Î²)
        if '=' not in lang.ops[Î£.txt]: return n
        Î£ = OP.TND(Î£.txt[:-1])
        return make_inline_asgn(Î±, Î£, Î²)

def Ïƒ_25():
    @(yield reduction("op_call", rec='B', n="Flatten cmp ops"))
    def _(n):
        if 'Î»' in op_man[n.C[1]] and \
                n.C[0] != NULL and n.C[2] != NULL:
            return [*n.C[0].C, n.C[1], *n.C[2].C]
        return [n]

def Ïƒ_30():
    def make_cmp_chain(n, layers=á—œ):
        layers = layers or OPS_COMP
        layer, *layers = layers
        
        rec = lambda n: layers and make_cmp_chain(n, layers=layers) or n
        mkexp_rec = lambda N: rec(mkexp(*N))
        
        C = á’ª(split_at(n.C,
            lambda x: OP.is_op(x) and (k:=op_man[x]).t in layer and k.B,
            keep_separator=â´³))
        if âµŒ(C) < 3:
            return rec(n)
        r = â´´
        
        for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
            c = mkexp_rec(c)
            v = mkexp(("op_call",
                H and mkexp_rec(a) or Ã¾Ã¾,
                b,
                T and c or mknex_(Ã¾Ã¾, c)))
            r = mkexp(("op_call", r, OP.TND('âˆ§'), v)) if r else v
        return n.copy(c=[r])
    
    ((yield replacement("expr", rec='B', n="Generate comparison chains"))
    (make_cmp_chain))

demodp = lambda o: (o.C[0].txt, o.C[1], o.C[2].txt)
def mkbltnop(op_l): # format builtins if needed
    t = op_l.txt
    if (t := SWAP_TABLE.get(t,t)) not in OPS_BUILTIN['A']:
        return op_l
    return mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
def transform_oper(op_): # apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    if not (m_l or m_r): return op_l
    op_n = mkbltnop(op_l)
    mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
    
    if 'â‰º' in m_l: op_n = mkmod(op_n, "BSTAR")
    if 'âŸ¥' in m_l: op_n = mkmod(op_n, "LNULL")
    
    rmods = á¦
    for m in m_r:
        if m in "âŸ¥âŸ¤áµœêœ Â´":
            match m:
                case 'âŸ¤': op_n = mkmod(op_n, "RNULL")
                case 'áµœ': op_n = mkmod(op_n, "SWAPA")
                case 'êœ ': op_n = mkmod(op_n, "DUPER")
        else:
            rmods += m
    if rmods:
        rmods = á’(',', (f'"{x}"' if FS(x).issubset(ascii_uppercase) else lang(x) \
                    for x in SCRIPT.nrm(rmods).split('ğ‘')))
        op_n = mkexp(op_n, Node("expr_", f'[{rmods}]'))
    return op_n

def Ïƒ_35():
    hnul = lambda x: x.copy("NULL_") if x == "NULL" else x
    
    def try_builtin(m, op_l, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
        if m_l or m_r: return
        if SWAP_TABLE.get(t, t) not in OPS_BUILTIN[m]: return
        return mkgxp(*Îµ(L), op_l, *Îµ(R))

    @(yield replacement("op_call", rec='B', n="Refactor op calls"))
    def _(n):
        l, op_, r = n.C
        op = op_man[op_]
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
        
        if not (m_l or m_r):
            if 'Î²' in op and     L and R: return mkgxp(L, op_l, R)
            if 'Ïƒ' in op and not L and R: return mkexp(op_l, r)
            if 'Î¹' in op: return mkexp(hnul(l), op_l, hnul(r))
            if 'Ï' in op:
                match t:
                    case 'â†’': return L
                    case 'â†': return R
                    case 'â¥‰': return mkgxp(R, L)
                    case 'â‰”': return mkgxp(l, op_l, R)
                    case ('Â¬') if L or R:
                            return mkgxp(op_l, L or R)
        
        op_l = transform_oper(op_)
        
        A = (op_l, L, m_l, t, m_r, R)
        if op.S and L and not op.B:
            return try_builtin('S', *A) or mkexp(mkbltnop(op_), L)
        if op.P and R and not op.B:
            return try_builtin('P', *A) or mkexp(mkbltnop(op_), R)
        if op.B and L and R:
            return try_builtin('B', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA,    r))
        if op.S and L:
            return try_builtin('S', *A) or mkexp(mkbltnop(op_), mkgxp(   l, COMMA, NULL))
        if op.P and R:
            return try_builtin('P', *A) or mkexp(mkbltnop(op_), mkgxp(NULL, COMMA,    r))
        if op.N and 'Î½' in op:
            return mkexp(mkbltnop(op_), mkgxp())
        return mkbltnop(op_)

def Ïƒ_40():
    @(yield replacement("oper", rec='A', n="Refactor sitting ops"))
    def _(n):
        if n.C[1].txt in kw_neverswouce:
            return n
        if not (n.C[2].txt or n.C[0].txt):
            n = n.copy(c=[n.C[0], n.C[1], n.C[2].copy(c="Â´")])
        return transform_oper(n)
    
    ((yield replacement(*KEYWORD_NODE_NAMES, "oper_lit",
                        n="Lang keywords â† cpy keywords"))
    (lambda n: n.copy(c=py_escape_var(SWAP_TABLE.get(n.txt, n.txt)))))
    
    ((yield replacement("lamb", rec='B', n="Format lambda"))
    (lambda n: mkgxp(n.C[0], mkgrp(n.C[1]))))
    
    ((yield replacement("lamb_h", rec='B', n="Format lambda header"))
    (lambda n: Åƒ("lamb_h", ("kw", "lambda"), *JÌ(n.C, COMMA), ("oper_lit", ":"))))

def Ïƒ_45():
    ((yield replacement("parser_main", rec='A', n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((yield reduction("BLOCK", rec='B', n="Flatten blocks"))
    (lambda n: n.C))

def Ïƒ_48():
    ((yield replacement("for_expr", rec='B', n="Build for exprs"))
    (lambda n: Åƒ(
        "expr",
        n.C[0], ("kw", "for"), n.C[1], ("kw", "in"), n.C[2],
        *([("kw", "if"), n.C[3]] if n['cond'] else []))))
    
    ((yield replacement("for_stmt", rec='B', n="Build for stmt"))
    (lambda n: Åƒ(
        "kw_pfx_colon_expr",
        Node("kw_pfx_colon", "for"),
        ("expr", n.C[0], ("kw", "in"), n.C[1]),
        *n.C[2:])))

def Ïƒ_50():
    ((yield replacement("kw_pfx_colon_expr", rec='B', n="Add colons"))
    (lambda n: n.insert_after_marker('M', COLON)))
    
    ((yield replacement("parser_main", rec='B', n="Insert spaces"))
    (Ï(add_spaces, ignore_nodes=("str_cpy", "str_py", "str_star", "str_$"))))

# Â§ node transpilers

generator(*KEYWORD_NODE_NAMES, "oper_lit", "var", "var_spec")(
    lambda n: py_escape_var(n.txt))
generator("NULL")(lambda n: "NULL")

@generator("group")
def gen_group        (n):
    if n.C[0].txt == 'âŸ¦': # broken mostly
        content = next(filter(âµ, á´(gen, n.C[1:-1])))
        return f'''(exec("def _EXE():\\n{py_escape_string(force_indent(content))}",globals(),locals()),_EXE)[1]()'''
    return n.C[0].txt + á’(á¦, á´(gen, n.C[1:-1])) + n.C[-1].txt

generator("str_guts"              )(lambda n: py_escape_string(n.txt))
generator("str_escape", "str_star")(lambda n: "'" + py_escape_string(n.txt) + "'")
generator("str_sub"               )(lambda n: "{" + gen(n.C[0]) + "}")
generator("str_spec_char"         )(lambda n: "'" + py_special_mapper(n.txt) + "'")

def make_str_cpy(n):
    # issue: we don't always want space here
    r=' f"'
    for c in n.c:
        if   c.t == "str_escape"   : r += py_escape_string(c.txt)
        elif c.t == "str_spec_char": r += py_special_mapper(c.txt)
        else                       : r += gen(c)
    return r + '"'

generator("neg_num")(lambda n: f"(-{UPSIDEDOWNSYNDROME.flip(n.txt)})")
generator("str_cpy")(make_str_cpy)

@generator("str_$")
def make_str_money(n):
    s, *C = n.c
    return f'SUBPROCA({make_str_cpy(n.copy(c=C))},' \
           f'"{py_escape_string(SCRIPT.nrm(s.txt))}")'