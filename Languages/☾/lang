# P/S/B/N: prefix/suffix/binary/nullary
# I: Include self in group (right asoc.)
# Î±: basic concat
# Î´: x <op>= y doesn't make sense
# Î½: NULL version self-calls
# Ï‡: <op>ó°€‚ with C: capital letter doesn't do anything special
# Ï: *special*

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« HEADERS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

from whitespace_tools import *
from string import ascii_uppercase
from py_naming_tools import *
py_escape_var = lambda x, f=py_escape_var: f(x, â´³)

mkexp = lambda *X: Åƒ("expr", *X)
mkgrp = lambda *X, b="()": Åƒ("group", b[0], X[0] if âµŒ(X)==1 else X, b[1])
mkgxp = lambda *X, b="()": mkgrp(mkexp(*X), b=b)
mkstr = lambda x: Åƒ("str", '"', x, '"')
mkvar = lambda x: Node("var", x)
mkexp_ = lambda *n: Node("expr_", á’ª(n))
mkgxp_ = lambda *n: mkgrp(mkexp_(*n))
fcall_ = lambda f,*n,E=[]: mkexp_(f, mkgxp_(*JÌ(n, COMMA)), *E)
mknex_ = lambda a, b     : mkexp_(a, EQCLN, b)

sst = lambda x  : set(á–µ(á—œ,á´(âµ,âµ‰(á–‡(x,'â‰',Å„),Å„))))
mdt = lambda y  : á–±(á´(âµ,âµ‰(x,Å›,1)) for x in sst(y))
inv = lambda z  : {y:x for x,y in z.items()}
rmk = lambda z,k: {x:y for x,y in z.items() if x not in k}

NUM_M3, NUM_M2, NUM_M1, NUM_P0, NUM_P1 = (Node("number", á”(x)) for x in range(-3,2))
COMMA, COLON, EQCLN = (Node("oper_lit", x) for x in âµ‰(", : :=", Å›))
ARG_A = mkexp(("oper_lit", "â ¤"), mkvar('ğ”¸'))
ARG_K = mkexp(("oper_lit", "â ¶"), mkvar('ğ•‚'))
TACTACK_L, TACTACK_R = mkvar('âŸ'), mkvar('âŸ')
TRUE, FALSE = mkvar("True"), mkvar("False")
Ã¾PSH, Ã¾POP = mkvar("Ã¾PSH"), mkvar("Ã¾POP")
Ã¾POP_M3, Ã¾POP_M2, Ã¾POP_M1 = fcall_(Ã¾POP, NUM_M3), fcall_(Ã¾POP, NUM_M2), fcall_(Ã¾POP, NUM_M1)

Ã¾POPNR = fcall_(mkvar("Ã¾POPNR"))
Ã¾Ã¾ = mkvar("Ã¾Ã¾") # sus

OPS_BUILTIN = {
    'S': """""",
    'N': """; â‰ : â‰ , â‰ if â‰ elif â‰ else â‰ for""",
    'P': """+ â‰ - â‰ * â‰ ~ â‰ ** â‰not â‰ yield""",
    'B': """+ â‰ - â‰ * â‰ @ â‰ ** â‰ // â‰< â‰ > â‰ % â‰ . â‰ & â‰ ^ â‰ | â‰ / â‰ != â‰ == â‰ << â‰ >> â‰ >= â‰ <= â‰ in â‰ not inâ‰ is â‰is notâ‰ or â‰ and""" }
OPS_BUILTIN = {k:sst(v) for k,v in OPS_BUILTIN.items()}
OPS_BUILTIN['A'] = set.union(*map(set,OPS_BUILTIN.values()))

OPS_COMP = á–µ(á—œ, ({s for s in l if 'Î»' in lang.ops[s]} for l in lang.op_orders.values()))

SWAP_TABLE = mdt("""
    â‹…   * â‰ âŒƒ    ** â‰ â‰¡     == â‰ â‰¤ <= â‰ â‰” := â‰ Â¯ -
    â ¤   * â‰ â ¶    ** â‰ â‰      != â‰ â‰¥ >= â‰ Ã· / â‰ â¹ //
    â€CAT *â‰
    âˆ¨  or â‰ â‰…    is â‰ ó°†´    del â‰ Î© class â‰ ó±€˜ class
    Â¬ not â‰ Â¿    if â‰ âŠ¢    def â‰ â° while
    âˆ§ and â‰ â¸˜  elif â‰ â®‚  yield â‰ â†ª return
    âˆ€ for â‰ Â¡  else â‰ â‡¥  break â‰ â†º continue
    âˆˆ  in â‰ â®Œ  from â‰ â¨¡ import â‰ â‰‡ is not â‰ âˆ‰ not in""")
KEYWORDS_TO_CPY=rmk(inv(SWAP_TABLE), sst("* â‰ **"))

merge_shorthands = lambda z: (z:=sst(z)) | {x for x,y in SWAP_TABLE.items() if y in z}

kw_pfx_colon   = merge_shorthands("""if â‰ elif â‰ else â‰ for â‰ while â‰ try â‰ except â‰ finally â‰ class â‰ match â‰ case â‰ def â‰ with""")
kw_neverswouce = merge_shorthands("""if â‰ elif â‰ else â‰ for â‰ yield""")
kw_inline      = merge_shorthands("""in â‰ is â‰ is not â‰ not in â‰ or â‰ and â‰ not""") | kw_neverswouce
kw_pfx         = merge_shorthands("""return â‰ continue â‰ break â‰ pass â‰ import â‰ global â‰ nonlocal â‰ raise â‰ assert â‰ del â‰ async""")
kw = kw_pfx_colon | kw_pfx | kw_inline
kw_spec = { i for i in kw if all(not x.isalpha() and not x.isdigit() for x in i) }
var_spec = set("â´³â´´âœ“âœ—â–¡á¦ó°®ˆâ¬¤Ã®Äµó·ºˆâ„‡Ï„Ï€ó·ºó·ºâˆó·±ªó·±½ó·±¾ó·±«ó·±¬ó·±­ó·±®ó·±¯ó·±°ó·±©â†‰Â½â…“Â¼â…•â…™â…â…›â…‘â…’â…”â…–Â¾â…—â…œâ…˜â…šâ…â…") # forced to be one char, will not act as object or attr-getter when superscript
escaped_var_specs = {*á´(py_escape_var, var_spec)}

register("kw", kw)
register("kw_pfx", kw_pfx)
register("kw_spec", kw_spec)
register("kw_pfx_colon", kw_pfx_colon)
register("var_spec", var_spec)

IG = {'.'}
sel = [(v.t+'=', v) for v in lang.ops.values() if v.B and 'Î´' not in v] \
    + [(":=", lang.ops['â‰”']), ('â‰”', lang.ops.pop('â‰”')),
       (":=", lang.ops['ó·¸‰']), ('ó·¸‰', lang.ops.pop('ó·¸‰')),
       (":=", lang.ops['ó·¸Š']), ('ó·¸Š', lang.ops.pop('ó·¸Š')),
       (":=", lang.ops['ó·¸‹']), ('ó·¸‹', lang.ops.pop('ó·¸‹'))]
new_ops = {}
for k, v in sel:
    new_ops[k] = OP(k, "B=", IG, lang.ops["â€ASGN_MRK_R"].R, v.f)
lang.ops |= new_ops
for k, v in lang.ops.items():
    if k in IG: continue
    v.R |= set(new_ops)
lang.ops["â‰•"] = OP(k, "B=", lang.ops["â€ASGN_MRK_L"].L, IG, v.f)
lang.ops["ó·¸"] = OP(k, "B=", lang.ops["â€ASGN_MRK_L"].L, IG, v.f)
lang.ops["ó·¸Œ"] = OP(k, "B=", lang.ops["â€ASGN_MRK_L"].L, IG, v.f)
lang.ops["ó·¸"] = OP(k, "B=", lang.ops["â€ASGN_MRK_L"].L, IG, v.f)

# janky? we need test cases broooo
lang.ops["â¬…"].R |= {"â†’", "â­¢"}
lang.ops["â†"].R |= {"â­¢"}

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« OPERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

â¨¡á´ºá´¾ó°”
;á´ºá´¾ó°” ,á´ºá´¾ó°”
=á´ºá´¾ó°” â®‚á´ºá´¾ó°” â†ªá´ºá´¾ó°” â®Œá´ºá´¾ó°” â†ºá´ºó°” â‡¥á´ºó°” â°á´ºá´¾ó°” âˆ€ â›
     â ¤á´¾ó°”ó° â ¶á´¾ó°”ó° :á´®á´¾á´ºó°ó°”
â€ARW_1á´µá´®
â­á´ºá´®á´µó°œ â‰ â­œá´®á´µó°œ
â€ARW_2á´µá´®
Â¡á´®á´µó°œ â‰ â¸˜á´ºá´¾ó°” Â¿á´ºá´®á´µó°œ
â€ASGN_MRK_Lá´® â‰”á´®ó°œ ó·¸‰á´®ó°œ ó·¸Šá´®ó°œ ó·¸‹á´®ó°œ â€ASGN_MRK_Rá´® â›
             â‰•á´®ó°œ ó·¸á´®ó°œ ó·¸Œá´®ó°œ ó·¸á´®ó°œ
â€ARW_3á´µá´®
â¨³á´®á´¾ó°€’á´º
âˆ¨á´®á´º â©”á´®á´º ó·º¥á´®á´º ó·º«á´®á´º ó·º¤á´®á´º ó·º¦á´®á´º
âˆ§á´®á´º â©“á´®á´º ó·º’á´®á´º ó·º¬á´®á´º
â‰¡á´®á´ºó°–ó° ==á´®á´ºó°–ó° !=á´®á´ºó°–ó° â‰ á´®á´ºó°–ó° âˆ£á´®á´ºó°–  âˆ¤á´®á´ºó°–         â›
      <=á´®á´ºó°–ó°  â‰¤á´®á´ºó°–ó° <á´®á´ºó°–ó° >á´®á´ºó°–ó° â‰¥á´®á´ºó°–ó° >=á´®á´ºó°–ó° â›
       âŠ„á´®á´ºó°–   âŠŠá´®á´ºó°–  âŠ‚á´®á´ºó°–  âŠƒá´®á´ºó°–  âŠ‹á´®á´ºó°–   âŠ…á´®á´ºó°–  â›
       âˆ‰á´®á´ºó°–   âˆˆá´®á´ºó°–  âˆ‹á´®á´ºó°–  âˆŒá´®á´ºó°–
â€TACá´®
êŸ¿á´®á´º á´á´®á´º    ï’¼á´®á´¾ó°€’á´ºó°¢ Å¿á´®á´ºó°¢   Ïœá´®á´ºó°¢   â¨€á´®á´¾ó°€’á´ºó°¢ â¨á´®á´¾ó°€’á´ºó°¢ â›
    ó°ˆ²á´®á´¾ó°€’á´ºó°¢ ó°ˆ³á´®á´¾ó°€’á´ºó°¢ ó°’¼á´®á´¾ó°€’á´ºó°¢ ó°’½á´®á´¾ó°€’á´ºó°¢ î®†á´®á´¾ó°€’á´º         â›
    á™á´®ó°€’á´ºó°¢  á™¡á´®ó°€’á´ºó°¢  á—¢á´®ó°€’á´ºó°¢  á™§á´®ó°€’á´ºó°¢ 
âˆ˜á´®á´º â—‹á´®á´º âœá´®á´º ó°¬«á´®á´º ó°¬©á´®á´º ó±–šá´®á´º ó±–˜á´®á´º ïó°€’á´º   á£†á´®á´¾ó°€’á´º â›
    âŠšá´®á´¾ó°€’á´º âŠ›á´®á´¾ó°€’á´º âŸá´®á´¾ó°€’á´º âŠœá´®á´¾ó°€’á´º ğŸŸ•á´®á´¾ó°€’á´º ğŸŸ–á´®á´¾ó°€’á´º â›
    ï±á´®á´¾ó°€’á´º ó°”¶á´®á´¾ó°€’á´º î©¬á´®á´¾ó°€’á´º
á¹á´®á´¾ó°€’á´ºó°– á´á´®á´¾ó°€’á´ºó°– ó·¹µá´®á´ºó°– ó·¹´á´®á´ºó°– ó±‘¼á´®á´¾ó°€’á´ºó°¢ ó·¹…á´®á´¾ó°€’á´ºó°¢ î‰°á´®á´¾ó°€’á´ºó°˜ó°¢ ó±…á´®á´¾ó°€’á´ºó°˜ó°¢ ï´á´®á´¾ó°€’á´ºó°˜ó°¢
|á´®á´º â‰ ^á´®á´º â‰ &á´®á´º
<<á´®á´º >>á´®á´º âª¡á´¾ó°€’á´®á´º âª¢á´¾ó°€’á´®á´º
âˆ“á´¾á´®á´º Â±á´¾á´®á´º +á´¾á´®á´º -á´¾á´®á´º
â—„á´®á´ºó° â–ºá´®á´ºó°
â‹„á´®á´º
âˆªá´®á´º â‰ âˆ©á´®á´º â‰ â¨‰á´¾ó°€’á´®á´º âŠá´¾ó°€’á´®á´º âˆ–á´®á´º
//á´®á´º /á´®á´º    *á´®á´ºá´¾ó° â›
     â‰…á´®á´ºó°   â‰‡á´®á´ºó°   â‹…á´®á´º    Ã·á´®á´º   â¹á´®á´º    %á´®á´º  â›
     â‹€á´¾ó°€’á´º   â‹á´¾ó°€’á´º   â«°á´¾ó°€’á´º   â«¯á´¾ó°€’á´º  @á´®á´¾á´ºó°  âˆšá´¾á´º  â›
     âŸ•á´®á´¾ó°€’á´º  â¨á´®á´¾ó°€’á´º  âŸ—á´®á´¾ó°€’á´º  âŸ–á´®á´¾ó°€’á´º !ó°€’á´ºó°   â˜¾á´¾ó°€’á´º â›
     ó·¸¹á´®á´¾ó°€’á´º  ó·¸¸á´®á´¾ó°€’á´º  ó·¸»á´®á´¾ó°€’á´º  ó·¸ºá´®á´¾ó°€’á´º â­á´¾ó°€’á´º   â‰á´¾ó°€’á´º â›
     ó·¹“á´®á´ºó°€’   ó°‘…á´®á´ºó°€’   ó·¹”á´®á´ºó°€’   ó·¹•á´®á´ºó°€’ó°¢ ó·¹–á´®á´ºó°€’ó°¢  â›¶á´¾ó°€’á´º â›
     â¬“á´¾ó°€’á´º   â–¢á´®á´¾ó°€’á´º  â¬’á´¾ó°€’á´º   ó°¸µá´®á´º   ó°¸·á´®á´º    ğŸƒŒá´¾ó°€’á´º â›
     â¤ˆá´®á´¾ó°€’á´ºó°¢ ó·¹„á´®á´¾ó°€’á´ºó°¢ â¤‰á´®á´¾ó°€’á´ºó°¢ â†¨á´¾ó°€’á´º  â­¥á´¾ó°€’á´º   â´µá´¾ó°€’á´º â›
     ó·¹Œá´®á´¾ó°€’á´º  ó·¹á´®á´¾ó°€’á´º  ó·¹á´®á´¾ó°€’á´º  ğŒ‚á´®á´¾ó°€’á´º á´™á´¾ó°€’á´º   áš¤á´®á´¾ó°€’á´ºâ›
     â¬„á´®á´¾ó°€’á´º  ó°Œ·á´®á´¾ó°€’á´º  ó°›”á´®á´¾ó°€’á´ºó°¢ ó·¹á´¾ó°€’á´ºó°¢ ó·¹œá´®á´¾ó°€’á´ºó°¢      â›
     ó·¸šá´¾ó°€’á´º   ó·¸›á´¾ó°€’á´º   ó·¸™á´¾ó°€’á´º   ó·¸˜á´¾ó°€’á´º  ó·¸œá´¾ó°€’á´º   ó·¸—á´¾ó°€’á´º ó·¸–á´¾ó°€’á´º ó·¸•á´¾ó°€’á´º 
Â¬á´¾ó°€’á´ºó°œ Â¯á´¾á´º
â€CATá´®á´º
**á´µá´®á´¾ó° â€¦á´®á´º âŒƒá´µá´®á´º
ï€…á´µá´¾á´º âˆ¾á´µá´¾á´º î®¦á´ºó°€’
ó°»¾á´º â„µá´º â„¶á´º âˆ…á´ºó°˜ âá´ºó°˜
.á´®ó°ó°”
...á´º

      ï½œ  â€TACITá´ºó°€’ó°ó°œ  ï½œ
â€TAC  ï½œ â€TACITLá´ºó°€’ó°ó°œ  ï½œ
      ï½œ â€TACITRá´ºá´¾ó°ó°œ  ï½œâ€TAC
â€TAC  ï½œâ€TACITLRá´ºá´¾ó°€’á´®ó°ó°œï½œâ€TAC
      ï½œ          â¬…á´¾ó°ó°œï½œâ€ARW_1
â€ARW_1ï½œ          â¡ó°€’ó°ó°œï½œ
      ï½œ          â†á´¾ó°ó°œï½œâ€ARW_2
â€ARW_2ï½œ          â¥‰á´®ó°ó°œï½œâ€ARW_2
â€ARW_2ï½œ          â†’ó°€’ó°ó°œï½œ
      ï½œ          â­ á´¾ó°ó°œï½œâ€ARW_3
â€ARW_3ï½œ          â­¢ó°€’ó°ó°œï½œ

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GRAMMAR Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

parser_main = exprs
parser_comment = (â ¶str âˆ¨ ó°†´comment âˆ¨ ~â€¹.|\nâ€º)*

exprs = ğ—ª? (â ¶expr ğ—ª?)*
expr = (
    (kw_pfx_colon_expr =  â ¶vkw_pfx_colon ó°†´Ã†? (expr_not_colon? ó°†´Ã†? ó°†´':') M:âœ“ ó°†´E? expr?)
        âˆ¨ (kw_pfx_expr =  â ¶vkw_pfx ó°†´E? expr?)
          âˆ¨ (norm_expr = (â ¶norm_expr_atom)+))

expr_not_colon = (Â¬':' â ¶norm_expr_atom)+
expr_not_comma = (Â¬',' â ¶norm_expr_atom)+

vkw_pfx_colon = â®kw_spec kw_pfx_colon âˆ¨ kw_pfx_colon â®text_breaker
vkw_pfx       = â®kw_spec kw_pfx       âˆ¨ kw_pfx       â®text_breaker
vkw           = â®kw_spec kw           âˆ¨ kw           â®text_breaker

norm_expr_atom = (â ¶lambs âˆ¨ â ¶gen_expr_atom) ó°†´E?
gen_expr_atom = group âˆ¨ â ¶str âˆ¨ var_spec âˆ¨ number âˆ¨ oper âˆ¨ â ¶vkw âˆ¨ â ¶script âˆ¨ var
number = pos_num âˆ¨ neg_num
pos_num = Æ¨(~â€¹0([bB][01]+|[oO][0-7]+|[xX][0-9a-fA-F]+)|([0-9]+(\.[0-9]*)?|[0-9]*\.[0-9]+)(e[+\-]?[0-9]+)?â€º)
neg_num = Æ¨(~â€¹ó·°½([ó·±ˆó·±][ó·°½ó·°¾]+|[ó·±ó·±•][ó·°½-ó·±„]+|[ó·±ó·±–][ó·°½-ó·±†ó·±‡-ó·±Œó·±-ó·±”]+)|([ó·°½-ó·±†]+(\.[ó·°½-ó·±†]*)?|[ó·°½-ó·±†]*\.[ó·°½-ó·±†]+)(ó·±‹[+\-]?[ó·°½-ó·±†]+)?â€º)

var = Æ¨(Â¬ğ—ª Â¬oper Â¬var_spec Â¬script Â¬(~â€¹ó°¦¥{5}â€º) ~â€¹[^âŸ¥âŸ¤â­¡â­£ğ—®-ğ˜‡ó·º—á¸á³á‘…á‘€á˜á’á‘ˆáµá›á–ó·º¹-ó·»€ğš²â¥Œâ†¦ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«ó°…‚$"'\[\](){}â…â†âŸ¦âŸ§âŸ¨âŸ©â€¹ â›â›â›â€º]â€º)+

group = ~â€¹[\[({â…âŸ¦]â€º (ğ—ª? â†· exprs) ~â€¹[\])}â†âŸ§]â€º

script = ((supscript = Æ¨(SUPSCRIPT)) âˆ¨ (subscript = Æ¨(SUBSCRIPT)))

oper = (
    (oper_mod_l = ~â€¹[âŸ¥â‰º]*â€º)
     oper_lit
    (oper_mod_r = Æ¨((~â€¹[Â´êœ áµœğ‘âŸ¤]+â€º âˆ¨ supscript)*)))

lambs = lamb_tacit âˆ¨ lamb
lamb = (
    (   (lamb_h_py = ó°†´"lambda" â®text_breaker ó°†´Ã† â ¶expr_not_colon ó°†´':')
      âˆ¨ (lamb_h_normal = (
            ó°†´('â¥Œ' Ã†?)
            ((Â¬lamb_h_implicit lamb) âˆ¨ â ¶gen_expr_atom ó°†´Ã†?)*
            ó°†´'â†¦' ))
      âˆ¨ (lamb_h_preset = ~"[ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«]")
      âˆ¨ (lamb_h_implicit = var ó°†´(Ã†? 'â†¦'))) ó°†´Ã†?
    (lamb_b = ((exprs ó°†´'ó°…‚') âˆ¨ expr_not_comma)))
lamb_tacit = (
      (â ¶LTL exprs â ¶LTR)
    âˆ¨ (â ¶LTL expr_not_comma âœ“ âœ“))
LTL = (â€¹âŸ¥â€ºâˆ¨âœ“) ~â€¹[á³á‘€á’áµá–ó·º¹ó·º»ó·ººó·º¼]â€º ó°†´Ã†?
LTR = ~â€¹[á¸á‘…á˜á‘ˆá›ó·º½ó·º¿ó·º¾ó·»€]â€º (â€¹âŸ¤â€ºâˆ¨âœ“)

str = str_star âˆ¨ Æ¦section âˆ¨ str_cpy âˆ¨ str_$ âˆ¨ str_py âˆ¨ str_escape âˆ¨ str_spec_char
str_$ = ó°†´('$' ğ˜„?) (Æ¨(supscript) âˆ¨ âœ“) ó°†´ğ˜„? (â ¶str_cpy_inner âˆ¨ 'â€º')* ó°†´(ğ˜„? 'ó·¹¹')
str_star = (ó°†´(~â€¹ó°¦¥{5}â€º)) ~â€¹((?!ó°¦¥{5})(.|\n))*â€º ó°†´((~â€¹ó°¦¥{5}â€º) âˆ¨ âœ“)
str_cpy = ó°†´'â€¹' (â ¶str_cpy_inner âˆ¨ 'ó·¹¹')* ó°†´'â€º'
str_cpy_inner = (str_escape âˆ¨ str_sub âˆ¨ str_spec_char âˆ¨ str_guts)
str_sub = ó°†´'âŸ¦' exprs ó°†´'âŸ§'
str_spec_char = ~â€¹[ğ—®-ğ˜‡ó·º—]â€º
str_guts = ~"[^ğ—®-ğ˜‡ó·º—âŸ¦â›â›â€ºó·¹¹]+"
str_escape = ó°†´"â›â›" ~â€¹.â€º
str_py = ((â€¹"â€º (str_py_sub âˆ¨ ~â€¹[^"\\]+â€º)* â€¹"â€º)
       âˆ¨  (â€¹'â€º (str_py_sub âˆ¨ ~â€¹[^'\\]+â€º)* â€¹'â€º))

str_py_sub = ~â€¹\\.â€º

Æ¦expr = (â ¶Æ¦atom âˆ¨ Æ¦op âˆ¨ ó°†´ğ—ª)*
Æ¦atom = Æ¦section âˆ¨ Æ¦range âˆ¨ Æ¦ESC âˆ¨ Æ¦CHR

Æ¦range   = ó°†´(â€¹â…â€º ğ—ª?) (Æ¦charset âˆ¨ Æ¦rchar)+ ó°†´(ğ—ª? â€¹â†â€º)
Æ¦section = ó°†´(â€¹âŸ¨â€º ğ—ª?) Æ¦mat_name (ó°†´ğ—ª? â†· Æ¦mat_body) Æ¦mat_func ó°†´(ğ—ª? â€¹âŸ©â€º)

Æ¦mat_name = Æ¨((ó°†´ğ—ª âˆ¨ Æ¦ESC âˆ¨ Æ¦CHR)*) ó°†´â€¹â­¡â€º âˆ¨ âœ“
Æ¦mat_body = Æ¦expr
Æ¦mat_func = ó°†´â€¹â­£â€º exprs âˆ¨ âœ“

Æ¦charset = â ¶Æ¦rchar â†· ó°†´(ğ—ª? â†· "â€¦")
Æ¦rchar = â ¶Æ¦ESC âˆ¨ ~â€¹[^â€¦â†]â€º

Æ¦op = Æ¦rrepeat âˆ¨ ~â€¹[â†’Â¿âŒâ¨â¨€âˆ¨]â€º
Æ¦rrepeat = (  ó°†´(â€¹âŸ®â€º ğ—ª?) (
                ((Æ¦INTâˆ¨âœ“) â†· ó°†´(ğ—ª? â†· â€¹,â€º))
                âˆ¨ Æ¦INT
           ) ó°†´(ğ—ª? â€¹âŸ¯â€º) )

Æ¦ESC = ó°†´"â" ~â€¹.â€º
Æ¦INT = ~â€¹[0-9]+â€º
Æ¦CHR = ~â€¹[^ \n\tâ­£â­¡â…â†âŸ¨âŸ©âŸ®âŸ¯âˆ¨â†’âŒÂ¿â¨â¨€]â€º

ğ˜„ = ~â€¹([ \t]*â›â›\n[ \t]*)+|[ \t]+â€º
ğ—ª = ~â€¹[ \t\n]+â€º
text_breaker = â®(E âˆ¨ kw_spec âˆ¨ var_spec âˆ¨ Â¬var)
E = ğ˜„ âˆ¨ ~â€¹â›â›\nâ€º
Ã† = ğ—ª âˆ¨ ~â€¹â›â›\nâ€º

comment = ~â€¹((î¬¦|#)[^\n]*(?=\n|\Z))|(ğŸŸ‘[^ğŸŸ‘]*(ğŸŸ‘|\Z))|(Ö[^Ö]*(Ö|\Z))â€º

Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â«Â« GENERATORS Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»Â»

# Â§ tree manipulation
KEYWORD_NODE_NAMES = ("kw", "kw_pfx", "kw_pfx_colon")

def Ïƒ_00():
    TL, TR = á”.maketrans("ó·º¹ó·ººó·º»ó·º¼","á‘€áµá’á–"), á”.maketrans("ó·º½ó·º¾ó·º¿ó·»€","á‘…á‘ˆá˜á›")
    
    @(yield replacement("lamb_tacit", rec='A', n="Reform tacit exprs"))
    def _(n):
        bl, l, Î», r, br = n
        bl, l,    r, br = bl.as_txt(), l.as_txt(), r.as_txt(), br.as_txt()
        if Î».t in {"exprs", "expr", "expr_norm"}:
            Î±, Î² = Î»[0].c, Î»[-1].c 
        else:
            Î± = Î² = Î».c
        
        if l in "ó·º¹ó·º»ó·ººó·º¼": bl, l = â´³, l.translate(TL)
        if r in "ó·º½ó·º¿ó·º¾ó·»€": br, r = â´³, r.translate(TR)
        
        l, r = l or (r and "á³" or "á‘€"), r or "á¸"
        
        args, targs = [], [NUM_M1, NUM_M1]
        OP_NAME = "â€TACIT"
        
        if l and l in "á‘€áµá’á–":
            if not bl: OP_NAME += "L"
            if l in "á‘€áµ": Î±.insert(0, TACTACK_L)
            targs[0] = NUM_P1 if (l in "áµá–") else NUM_P0
            args.append(TACTACK_L)
        if r and r in "á‘…á‘ˆá˜á›":
            if not br: OP_NAME += "R" 
            if r in "á‘…á‘ˆ": Î².append(   TACTACK_R)
            targs[1] = NUM_P1 if (r in "á‘ˆá›") else NUM_P0
            args.append(TACTACK_R)
        
        COM = OP.TND(',')
        args, targs = JÌ(args, COM), JÌ(targs, COM, l=â´³)
        
        if args: args.append(COM)
        args.extend([OP.TND("â ¤"), mkvar("ğ“"), COM,
                     OP.TND("â ¶"), mkvar("ğ“š")])
        
        return Åƒ("oper",
            ("oper_mod_l", á¦), ("oper_lit", OP_NAME),
            ("oper_mod_r", mkgxp(
                ("lamb", ("lamb_h_normal", *args),
                         ("lamb_b", ("norm_expr", Î»))),
                *targs)))

def Ïƒ_03():
    @(yield replacement(*KEYWORD_NODE_NAMES, n="Lang keywords â†’ cpy keywords"))
    def _(n):
        txt = n.as_txt()
        # keyword that are just ops:
        if txt in kw_inline: return OP.TND(KEYWORDS_TO_CPY.get(txt, txt))
        return n.copy(c=KEYWORDS_TO_CPY.get(txt, txt))
    
    @(yield reduction("supscript", n="Swap Superscripts"))
    def _(n):
        t = gram(SCRIPT.nrm(n.as_txt()), "exprs")
        txt = t.as_txt()
        T = lang(txt.strip())
        if not T.isidentifier() or T in escaped_var_specs:
            return [OP.TND('âŒƒ'), mkgxp_(Node(c=lang(txt)))]
        return [OP.TND('.'), t]
    
    ((yield replacement("subscript", rec='A', n="Subscripts to brackets"))
    (lambda n: mkgrp(tree_transform(gram(SCRIPT.nrm(n.c), "exprs"), 3+1), b="[]")))
    
    ((yield replacement("norm_expr", "expr_not_colon", "expr_not_comma", rec='B',
                        n="Normalize expression types"))
    (lambda n: n.copy("expr")))
    
    ((yield replacement("W", n="Trim whitespace"))
    (lambda n: n.copy(c=Å„ in n.c and Å„+âµ‰(n.c,Å„)[-1] or n.c)))

def Ïƒ_05():
    op_chk = lambda n, o: n.t == "oper" and n.as_txt() == o
    hs_op = lambda C, o: â´¸(op_chk(c, o) for c in C)

    @(yield replacement("expr", rec='A', n="Detect for_expr"))
    def _(N):
        if not hs_op(C := N.C, 'âˆ€'): return N
        
        Î±, _, Î² = part(C, Ï(op_chk, o='âˆ€'))
        Î², _, Î³ = part(Î², Ï(op_chk, o='âˆˆ'))
        if hs_op(Î³, 'Â¿'):
            Î³, _, Ïƒ = part(Î³, Ï(op_chk, o='Â¿'))
        else:
            Ïƒ = None
        
        cc = [Node("expr", Î±), Node("expr", Î²), Node("expr", Î³)]
        if Ïƒ: cc.append(Node("expr", Ïƒ, e="cond"))
        return N.copy("for_expr", c=cc)
    
    @(yield replacement("kw_pfx_colon_expr", rec='A', n="Detect for_stmt"))
    def _(N):
        if not op_chk(N.C[0], 'âˆ€'): return N
        Î±, _, Î² = part(N.C[1].C, Ï(op_chk, o='âˆˆ'))
        return N.copy("for_stmt", c=[Node("expr", Î±), Node("expr", Î²), *N.C[2:]])

def Ïƒ_10():
    ((yield replacement("parser_main", rec='A', n="Build whitespace blocks"))
    (whitespace_parser))

def Ïƒ_15():
    yield "Refactor lambdas"
    ((yield replacement("lamb_h_preset"))
    (lambda n: Åƒ("lamb_h",
            *á´(lambda t: mkexp(mkvar(t)), "xyzwvutsr"[:"ğš²ó°²¡ó°²£ó°²¥ó°²§ó°²©ó°²«ó°²­ó°²¯ó°²±".index(n.c)]),
            ARG_A, ARG_K)))
    
    ((yield replacement("lamb_h_implicit"))
    (lambda n: Åƒ("lamb_h", mkexp(n.C[0]), ARG_A, ARG_K)))
    
    @(yield replacement("lamb_h_normal", "lamb_h_py"))
    def _(n):
        C = á´(Node.strip,
              êŸ¿(mkexp,
                 split_at(
                    n.C,
                    lambda x: OP.is_op(x) and (k:=op_man[x]).t == ',')))
        has_a = has_k = â´´
        
        C = á–µ(lambda x: x.as_txt(), C) # b/c â¥Œâ†¦ has empty an expr
        for c in C:
            if not c.C or (o:=c.C[0]) != "oper": continue
            k = o.C[1].c
            if   k in ( "*", "â ¤"): has_a = â´³
            elif k in ("**", "â ¶"): has_k = â´³
            else                 : continue
            if len(c) == 1:
                c.C[0] = Åƒ("expr_", '*'+'*'*(k=="**" or k=='â ¶'))
        if not has_a: C.append(ARG_A)
        if not has_k: C.append(ARG_K)
        return Åƒ("lamb_h", *C)
    
    ((yield replacement("lamb_b", rec='A'))
    (lambda n: n.copy(t="expr")))

def Ïƒ_18():
    @(yield replacement("expr", rec='B', n="Implicit Multiplication"))
    def _(n):
        if not n.C: return n
        cc, s = [], peekable(n.C)
        while True:
            Î± = next(s)
            if not s: break
            Î² = s.peek()
            cc.append(Î±)
            
            S = { "number": {"var", "group", "var_spec", "number"},
                  "var_spec": {"number", "var", "var_spec"} }
            # ó°¤± condition for 2âˆš2
            if    Î±.t in S and Î².t in S[Î±.t] \
               or Î².t in S and Î±.t in S[Î².t] \
               or Î±.t == "group" and Î².t == "var_spec": # ó°¤± this is weird
                    cc.append(OP.TND("â€CAT"))
        cc.append(Î±)
        return n.copy(c=cc)

def Ïƒ_19():
    @(yield replacement("expr", rec='B', n="Add dummy variables"))
    def _(n):
        c, i = n.c, 0
        while i < len(c):
            x = c[i]
            if x.t == "oper":
                txt = x.c[1].as_txt()
                if   txt in "ó·¸Šó·¸‹": c[i+1:i+1] = [mkvar("â€DUM")]
                elif txt in "ó·¸Œó·¸": c[i  :i  ] = [mkvar("â€DUM")]
                else:
                    i += 1
                    continue
                i += 1
            i += 1
        return n

def Ïƒ_20():
    ((yield replacement("expr", rec='B', n="Parse expressions"))
    (lambda n: n.copy(c=into_expr(parse_expr(n.C)).c)))

def Ïƒ_21():
    def split_target(l):
        l, t = l.copy(), []
        while l:
            Î± = l.pop()
            if Î± == '.':
                return '.', l, t[0]
            if Î±.t == "op_call":
                assert Î±.C[1].as_txt() == '.'
                l.extend([*Î±.C[0], '.', *Î±.C[2]])
                continue
            if Î±.t == "group" and (Î±.C[0].as_txt(), Î±.C[2].as_txt()) == ('[', ']'):
                return 'l', l, Î±.C[1]
            t.insert(0, Î±)
        assert âµŒ(t) == 1
        return á¦, á—œ, t[0]

    # xî “ó·¸ŠğŸƒŒ âŸ¶ â–º(GI(xâ†‘,yâ†‘)â†‘, SI(â†“ô§,â†“ô§°,ğŸƒŒâ†“))
    # ğŸƒŒó·¸Œxî “ âŸ¶ â–º(GI(xâ†‘,yâ†‘)â†‘, SI(â†“ô§,â†“ô§°,â†“ğŸƒŒ))
    # xî “ó·¸‹ğŸƒŒ âŸ¶ â—„(GI(xâ†‘,yâ†‘)â†‘, SI(â†“ô§,â†“ô§°,ğŸƒŒâ†“))
    # ğŸƒŒó·¸xî “ âŸ¶ â—„(GI(xâ†‘,yâ†‘)â†‘, SI(â†“ô§,â†“ô§°,â†“ğŸƒŒ))
    
    def make_inline_asgn(Î±, Î£, Î²): # optimization: pull out some constant nodes
        # ó°¤±ôŠ½¨ â‰• and stuff should do eval b4 var ref?
        (Ï„, Îº, Ï‡), Ïƒ = split_target(Î±.C), Î£.as_txt()
        if Ï„:
            Ï = "ATTR" if Ï„ == '.' else "ITEM"
            Îº = mkgxp(*(Node("expr_", '.') if i == '.' else i for i in Îº))
            Ï‡ = mkgxp(("str_", f'"{py_escape_var(Ï‡.as_txt())}"') if Ï == "ATTR" else Ï‡)
            ST, GT = mkvar("SET"+Ï), mkvar("GET"+Ï)
        
        # https://ganer.xyz/s/b92fe70c1a9eb090 https://ganer.xyz/s/584893fc23aafb70
        if Ïƒ in "ó·¸Šó·¸‹ó·¸Œó·¸":
            outer = mkvar("RET_"+('L' if Ïƒ in "ó·¸‹ó·¸" else 'R'))
            find_dum = lambda n: n.t == "var" and n.as_txt() == "â€DUM"
            if Ï„:
                larg = fcall_(Ã¾PSH, fcall_(GT, fcall_(Ã¾PSH, Îº), fcall_(Ã¾PSH, Ï‡)))
                rarg = fcall_(ST, Ã¾POP_M3, Ã¾POP_M2, Î².find_replace(find_dum, lambda n: Ã¾POP_M1), NUM_P0)
                return fcall_(outer, larg, rarg)
            v = mkgrp(mknex_(Ï‡, mkgxp(Î².find_replace(find_dum, lambda n: Ï‡))))
            return fcall_(outer, Ï‡, v) if Ïƒ in "ó·¸‹ó·¸" else v
        if Ïƒ in "ó·¸‰ó·¸": # https://ganer.xyz/s/bd0de51c7f02dac6
            if not Ï„:
                larg = fcall_(ST, Ã¾POP_M3, Ã¾POP_M2, Î², NUM_P0)
                rarg = fcall_(Ã¾PSH, fcall_(GT, fcall_(Ã¾PSH, Îº), fcall_(Ã¾PSH, Ï‡)))
                return fcall_(mkvar("RET_L"), larg, rarg)
            return fcall_(ST, Îº, Ï‡, Î², NUM_P0)
        
        if not Ï„:
            v = Î² if Ïƒ in {*"â‰”â‰•", ":="} else ("op_call", mkexp(Ï‡), Î£, Î²)
            return mkgrp(mknex_(Ï‡, mkgxp(v)))
        
        if Ïƒ in {*"â‰”â‰•", ":="}:
            return fcall_(ST, Îº, Ï‡, Î², NUM_P0)

        return fcall_(ST, # +=, Å¿=, etcâ€¦
            fcall_(Ã¾PSH, Îº),
            fcall_(Ã¾PSH, Ï‡),
            Node("op_call", [
                fcall_(GT, Ã¾POP_M2, Ã¾POP_M1), Î£, Î²]),
            NUM_P0)
        
    
    @(yield replacement("op_call", rec='A', n="Refactor assignment infix opertators"))
    def _(n):
        Î±, Î£, Î² = n.C
        if Î£.c[0].as_txt() or Î£.c[2].as_txt(): return n # ó°¤± allow mods
        
        Ïƒ = Î£.as_txt()
        if Ïƒ in {*"â‰”ó·¸Šó·¸‹", ":="}: return make_inline_asgn(Î±, Î£, Î²)
        if Ïƒ in {*"â‰•ó·¸Œó·¸"      }: return make_inline_asgn(Î², Î£, Î±)
        if '=' not in lang.ops[Ïƒ]: return n
        Î£ = OP.TND(Ïƒ[:-1])
        return make_inline_asgn(Î±, Î£, Î²)

def Ïƒ_25():
    @(yield reduction("op_call", rec='B', n="Flatten cmp ops"))
    def _(n):
        if 'Î»' in op_man[n.C[1]] and \
                n.C[0] != NULL and n.C[2] != NULL:
            return [*n.C[0].C, n.C[1], *n.C[2].C]
        return [n]

def Ïƒ_30():
    def make_cmp_chain(n, layers=á—œ):
        layers = layers or OPS_COMP
        layer, *layers = layers
        
        rec = lambda n: layers and make_cmp_chain(n, layers=layers) or n
        mkexp_rec = lambda N: rec(mkexp(*N))
        
        C = á’ª(split_at(n.C,
            lambda x: OP.is_op(x) and (k:=op_man[x]).t in layer and k.B,
            keep_separator=â´³))
        if âµŒ(C) < 3: return rec(n)
        r = â´´
        
        for H,T,(a,(b,),c) in mark_ends(windowed(C, 3, step=2)):
            # if b[1].c == 'âˆ¨' and âµŒ(C) > 3:
            #     b[1].c = 'â©”'
            c = mkexp_rec(c)
            v = mkexp(("op_call",
                H and mkexp_rec(a) or Ã¾Ã¾,
                b,
                T and c or mknex_(Ã¾Ã¾, c)))
            r = mkexp(("op_call", r, OP.TND('âˆ§'), v)) if r else v
        return n.copy(c=[r])
    ((yield replacement("expr", rec='B', n="Generate comparison chains"))
    (make_cmp_chain))

demodp = lambda o: (o.C[0].as_txt(), o.C[1], o.C[2].as_txt() if o.C[2].S else o.C[2])
def mkbltnop(op_l): # format builtins if needed
    t = SWAP_TABLE.get(t := op_l.as_txt(), t)
    if t not in OPS_BUILTIN['A']: return op_l
    return mkexp(mkvar("LITERAL_OPS_"), mkgrp(mkstr(t), b="[]"))
def transform_oper(op_): # apply modifiers to op
    m_l, op_l, m_r = demodp(op_)
    # if op_l in "Â¿Â¡â­œâ­": # ó°¤±
    if not (m_l or m_r): return op_l
    op_n = mkbltnop(op_l)
    mkmod = lambda op, x: mkexp(mkvar(f"OP_{x}_"), mkgrp(op))
    
    if 'â‰º' in m_l: op_n = mkmod(op_n, "BSTAR")
    if 'âŸ¥' in m_l: op_n = mkmod(op_n, "LNULL")
    
    if isinstance(m_r, Node): return mkexp(op_n, mkgxp(m_r, b="[]"))
    rmods = á¦
    for m in m_r:
        if m in "âŸ¤áµœêœ Â´":
            match m:
                case 'âŸ¤': op_n = mkmod(op_n, "RNULL")
                case 'áµœ': op_n = mkmod(op_n, "SWAPA")
                case 'êœ ': op_n = mkmod(op_n, "DUPER")
        else:
            rmods += m
    if rmods:
        o = set() if 'Ï‡' in op_man[op_] else ascii_uppercase
        rmods = á’(',', (f'"{x}"' if frozenset(x).issubset(o) else lang(x) \
                    for x in SCRIPT.nrm(rmods).split('ğ‘')))
        op_n = mkexp(op_n, Node("expr_", f'[{rmods}]'))
    return op_n

def Ïƒ_35():
    hnul = lambda x: x.copy("NULL_") if x == "NULL" else x
    
    def try_builtin(m, op_l, L, m_l, t, m_r, R): # see if op + arg matches can make a builtin
        if m_l or m_r: return
        if SWAP_TABLE.get(t, t) not in OPS_BUILTIN[m]: return
        return mkgxp(*Îµ(L), op_l, *Îµ(R))

    def make_if(t, l, r, m_l, m_r):
        return Åƒ(t, l, r, m_l, m_r)
    def make_el(t, l, r, m_l, m_r):
        assert l[0].t in "â­œÂ¿"
        if t=='â­': return mkgxp(l[0][1], OP.TND('Â¿'), l[0][0], OP.TND('Â¡'), r)
        if t=='Â¡': return mkgxp(l[0][0], OP.TND('Â¿'), l[0][1], OP.TND('Â¡'), r)

    @(yield replacement("op_call", rec='B', n="Refactor op calls"))
    def _(n):
        l, op_, r = n.C
        op = op_man[op_]
        t = KEYWORDS_TO_CPY.get(op.t, op.t)
        m_l, op_l, m_r = demodp(op_)
        L, R = l != NULL and mkgrp(l), r != NULL and mkgrp(r)
        
        if not (m_l or m_r):
            if 'Î²' in op and     L and R: return mkgxp(L, op_l, R)
            if 'Ïƒ' in op and not L and R: return mkexp(op_l, r)
            if 'Î¹' in op: return mkexp(hnul(l), op_l, hnul(r))
            if 'Ï' in op:
                if t in 'â¡â†’â­¢'           : return L
                if t in 'â¬…â†â­ '           : return R
                if t in 'â‰”ó·¸‰'            : return mkgxp(l, op_l, R)
                if t in 'â‰•ó·¸'            : return mkgxp(l, op_l, R)
                if t == 'â¥‰'             : return mkgxp(R, L)
                if t == 'Â¬' and (L or R): return mkgxp(op_l, L or R)
        if t in 'â­œÂ¿'            : return make_if(t, l, r, m_l, m_r)
        if t in 'â­Â¡'            : return make_el(t, l, r, m_l, m_r)
        if t == "ó·º¥": # xâ­œâœ—â­yâ­œxâ­âœ“
            return mkgxp(
                FALSE,
                    OP.TND('Â¿'),
                fcall_(Ã¾PSH, ğ“›),
                    OP.TND('Â¡'),
                mkgxp(
                    Ã¾POP_M1,
                        OP.TND('Â¿'),
                    ğ“¡,
                        OP.TND('Â¡'),
                    mkgxp(Ã¾POPNR, Åƒ("oper_lit", 'âˆ¨'), TRUE)))
        if t == "ó·º’": # xâ­œ(yâ­œâœ—â­x)â­âœ“
            return mkgxp(
                mkgxp(
                    mkgxp(Ã¾POPNR, Åƒ("oper_lit", 'âˆ¨'), FALSE),
                        OP.TND('Â¿'),
                    ğ“¡,
                        OP.TND('Â¡'),
                    Ã¾POP_M1
                ),  OP.TND('Â¿'),
                fcall_(Ã¾PSH, ğ“›),
                    OP.TND('Â¡'),
                TRUE)
        
        A = (transform_oper(op_), L, m_l, t, m_r, R)
        tb, mblo = try_builtin, mkbltnop
        if op.S and L       and not op.B: return tb('S', *A) or mkexp(mblo(op_), L)
        if op.P       and R and not op.B: return tb('P', *A) or mkexp(mblo(op_), R)
        if op.B and L and R             : return tb('B', *A) or mkexp(mblo(op_), mkgxp(   l, COMMA,    r))
        if op.S and L                   : return tb('S', *A) or mkexp(mblo(op_), mkgxp(   l, COMMA, NULL))
        if op.P       and R             : return tb('P', *A) or mkexp(mblo(op_), mkgxp(NULL, COMMA,    r))
        if op.N and 'Î½' in op           : return mkexp(mblo(op_), mkgxp())
        return mkbltnop(op_)

def Ïƒ_36():
    @(yield replacement("â­œ", rec='B', n="Refactor elseless â­œ"))
    def _(n):
        return mkgxp(n[1], OP.TND("Â¿"), n[0], OP.TND("Â¡"), mkvar("None"))

def Ïƒ_40():
    @(yield replacement("oper", rec='A', n="Refactor sitting ops"))
    def _(n):
        if n.C[1].as_txt() in kw_neverswouce: return n
        if not (n.C[2].as_txt() or n.C[0].as_txt()):
            n = n.copy(c=[n.C[0], n.C[1], n.C[2].copy(c="Â´")])
        return transform_oper(n)
    
    ((yield replacement(*KEYWORD_NODE_NAMES, "oper_lit",
                        n="Lang keywords â† cpy keywords"))
    (lambda n: n.copy(c=py_escape_var(SWAP_TABLE.get(txt:=n.as_txt(), txt)))))
    
    ((yield replacement("lamb", rec='B', n="Format lambda"))
    (lambda n: mkgxp(n.C[0], mkgrp(n.C[1]))))
    
    ((yield replacement("lamb_h", rec='B', n="Format lambda header"))
    (lambda n: Åƒ("lamb_h", ("kw", "lambda"), *JÌ(n.C, COMMA), ("oper_lit", ":"))))

def Ïƒ_45():
    ((yield replacement("parser_main", rec='A', n="Unparse whitespace"))
    (whitespace_unparser))
    
    ((yield reduction("BLOCK", rec='B', n="Flatten blocks"))
    (lambda n: n.C))

def Ïƒ_48():
    ((yield replacement("for_expr", rec='B', n="Build for exprs"))
    (lambda n: Åƒ(
        "expr",
        n.C[0], ("kw", "for"), n.C[1], ("kw", "in"), n.C[2],
        *([("kw", "if"), n.C[3]] if n['cond'] else []))))
    
    ((yield replacement("for_stmt", rec='B', n="Build for stmt"))
    (lambda n: Åƒ(
        "kw_pfx_colon_expr",
        ("kw_pfx_colon", "for"),
        ("expr", n.C[0], ("kw", "in"), n.C[1]),
        *n.C[2:])))

def Ïƒ_50():
    ((yield replacement("kw_pfx_colon_expr", rec='B', n="Add colons"))
    (lambda n: n.insert_after_marker('M', COLON)))
    
    ((yield replacement("parser_main", rec='B', n="Insert spaces"))
    (Ï(add_spaces, ignore_nodes=("str_cpy", "str_py", "str_star", "str_$"))))

# Â§Â§Â§ node transpilers Â§Â§Â§
generator(*KEYWORD_NODE_NAMES, "oper_lit", "var", "var_spec")(lambda n: py_escape_var(n.as_txt()))
generator("NULL")(lambda n: "NULL")

@generator("group")
def gen_group        (n):
    txt = n.C[0].as_txt()
    if txt == 'âŸ¦': # broken mostly
        content = next(filter(âµ, á´(gen, n.C[1:-1])))
        return f'''(exec("def _EXE():\\n{py_escape_string(force_indent(content))}",globals(),locals()),_EXE)[1]()'''
    return txt + á’(á¦, á´(gen, n.C[1:-1])) + n.C[-1].as_txt()

generator("str_guts"              )(lambda n: py_escape_string(n.as_txt()))
generator("str_escape", "str_star")(lambda n: "'" + py_escape_string(n.as_txt()) + "'")
generator("str_sub"               )(lambda n: "{" + gen(n.C[0]) + "}")
generator("str_spec_char"         )(lambda n: "'" + py_special_mapper(n.as_txt()) + "'")

def make_str_cpy(n):
    r='""f"'
    for c in n.c:
        if   c.t == "str_escape"   : r += py_escape_string(c.as_txt())
        elif c.t == "str_spec_char": r += py_special_mapper(c.as_txt())
        else                       : r += gen(c)
    return r + '"'

generator("neg_num")(lambda n: f"(-{UPSIDEDOWNSYNDROME.flip(n.as_txt())})")
generator("str_cpy")(make_str_cpy)

@generator("str_$")
def make_str_money(n):
    s, *C = n.c
    return f'SUBPROCA({make_str_cpy(n.copy(c=C))},"{py_escape_string(SCRIPT.nrm(s.as_txt()))}")'