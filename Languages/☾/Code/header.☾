 󰛔󰘬
 Star versions of: 󰈲󰈳󰒼󰒽󰑅󰑁󰑃 ?
 10⭥ ᗒ²+⟞   ⟶   10⭥ᴍ¹⥌⟞↦⟞²+⟞
   5 ᗌ²+⟞   ⟶  (5,)ᴍ⁰⥌⟞↦⟞²+⟞
   5 ᗌ²+ᗏ 6 ⟶ (5,6)ꟿ⁰⥌⟞,⟝↦⟞²+⟝
 ᗏᗕ ⟝⟞ ᗒᗌ
 x ⭜ y ⭝ z

exec ← "from math import *"
󰆴 factorial, e, pi, tau, sqrt, cbrt, pow
𝑜,𝑑,𝑏,𝑙,𝑡,𝑠,ᔐ,𝑖,𝑓 = object, dict, bool, list, tuple, set, str, int, float
⮌ py_naming_tools ⨡ py_escape_var as PEV
⮌ functools ⨡ reduce
⮌ itertools ⨡ starmap, filterfalse, product, accumulate, zip_longest

LITERAL_OPS_ = {
      ␛∧:󰲣x∧y,  ␛∨:󰲣x∨y,
      ␛*:󰲣x⋅y,  ␛/:󰲣x/y,   ␛<:󰲣x <y,  ␛>:󰲣x >y,
      ␛|:󰲣x|y,  ␛&:󰲣x&y,   ␛^:󰲣x ^y,  ␛%:󰲣x %y,
    ␛=␛=:󰲣x≡y,␛!␛=:󰲣x≠y, ␛<␛=:󰲣x ≤y,␛>␛=:󰲣x ≥y,
    ␛/␛/:󰲣x⹏y,␛*␛*:󰲣x⌃y, ␛<␛<:󰲣x<<y,␛>␛>:󰲣x>>y,
      ␛+:𝚲+𝔸ᵥ ¿𝔸ᵥ􊮝₀≅␀∨𝔸ᵥ􊮝₁≅␀¡ 𝔸₀+𝔸₁,
      ␛-:𝚲-𝔸ᵥ ¿𝔸ᵥ􊮝₀≅␀∨𝔸ᵥ􊮝₁≅␀¡ 𝔸₀-𝔸₁,
    "not":󰲡¬x,
    "is":󰲣x≅y, "is not":󰲣x≇y,
    "in":󰲣x∈y, "not in":󰲣x∉y }

þSTACK = []
GETATTR = 󰲣getattr(x,y)
SETATTR = 󰲥setattr(x,y,z) ∨ z
GETITEM = 󰲣x.__getitem__(y)
SETITEM = 󰲥x.__setitem__(y,z) ∨ z
þPSH, þPOP = 󰲡þSTACK.append(x)∨x, 󰲡þSTACK.pop(x)

OP_DUPER_ = ƒ↦󰲡ƒ(x,x,⠤𝔸,⠶𝕂) # ꜠
OP_SWAPA_ = ƒ↦󰲣ƒ(y,x,⠤𝔸,⠶𝕂) # ᵜ
OP_LNULL_ = ƒ↦󰲡ƒ(␀,x,⠤𝔸,⠶𝕂) # ⟥
OP_RNULL_ = ƒ↦󰲡ƒ(x,␀,⠤𝔸,⠶𝕂) # ⟤
OP_BSTAR_ = ƒ↦󰲡ƒ(⠤x ,⠤𝔸,⠶𝕂) # ≺
NULL = ␀ = 𝑜()

✓,✗ = True, False
𝒞ℳ, 𝒮ℳ, 𝗙 = classmethod, staticmethod, callable
ᗜ = □ = None
π = 3.14159265358979323
ℇ = 2.71828182845904523
î = complex(0, 1)
↉ = 0  bruh
½,⅓,¼,⅕,⅙,⅐,⅛,⅑,⅒ = 1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10
⅔,⅖ = 2/3,2/5
¾,⅗,⅜ = 3/4,3/5,3/8
⅘ = 4/5
⅚,⅝ = 5/6,5/8
⅞ = 7/8
∞, ᐦ, τ, 󷺍 = inf, '', 2⋅π, ½⋅π
󷱪, 󷱫, 󷱬, 󷱭, 󷱮 = -î, -ℇ, -τ, -π, -󷺍

𝕝, 𝕣 = 󰲡[⠤𝔸]¿x≅␀¡[x], 󰲡x󰈳󰲡x≅␀
𝗜 = is_iter = 󰲡hasattr(x,"__iter__")

Ω 𝑐𝑑(𝑑):
    ⊢ __init__(𝕊, ƒ, ⠤𝔸, 𝑔=□, ⠶𝕂):
        𝕊.ƒ, 𝕊.𝑔 = ƒ, 𝑔
        super().__init__(⠤𝔸,⠶𝕂)
    __call__ = 𝕊↦𝕊.ƒ(⠤𝔸,⠶𝕂)
    __repr__ = 𝕊↦𝕊["__repr__"](𝕊)¿"__repr__"∈𝕊¡super().__repr__()
    __getitem__ = ⥌𝕊,x↦super().__getitem__(x) ¿x∈𝕊¡ 𝕊.𝑔(x)
⊢ BINWRAP_(ƒ):
    Ω ω:
        ⊢ __call__(𝕊, x=␀, y=␀, ⠶𝕂):
            ¿x≅␀: x,y = y,x
            ¿y≅␀: ↪ ƒ(x, ⠶𝕂)
            ↪ ƒ(x,y,⠶𝕂)
        __getitem__ = ⥌𝕊,s↦𝚲𝕊(⠤𝔸, s=s, ⠶𝕂)
    ↪ ω()

⬤ = 𝑜()
⊢ ´(ƒ):
    ⊢ 𝒻(⠤𝜶,⠶𝜿):
        ⊢ 𝑓(⠤𝔸,⠶𝕂):
            𝓐, 𝔸 = 𝑙(𝜶), 𝑙(𝔸)
            𝓚 = 𝑙(𝜿.items())
            a, k = [], {}
            ➰𝓐:
                x = 𝓐.pop(0)
                a.append(𝔸.pop(0) ¿x≡⬤¡ x)
            ➰𝓚:
                x, y = 𝓚.pop(0)
                kₓ = 𝔸.pop(0) ¿y≡⬤¡ y
            ↪ ƒ(⠤a+𝔸,⠶k|𝕂)
        ↪ 𝑓
    ↪ 𝒻
´ = 𝑐𝑑(t≔ƒ↦𝚲ƒ(⠤𝔸ᴍ𝑙Σ[], ⠶𝕂), 𝑔=t)

Ω ⴳ(𝑖):
    __new__ = ℂ↦𝑖.__new__(ℂ,1)
    __call__, __repr__ = 𝚲ⴳ, 𝕊↦␛ⴳ
Ω ⴴ(𝑖):
    __new__ = ℂ↦𝑖.__new__(ℂ,0)
    __call__, __repr__ = 𝚲ⴴ, 𝕊↦␛ⴴ
ⴳ, ⴴ = ⴳ(), ⴴ()

⊢ ERROR_TRIANGLE(t, ƒ=␀, 𝑔=␀, 𝑇=Exception):
    v = 𝕣((ƒ, 𝑔))
    ¿v🃌≡1:
        v = v₀
        ¿t≡␛: raise v
        ⊢ r(⠤𝔸, ⠶𝕂):
            try:
                ↪ v(⠤𝔸, ⠶𝕂)
            except 𝑇 as ε:
                ¿t≡␛󰔶: ↪ 𝔸₀¿𝔸¡□
                ¿t≡␛: ↪ ε
    ¡:
        ⊢ r(⠤𝔸, ⠶𝕂):
            try:
                ↪ ƒ(⠤𝔸, ⠶𝕂)
            except 𝑇 as ε:
                ¿t≡␛: ↪ 𝑔
                ¿t≡␛󰔶: ↪ 𝑔(⠤𝔸, ⠶𝕂)
                ¿t≡␛: ↪ 𝑔(ε)
    ↪ r

 = 𝑐𝑑(ƒ≔ERROR_TRIANGLE(␛), 𝑔=󰲡ƒ(𝑇=x))
󰔶 = 𝑐𝑑(ƒ≔ERROR_TRIANGLE(␛󰔶), 𝑔=󰲡ƒ(𝑇=x))
 = 𝑐𝑑(ƒ≔ERROR_TRIANGLE(␛), 𝑔=󰲡ƒ(𝑇=x))

⊢ _get_depths(x):
    ¿¬𝗜(x): ↪{0}
    ¿xᐹᔐ: ↪{1}
    ↪ {w+1 ∀z∈x ∀w∈_get_depths(z)}
⊢ _map_neg_d(x,y,n):  kinda weird ngl
    ¿xᐹᔐ: ↪ [y(z) ∀z∈x] ¿¬n¡ y(x) ¿n≡1¡ x
    ¿0∈d≔_get_depths(x): ↪x ¿n¡ y(x)
    x = [_map_neg_d(z,y,n) ∀z∈x]
    ↪ y(x) ¿n∈d¡ x
⊢ _map_pos_d(x,y,i):
    ¿¬i: ↪y(x)
    ¿xᐹᔐ: ↪[y(z) ∀z∈x]
    ↪ [_map_pos_d(z,y,i-1) ∀z∈x] ¿𝗜(x)¡ y(x)
⊢ _map_d(x,y,n=1):
    ¿n<0: ↪_map_neg_d(x,y,-n-1)
    ↪ _map_pos_d(x,y,2²⁴¿n≡∞¡n)

⊢ _window(𝕏, l=1, r=1, m=✓, s=□, Δ=1):  s≠␀ should mean Δ=1 
    c ≔ (𝕏 ≔ 𝑙←𝕏)🃌
    ¿s≅␀: ↪ 𝕏⭥ₗ﹕₋ᵣ﹕󰃏ᴍ󰲡𝕏ₓ₋ₗ﹕ₓ + 𝕏ₓ⛶⋅𝑏(m) + 𝕏ₓ₊₁﹕ₓ₊ᵣ₊₁
    V = s⛶⋅l +𝕏+ s⛶⋅r
    ↪ 𝕏⭥﹕﹕󰃏ᴍ󰲡Vₓ﹕ₓ₊ₗ + Vₓ₊ₗ⛶⋅𝑏(m) + Vₓ₊ₗ₊₁﹕ₓ₊ₗ₊ᵣ₊₁

Ω 𝑏𝑔:
    __getitem__ = ⥌𝕊,z↦󰲣𝕊.ƒ(x,y,z)
    __call__     =⥌𝕊  ↦ 𝕊.ƒ(⠤𝔸)
Ω ſ´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦reduce    (y,x,⠤(z,)⋅←z≇␀)
Ω Ϝ´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦accumulate(x,y,⠶{}¿z≡␀¡{"initial":z})⥉𝑙
Ω ᙎ´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦_window(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡    1⋄1    , ✗, □¿z≅␀¡z, 1        )
Ω ᙡ´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦_window(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡    1⋄1    , ✓, □¿z≅␀¡z, 1        )
Ω ᗢ´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦_window(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡z≅␀∧1⋄1∨0⋄z, ✗, ␀      , z≅␀∧1∨z+1)
Ω ᙧ´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦_window(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡z≅␀∧1⋄1∨0⋄z, ✓, ␀      , z≅␀∧1∨z+1)
Ω 󰸵´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦(  (l⭥ᴍ(ⴴ¿z≅␀¡z¿𝗙(z)¡𝚲z))+x)¿(l≔y-x🃌)>0¡x
Ω 󰸷´(𝑏𝑔):ƒ=𝒮ℳ← ⥌x,y,z=␀↦(x+(l⭥ᴍ(ⴴ¿z≅␀¡z¿𝗙(z)¡𝚲z))  )¿(l≔y-x🃌)>0¡x

Ω ᴍ´:
    ƒ = 𝒮ℳ(_map_d)
    ⊢ __getitem__(𝕊, i):
        S, ƒ = 𝑠←i ¿iᐹ𝑡¡ (i,), □
        ¿s≔␛D→∈S: ƒ = f↦󰲣type(x)←f(x.items(),y)
        ⸘s≔␛K→∈S: ƒ = f↦󰲣type(x)←f(x.items(),y)ζx.values()
        ⸘s≔␛V→∈S: ƒ = f↦󰲣type(x)←x.keys()ζf(x.items(),y)
        ¿ƒ:
            S.discard(s)
            ↪ ƒ(S ∧ 𝕊[S.pop()] ∨ 𝕊)
        ↪ ⥌x,y,i=i↦𝕊.ƒ(x,y,i)
    __call__ = ⥌𝕊,x,y↦𝕊.ƒ(x,y,1)
Ω ꟿ´(ᴍ´):
    ƒ = 𝒮ℳ(⥌x,y,i↦_map_d(x,󰲡y(⠤(x¿𝗜(x)¡(x,))),i))

Ω √´:
    __getitem__ = ⥌𝕊,x↦⥌y↦y¹􋑬ˣ
    __call__ = ⥌𝕊,x↦x⌃½

√´ = √´()
ᴍ´,ꟿ´,ſ´,Ϝ´ = ᴍ´(),ꟿ´(),ſ´(),Ϝ´()
ᙎ´,ᙡ´,ᗢ´,ᙧ´ = ᙎ´(),ᙡ´(),ᗢ´(),ᙧ´()
󰸵´,󰸷´ = 󰸵´(),󰸷´()

⊢ ⨳´(α=␀, β=␀):
    ¿α≅␀: α,β = β,α
    assert α, "Assertion failed!"¿β≅␀¡β
    ↪ α

⊢ _wherest(𝕏, ƒ=𝑏, I=ⴴ):
    ƒ = ƒ≅␀∧𝑏∨ƒ
    ∀i,x∈↨𝕏:
        ¿ƒ(x): ↪i ¿I¡ x
    ↪ □
ᣆ´ = 𝑐𝑑(ƒ ≔ 󰲣y(x) ¿(𝔸₀ ¿𝔸🃌¡ x)¡ x, 𝑔=a↦󰲣ƒ(x,y,a))
󰑅´ = 𝑐𝑑(_wherest, I=𝚲_wherest(⠤𝔸,I=✓))
󰑁´ = ⥌𝕏,ƒ=𝑏↦□ ¿□≅i≔𝕏󰑅ᴵƒ¡ 𝕏﹕ᵢ
󰑃´ = ⥌𝕏,ƒ=𝑏↦□ ¿□≅i≔𝕏󰑅ᴵƒ¡ 𝕏ᵢ﹕
⊂´ = 󰲣𝑠(x).issubset(𝑠←y)
⊃´ = 󰲣𝑠(y).issubset(𝑠←x)
⊊´ = 󰲣(α≔𝑠←x).issubset(β≔𝑠←y) ∧ α≠β
⊋´ = 󰲣(α≔𝑠←y).issubset(β≔𝑠←x) ∧ α≠β
⊄´ = 󰲣¬(x⊂y)
⊅´ = 󰲣¬(x⊃y)
∋´, ∌´ = 󰲣y∈x, 󰲣y∉x
∣´, ∤´ = 󰲣gcd(x,y)≡x, 󰲣gcd(x,y)≠x
∪´ = 󰲣𝑠(x) | 𝑠(y)
∩´ = 󰲣𝑠(x) & 𝑠(y)
∖´ = 󰲣𝑠(x) - 𝑠(y)
⨉´ = 𝚲product(⠤v₀ ¿(1≡🃌←v≔𝕣(𝔸))¡ v)ᴍ𝑙
∓´ = 𝚲[¯h₀,+h₀]¿(h≔𝕣(𝔸))🃌≡1¡[h₀-h₁,h₀+h₁]
±´ = 𝚲[+h₀,¯h₀]¿(h≔𝕣(𝔸))🃌≡1¡[h₀+h₁,h₀-h₁]

⊢ ᐹ´(x=␀, y=␀):
    ¿x≅␀: ↪type(y)
    ⸘y≅␀: ↪type(x)
    ↪ isinstance(x, y ¿isinstance(y,type)¡ type(y))
🃌 = len
󰻾 = 𝑐𝑑(󰲡x,𝑔=󰲡𝑐𝑑(𝚲x,__repr__=𝚲‹󰻾[⟦x⟧]›),__repr__=𝚲␛󰻾)
ᴙ = 𝑐𝑑(󰲡(x¿xᐹᔐ¡𝑙(x))﹕﹕₋₁, L=󰲡𝑙(x)﹕﹕₋₁)  reverse; ᴙᴸ to force 𝑙
⍉ = 󰲡ζ(⠤x)
⍭ = 󰲡x.split(␛ )ᴍ⍭´ ¿␛ ∈x¡ x.split(␛ )

↨ = 󰲡𝑙←enumerate←x
⭥ = 󰲡𝑙←range←(x ¿xᐹ𝑖¡ x🃌)

⤈, ⤉ = (min,max) ᴍ ƒ↦𝚲ƒ(𝔸₀, key=𝔸₁) ¿𝔸₁﹕∧𝗙(𝔸₁)¡ ƒ(⠤𝕣(𝔸))
ⴵ = sign = 󰲡1¿x>0¡x∧¯1∨0
 󷹄 = 󰲣¿𝕣(𝔸)¡
⛶ = 𝑐𝑑(󰲡[x], S=󰲡{x}, T=󰲡(x,))
▢ = 𝚲round(⠤𝕣(𝔸))
… = 󰲣𝑙←range(x,y)
! = 󰲡󷸺xΠ1
⫰, ⫯ = 󰲡+abs(x), 󰲡¯abs(x)

⊢ ⬄´(x=␀,y=␀):
    ¿x≅␀: x,y=y,x
    ¿xᐹᔐ ∧← y≅␀ ∨ yᐹᔐ:
        ↪x.strip(⠤𝕣((y,)))
    ✗⨳  󰤱
 󰛔 =  󰤱
   (ᔐ,ᔐ): ᔐ.replace
   (𝒾,𝑜):   replace ; 󰛔ʳ
 󰘬 =  󰤱
   (𝒾, ): spl by falsy
   ( ,𝒾): spl by falsy (keep sep)
   (𝒾,ƒ): spl by ƒ
   (ƒ,𝒾): spl by ƒ (keep sep)
   (ᔐ, ): spl by space
   ( ,ᔐ): spl by space (keep sep)
   (ᔐ,ᔐ): spl by arg 2
   (ᔐ,ƒ): spl by ƒ join inner strs
   (ƒ,ᔐ): spl by ƒ (keep sep) join inner strs

◄, ► = 󰲣x, 󰲣y
⊢ ⋀´(𝑋, v=✓):
    ∀v∈𝑋:
        ¿¬v:↪v
    ↪v
⊢ ⋁´(𝑋, v=✗):
    ∀v∈𝑋:
        ¿ v:↪v
    ↪v
☾ = ⥌⠤𝔸,flush=✓↦print(⠤𝔸,flush=flush,⠶𝕂)∨𝔸∧𝔸₀
ζ = 𝚲zip(⠤𝕣(𝔸))ᴍ𝑙
Π = 󰲡ſ´(x,⋅,⠤𝕣(𝔸))
Σ = 󰲡ſ´(x,+,⠤𝕣(𝔸))
󰒼 = 󰲣sorted(x,key=𝕝(y,□)₀)
󰒽 = 󰲣sorted(x,key=𝕝(y,□)₀,reverse=✓)

⊢ 󰈲´(x=␀, y=␀, s=␀, neg=✗):
    ¿s≅*: s=y
    ¿neg: y=¬○y
    ¿s≅␀: ↪ 𝑙←filter(□¿y≅␀¡y, x)
    ¿¬𝗙(s): s=󰻾ˢ
    ¿y≅␀: ↪ 𝑙←filter(□, xᴍs)
    ↪ [s(z)¿y(z)¡z ∀z∈x]
󰈳´ = BINWRAP_(𝚲󰈲´(⠤𝔸,⠶𝕂,neg=✓))
󰈲´ = BINWRAP_(󰈲´)

⊢ RANGE_(x=␀, y=␀, s=␀, 𝕏=␀):
    x≅␀≅y →¬ ⨳‹Range missing both values!›
    ¿𝔰≔s≅␀: s=1
    
    v = y ¿x≅␀¡ x ¿y≅␀¡ ␀
    ¿(v≅␀ ∧ (x≇␀∧xᐹ𝑖) ∧ (y≇␀∧yᐹ𝑖)) ∨ (v≇␀∧vᐹ𝑖):
        ¿v≇␀: x, y = 0, v
        ¿𝕏≡␛󷸹: ↪ [⠤range(x  ,y  ,s)]
        ¿𝕏≡␛󷸺: ↪ [⠤range(x+1,y+1,s)]
        ¿𝕏≡␛󷸸: ↪ [⠤range(x+1,y  ,s)]
        ¿𝕏≡␛󷸻: ↪ [⠤range(x  ,y+1,s)]
    ¿v≇␀:
        𝗜(v) ⨳ ; v=𝑙←v
        ¿𝕏≡␛󷸸: ↪ (v₀, v₁﹕􍨄﹕ₛ, v􍨄)
        ¿𝔰: s=0
        ¿𝕏≡␛󷸹: ↪ v₀₊ₛ
        ¿𝕏≡␛󷸺: ↪ v􍨄₋ₛ
        ¿𝕏≡␛󷸻: ↪ v₀₊ₛ, v􍨄₋ₛ
    ¿𝗜∘x ∧ 𝗜∘y:
        ↪ [xₕ∀h∈y﹕﹕ₛ]
    ¿𝗜∘x ∧ yᐹ𝑖:
        ¿𝕏≡␛󷸹: ↪ x[   :y  :s]
        ¿𝕏≡␛󷸺: ↪ x[0+1:y+1:s]
        ¿𝕏≡␛󷸸: ↪ x[0+1:y  :s]
        ¿𝕏≡␛󷸻: ↪ x[   :y+1:s]
    ¿xᐹ𝑖 ∧ 𝗜∘y:
        ¿𝕏≡␛󷸹: ↪ y[slice(x  ,󷰾,s)]
        ¿𝕏≡␛󷸺: ↪ y[slice(x+1,□,s)]
        ¿𝕏≡␛󷸸: ↪ y[slice(x+1,󷰾,s)]
        ¿𝕏≡␛󷸻: ↪ y[slice(x  ,□,s)]
    ✗⨳‹Invalid arguments! ⟦ᐹx⟧ ⟦ᐹy⟧›
⊢ JOIN_(x=␀, y=␀, s=ᐦ, 𝕏=␀, LR_def=□, bound_mode=␀):
    x≅␀∧␀≅y →¬ ⨳‹Join missing both values!›
    ¿x≅␀: x,y = y,x
    ¿sᐹ𝑡:
        ¿s₀ᐹ𝑖: bound_mode, 𝕏 = s
        ¡    : 𝕏, bound_mode = s
        𝕏ᐹᔐ ∧ bound_modeᐹ𝑖 ⨳ ‹Bad modifiers!›
    ⸘sᐹ𝑖:
        s, bound_mode = ᐦ, s
    ¿bound_mode≅␀: bound_mode = 𝕏≡␛⟗∧1∨0
    ¿x≅␀:
        x,y = y,x
        𝗜(x) ⨳ ‹Single-arg ⟦t⟧ needs an iterable›
        ↪ 𝗻⋅𝕏∈␛⟕␛⟗+ᐦ.join(xᴍᔐ)+␛⟗␛⟖∋𝕏⋅𝗻 → ᣆ􋂝ᴸ􋁉ˢ 𝑙
    
    Y = y
    ¿¬𝗙(y): y=󰻾ʸ
    
    R = []
    ¿x🃌≡0 ∧ (𝕏≠␛⨝ ∨ bound_mode>0):
        v = y(LR_def, LR_def)
        ¿𝕏∈␛⟕␛⟖ ∨ bound_mode≡1: R = [v]
        ¡                     : R = [v,v]
    ¡:
        ¿𝕏∈␛⟕␛⟗: R.append(y(LR_def, x₀))
        ∀i∈x🃌󷸸 : R.extend([xᵢ₋₁, y(xᵢ₋₁, xᵢ)])
        R.append(x􍨄)
        ¿𝕏∈␛⟖␛⟗: R.append(y(x􍨄, LR_def))
    
    ↪ ᐦ.join(Rᴍᔐ) ¿␛L∉s∧Yᐹᔐ¡ R
󷸹´ = BINWRAP_(𝚲RANGE_(⠤𝔸,⠶𝕂,𝕏=␛󷸹))
󷸺´ = BINWRAP_(𝚲RANGE_(⠤𝔸,⠶𝕂,𝕏=␛󷸺))
󷸸´ = BINWRAP_(𝚲RANGE_(⠤𝔸,⠶𝕂,𝕏=␛󷸸))
󷸻´ = BINWRAP_(𝚲RANGE_(⠤𝔸,⠶𝕂,𝕏=␛󷸻))
⨝´ = BINWRAP_(𝚲JOIN_(⠤𝔸,⠶𝕂,𝕏=␛⨝))
⟕´ = BINWRAP_(𝚲JOIN_(⠤𝔸,⠶𝕂,𝕏=␛⟕))
⟖´ = BINWRAP_(𝚲JOIN_(⠤𝔸,⠶𝕂,𝕏=␛⟖))
⟗´ = BINWRAP_(𝚲JOIN_(⠤𝔸,⠶𝕂,𝕏=␛⟗))

 = 𝑐𝑑(𝚲⥌I,ƒ=𝑏↦r≔{}→◄←Iᴍ󰲡r.setdefault(h≔ƒ(x),[]).append(x)󰅂󰅂(⠤𝕣(𝔸),⠶𝕂),
       S=𝚲´(⠤𝔸,⠶𝕂).items 󰒼 ᴍ󰲡x₁,
       B=𝚲h≔{✓:[],✗:[],⠶´(⠤𝔸,⠶𝕂)}→►←[h₀,h₁])

⊢ ´(ƒ,⠤𝔸,⠶𝕂):
    ¿𝗙(ƒ): ↪ ƒ(⠤𝔸,⠶𝕂)
    ¿𝗜(ƒ):
        ∀x∈ƒ: pass
        ↪ ƒ
    ✗⨳‹⟦ƒ⟧ is not iterable or callable.›
∘ = 󰲣x(y)
○ = 󰲣𝚲x(y(⠤𝔸,⠶𝕂))
Ω 𝑙𝑙(𝑙): □
⋄ = 󰲣(x¿xᐹ𝑙𝑙¡x≔𝑙𝑙((x,))).append(y)►x
⨁ = 󰲣𝑏(x)≡𝑏(y)  xand
⊻ = 󰲣𝑏(x)^𝑏(y)  ∧←x∨y  xor
⊼ = 󰲣𝑏(x)∧𝑏(y)→¬∧←x∨y  nand

⊢ ⓦ(⠤𝔸, 𝐀=□):
    𝐀∨=[]
    ⠤𝔸, ƒ = 𝔸
    ¿¬𝔸: ↪ƒ(⠤𝐀)
    𝕒, ⠤𝔸 = 𝔸
    with 𝕒 as 𝐚:
        𝐀.append∘𝐚
        ↪ ⓦ(⠤𝔸, ƒ, 𝐀=𝐀)

 all this be weird
Ω ℵ´(𝑑):
    𝐶𝑛 = ␛ℵ
    __json__ = ⥌𝕊,cb,⠤𝓐,⠶𝓚↦ 𝑑(𝕊) ꟿⱽ 󰲣cb(y,⠤𝓐,⠶𝓚)
    __init__ = 𝕊↦super().__init__(⠤𝔸,⠶𝕂)
    __setattr__ = 𝑑.__setitem__
    __getitem__ = ⥌𝕊,x↦𝑑.__getitem__(𝕊,x) ¿x∈𝕊¡ 𝕊.getdef()
    __getattr__ = __getitem__
    __iter__ = 𝕊↦iter(𝕊.items())
    __repr__ = 𝕊↦‹⟦𝕊.__class__.𝐶𝑛⟧⟦‹[⟦h₀⟧]›¿0∈(h≔𝕊.__dict__)¡ᐦ⟧(⟦␛,𝘀→.join←𝕊.itemsꟿ󰲣‹⟦x⟧=⟦y⟧›⟧)›
    __call__ = 𝕊↦𝑑.update(𝕊,⠤𝔸,⠶𝕂)►𝕊
    __bool__ = 𝕊↦𝕊🃌>0
    __or__   = ⥌𝕊,x↦𝕊.copy()(x)
    ⊢ __getstate__(𝕊):
        ¿𝕊.hasdef(): ↪𝑑(𝕊), 𝕊.getdef()
        ¡          : ↪𝑑(𝕊),
    ⊢ __setstate__(𝕊, s):
        𝕊.__init__(s₀)
        ¿s🃌 > 1: 𝕊.setdef(s₁)
    ⊢ __pow__(𝕊, x):
        ¿x≡-: ↪𝑙∘𝕊.keys   
        ¿x≡+: ↪𝑙∘𝕊.values 
        ¿x≡*: ↪𝑙∘𝕊.items  
        ✗⨳
    hasdef = ⥌𝕊↦0∈𝕊.__dict__
    getdef = ⥌𝕊  ↦𝕊.__dict__₀
    setdef = ⥌𝕊,x↦𝕊.__dict__₀≔x →► 𝕊
    ⊢ copy(𝕊):
        r = type(𝕊)(super().copy())
        ¿𝕊.hasdef(): r.setdef(𝕊.getdef())
        ↪ r
Ω ℶ(ℵ´):
    𝐶𝑛 = ␛ℶ
    __iter__ = 𝕊↦iter(𝕊.values())
Ω _hwrap(𝑑):
    ⊢ __init__(𝕊, 𝑐):
        𝕊􋇑, 𝕊􋇛 = 𝑐, 𝑐􋆷􋇛
    __getitem__ = ⥌𝕊,x↦𝕊􋇑().setdef(x)
    __setitem__ = ⥌𝕊,x,y↦(⒯≔𝕊􋇑()).__setitem__(x,y) →►← ⒯
    __call__ = 𝕊↦𝕊􋇑(⠤𝔸,⠶𝕂)
    __or__   = ⥌𝕊,x↦𝕊􋇑()|x
    __pow__  = ⥌𝕊,x↦𝕊􋇑()⌃x
    __repr__ = 𝕊↦‹⟦𝕊􋇛⟧()›
    __bool__ = 𝚲✗
ℵ´ = _hwrap(ℵ´)
ℶ  = _hwrap(ℶ )

 dbg_wrap = 𝑓↦𝚲☾´(‹⟦𝑓.__name__⟧: 𝔸=⟦𝔸⟧, 𝕂=⟦𝕂⟧ ↓›) ► 𝑓(⠤𝔸,⠶𝕂)☾

⊢ 𝔦𝔪𝔭(x):
    match x:
        case ␛s:  system stuff
            ⨡ os, sys, shutil, subprocess
            ⮌ pathlib ⨡ Path as 𝐩
            ⮌ subprocess ⨡ Popen as 𝐫
            ⮌ time ⨡ time, sleep
            
            i=0
            ➰i+=1:
                G = sys._getframe(i).f_globals
                ¿G["__file__"]≠__file__: ⇥
            G[␛𝐩⥉PEV] = 𝐩
            G[␛𝐫⥉PEV] = 𝐫
            G[h≔PEV("𝐩𝐝")] = 𝚲G["__file__"] ⥉𝐩→.parent
            G["subprocess"] = subprocess
            G["os"], G["sys"], G["shutil"] = os, sys, shutil
            G["time"], G["sleep"] = time, sleep
            G["ldir"] = 𝚲os.chdir←Gₕ

⊢ 󱠨(c, ⠤𝔸, get_ns=✗, ns=□, fname=□,
    interactive_𝕂=□, no_isolate=✗,
    no_isolate_ƒ=󰲡exec(x,globals()), ⠶𝕂):  󱠨(x, return_code=✓)
    
    ⮌ refresher ⨡ basic_cpy_interactive_session
    cpy = basic_cpy_interactive_session(
        print_output=✓, ns=ns, fname="cpy_󱠨" ¿fname≅□¡ fname,
        header_carry=__header_namespace__,
        ⠶interactive_𝕂∨{})
    ¿no_isolate: # absolutely beaned
        ¬get_ns ∧ ns≅□ ∧ fname≅□ ⨳
        c = cpy(c, ⠤𝔸, return_code=✓, ⠶𝕂)☾
        ↪ no_isolate_ƒ(c)
    r = cpy(c, ⠤𝔸, ⠶𝕂)
    ↪ cpyⁿˢ ¿get_ns¡ r

 𝔸∋* ⟶ merge all (public) module contents with globals
 𝔸∋- ⟶ don't set module itself as global (automatic w/ !)
 𝔸∋! ⟶ store the object with module name into globals instead of module
 g ⟶ store anything into globals
 store_code ⟶ m.__cpy_code__ is the source code
⊢ 󰋺(𝔣, ⠤𝔸, g=✓, store_code=✓, just_get_path=✗, just_get_code=✗):
    ¬(just_get_path ∧ just_get_code) ⨳  󰤱 return a tuple if both
    ⮌ sys ⨡ path as P, _getframe as GF
    ⮌ os ⨡ path, listdir
    ⮌ pathlib ⨡ Path as 𝐩
    f, drs = □, (␛., ⠤P) ᴍ󰲡𝐩←x→.resolve()󰅂 󰈲󰲡x.is_dir()
    ∀p∈drs:
        ¿f ≔ ⋁ ← ᐦ⋄".☾" ᴍ 󰲡z≔p/‹⟦𝔣⟧⟦x⟧›→.is_file() ∧ z󰅂: ⇥
    f ⨳ ‹Can't find "⟦𝔣⟧" in [⟦", ".join(drsᴍ󰲡‹"⟦x⟧"›)⟧]!›
    ¿just_get_path: ↪f
    with f.open() as 𝐟: code = 𝐟.read()
    ¿just_get_code: ↪ code
    nam = PEV(na ≔ f.stem)
    m = ℵ(⠶󱠨(␛+code, get_ns=✓, cap_stdout=✗, ns={"__name__": nam}, fname=ᔐ←f))
    𝑘 = (m.keys󰈳󰲡x₀≡␛_) ¿*∈𝔸¡ 𝑙(𝔸 ∖ {!})
    𝑘 += exports ≔ (𝑙(m.__exports__) ¿"__exports__"∈m.keys¡ [])
    ¿store_code: m􋕟􋕟ᶜᵖʸ􋕟ᶜᵒᵈᵉ􋕟􋕟 = code
    ¿g:
        G = GF(1).f_globals
        ∀k∈𝑘ᴍPEV: Gₖ = mₖ
        ¿-∉𝔸 ∧ !∉𝔸 ∧ na∉𝑘:
            Gₙₐₘ = m
    ¿!∈𝔸:
        nam∈m ⨳ ‹Can't find "⟦nam⟧" inside module "⟦f.stem⟧"!›
    ↪ m

ℳℱ_cache = {}
⊢ ℳℱ(load):
    ⊢ ƒ(⠤𝔸,⠶𝕂):
        ¿ℳℱ_cache∋𝓲≔id(load):
            𝑓 = ℳℱ_cache􋜆
        ¡:
            𝑓 = ℳℱ_cache􋜆 = load
        ↪ 𝑓(⠤𝔸,⠶𝕂)
    ↪ ƒ
SUBPROCA = ℳℱ(𝚲󰋺(‹subproca›).SUBPROCA)

⮌ random ⨡ shuffle, choice, uniform, randint
Ω Rand:
    __slots__ = ␛t,
    __init__ = ⥌𝕊,t↦𝕊ᵗ≔t →► □
    __getitem__ = ⥌𝕊,n↦⥌⠤𝓐,⠶𝓚↦n⭥ᴍ𝚲𝕊(⠤𝓐,⠶𝓚)
    ⊢ __call__(𝕊, x=␀, y=␀):
        ¿𝕊ᵗ≡␛:
            ¿𝗜(x) ∨ 𝗜(y):
                𝒾, n = (x,y) ¿𝗜(x)¡ (y,x)
                ¿n≅␀: ↪shuffle(𝕩≔𝑙∘𝒾) ► 𝕩
                ↪ n⭥ᴍ𝚲choice(𝒾)
            ✗⨳
        ¿␀≅x∧y≅␀: ↪uniform(⠤∓1¿𝕊ᵗ≡␛¡0⋄1)
        ƒ = uniform ¿𝕊ᵗ≡␛¡ randint
        ¿␀≇x∧y≇␀: ↪ƒ(x,y)
        ¿𝗜(𝕩≔𝕣(x⋄y)₀): ↪ƒ(⠤𝕩)
        ¡            : ↪ƒ(0,𝕩)
        ⨳✗
´,󱅏´,´ = ‹󱅏›ᴍRand

__error_printer__ = ℳℱ(𝚲󰋺("highlighter").__error_printer__)
__highlighter__   = ℳℱ(𝚲󰋺("highlighter").__highlighter__  )
__builtins__[t≔"__error_printer__"] = __error_printer__
__builtins__[t≔"__highlighter__"  ] = __highlighter__