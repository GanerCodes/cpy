exec ← "from math import *"
󰆴 factorial, e, pi, tau, sqrt, cbrt, pow
𝑜,𝑑,𝑏,𝑙,𝑡,𝑠,ᔐ,𝑖,𝑓 = object, dict, bool, list, tuple, set, str, int, float
⮌ py_naming_tools ⨡ py_escape_var as PEV
⮌ functools ⨡ reduce
⮌ itertools ⨡ chain, filterfalse, product, accumulate, zip_longest
⮌ random ⨡ shuffle, choice, uniform, randint
⮌ typing ⨡ Hashable

LITERAL_OPS_ = {
      ␛∧:󰲣x∧y,  ␛∨:󰲣x∨y,
      ␛*:󰲣x⋅y,  ␛/:󰲣x/y,   ␛<:󰲣x <y,  ␛>:󰲣x >y,
      ␛|:󰲣x|y,  ␛&:󰲣x&y,   ␛^:󰲣x ^y,  ␛%:󰲣x %y,
    ␛=␛=:󰲣x≡y,␛!␛=:󰲣x≠y, ␛<␛=:󰲣x ≤y,␛>␛=:󰲣x ≥y,
    ␛/␛/:󰲣x⹏y,␛*␛*:󰲣x⌃y, ␛<␛<:󰲣x<<y,␛>␛>:󰲣x>>y,
      ␛+:𝚲+𝔸ᵥ ¿𝔸ᵥ􊮝₀≅␀∨𝔸🃌≡1∨𝔸ᵥ􊮝₁≅␀¡ 𝔸₀+𝔸₁,
      ␛-:𝚲-𝔸ᵥ ¿𝔸ᵥ􊮝₀≅␀∨𝔸🃌≡1∨𝔸ᵥ􊮝₁≅␀¡ 𝔸₀-𝔸₁,
    "not":󰲡¬x,
    "is":󰲣x≅y, "is not":󰲣x≇y,
    "in":󰲣x∈y, "not in":󰲣x∉y }

SETATTR = 󰲧    setattr  (x,y,z)∨z ¿w≡0¡     setattr  (y,z,x)∨x
SETITEM = 󰲧x.__setitem__(y  ,z)∨z ¿w≡0¡ y.__setitem__(z  ,x)∨x
GETATTR = 󰲣    getattr  (x,y)
GETITEM = 󰲣x.__getitem__(  y)

þSTACK = []
þPSH, þPOP = 󰲡þSTACK.append(x)∨x, 󰲡þSTACK.pop(x)

␀, ⬤ = NULL≔𝑜(), 𝑜()
OP_DUPER_ = ƒ↦󰲡ƒ(x,x,⠤𝔸,⠶𝕂) # ꜠
OP_SWAPA_ = ƒ↦󰲣ƒ(y,x,⠤𝔸,⠶𝕂) # ᵜ
OP_LNULL_ = ƒ↦󰲡ƒ(␀,x,⠤𝔸,⠶𝕂) # ⟥
OP_RNULL_ = ƒ↦󰲡ƒ(x,␀,⠤𝔸,⠶𝕂) # ⟤
OP_BSTAR_ = ƒ↦󰲡ƒ(⠤x ,⠤𝔸,⠶𝕂) # ≺

✓,✗,□,ᐦ = True, False, None, ''
𝒞ℳ, 𝒮ℳ = classmethod, staticmethod
↉,½,⅓,¼,⅕,⅙,⅐,⅛,⅑,⅒ = 0,1/2,1/3,1/4,1/5,1/6,1/7,1/8,1/9,1/10
⅔,⅖,¾,⅗,⅜,⅘,⅚,⅝,⅞ = 2/3,2/5,3/4,3/5,3/8,4/5,5/6,5/8,7/8
π, ℇ = 3.14159265358979323, 2.71828182845904523
î, ∞, τ, 󷺍 = complex(0, 1), inf, 2⋅π, ½⋅π
󷱪, 󷱫, 󷱬, 󷱭, 󷱮 = ¯î, ¯ℇ, ¯τ, ¯π, ¯󷺍

⊢ 𝑏𝑔(ƒ):
    Ω ω:
        __slots__ = ()
        __call__ = 𝕊↦ƒ(⠤𝔸)
        __getitem__ = ⥌𝕊,z↦󰲣ƒ(x,y,z)
    ↪ ω()
⊢ OPWRAP_(ƒ):
    Ω ω:
        __slots__ = ()
        ⊢ __call__(𝕊, x=␀, y=␀, ⠶𝕂):
            ¿x≅␀: x,y = y,x
            ↪ ƒ(x,⠶𝕂) ¿y≅␀¡ ƒ(x,y,⠶𝕂)
        __getitem__ = ⥌𝕊,s↦𝚲𝕊(⠤𝔸, s=s, ⠶𝕂)
    ↪ ω()
⊢ ERROR_TRIANGLE_(t, ƒ=␀, 𝑔=␀, 𝑇=Exception):
    v = 𝕣((ƒ, 𝑔))
    ¿v🃌≡1:
        ƒ = v₀
        ¿t≡␛: raise ƒ
    ⊢ r(⠤𝔸, ⠶𝕂):
        try:
            ↪ ƒ(⠤𝔸, ⠶𝕂)
        except 𝑇 as ε:
            ¿v🃌≡1:
                ¿t≡␛󰔶: ↪ 𝔸₀¿𝔸¡□
                ¿t≡␛: ↪ ε
            ¿t≡␛: ↪ 𝑔
            ¿t≡␛󰔶: ↪ 𝑔(⠤𝔸, ⠶𝕂)
            ¿t≡␛: ↪ 𝑔(ε)
    ↪ r
⊢ _map_d(x,y,n=1):
    ⊢ _get_depths(x):
        ¿¬𝗜(x): ↪{0}
        ¿xᐹᔐ: ↪{1}
        ↪ {w+1 ∀z∈x ∀w∈_get_depths(z)}
    ⊢ _map_neg_d(x,y,n):  kinda weird ngl
        ¿xᐹᔐ: ↪ [y(z) ∀z∈x] ¿¬n¡ y(x) ¿n≡1¡ x
        ¿0∈d≔_get_depths(x): ↪x ¿n¡ y(x)
        x = [_map_neg_d(z,y,n) ∀z∈x]
        ↪ y(x) ¿n∈d¡ x
    ⊢ _map_pos_d(x,y,i):
        ¿¬i: ↪y(x)
        ¿xᐹᔐ: ↪[y(z) ∀z∈x]
        ↪ [_map_pos_d(z,y,i-1) ∀z∈x] ¿𝗜(x)¡ y(x)
    ¿n<0: ↪_map_neg_d(x,y,-n-1)
    ↪ _map_pos_d(x,y,2²⁴¿n≡∞¡n)
⊢ WINDOW_(𝕏, l=1, r=1, m=✓, s=□, Δ=1):  s≠␀ should mean Δ=1 
    c ≔ (𝕏 ≔ 𝑙←𝕏)🃌
    ¿s≅␀: ↪ 𝕏⭥ₗ﹕₋ᵣ﹕󰃏ᴍ󰲡𝕏ₓ₋ₗ﹕ₓ + 𝕏ₓ⛶⋅𝑏(m) + 𝕏ₓ₊₁﹕ₓ₊ᵣ₊₁
    V = s⛶⋅l +𝕏+ s⛶⋅r
    ↪ 𝕏⭥﹕﹕󰃏ᴍ󰲡Vₓ﹕ₓ₊ₗ + Vₓ₊ₗ⛶⋅𝑏(m) + Vₓ₊ₗ₊₁﹕ₓ₊ₗ₊ᵣ₊₁
⊢ RANGE_(𝕏, x=␀, y=␀, s=␀):
    x≅␀≅y →¬ ⨳‹Range missing both values!›
    ¿𝔰≔s≅␀: s=1
    
    v = y ¿x≅␀¡ x ¿y≅␀¡ ␀
    ¿(v≅␀ ∧ (x≇␀∧xᐹ𝑖) ∧ (y≇␀∧yᐹ𝑖)) ∨ (v≇␀∧vᐹ𝑖):
        ¿v≇␀: x, y = 0, v
        ¿𝕏≡␛󷸹: ↪ [⠤range(x  ,y  ,s)]
        ¿𝕏≡␛󷸺: ↪ [⠤range(x+1,y+1,s)]
        ¿𝕏≡␛󷸸: ↪ [⠤range(x+1,y  ,s)]
        ¿𝕏≡␛󷸻: ↪ [⠤range(x  ,y+1,s)]
    ¿v≇␀:
        𝗜(v) ⨳ ; v=𝑙←v
        ¿𝕏≡␛󷸸: ↪ (v₀, v₁﹕􍨄﹕ₛ, v􍨄)
        ¿𝔰: s=0
        ¿𝕏≡␛󷸹: ↪ v₀₊ₛ
        ¿𝕏≡␛󷸺: ↪ v􍨄₋ₛ
        ¿𝕏≡␛󷸻: ↪ v₀₊ₛ, v􍨄₋ₛ
    ¿𝗜∘x ∧ 𝗜∘y:
        ↪ [xₕ∀h∈y﹕﹕ₛ]
    ¿𝗜∘x ∧ yᐹ𝑖:
        ¿𝕏≡␛󷸹: ↪ x[   :y  :s]
        ¿𝕏≡␛󷸺: ↪ x[0+1:y+1:s]
        ¿𝕏≡␛󷸸: ↪ x[0+1:y  :s]
        ¿𝕏≡␛󷸻: ↪ x[   :y+1:s]
    ¿xᐹ𝑖 ∧ 𝗜∘y:
        ¿𝕏≡␛󷸹: ↪ y[slice(x  ,󷰾,s)]
        ¿𝕏≡␛󷸺: ↪ y[slice(x+1,□,s)]
        ¿𝕏≡␛󷸸: ↪ y[slice(x+1,󷰾,s)]
        ¿𝕏≡␛󷸻: ↪ y[slice(x  ,□,s)]
    ✗⨳‹Invalid arguments! ⟦ᐹx⟧ ⟦ᐹy⟧›
⊢ JOIN_(𝕏, x=␀, y=␀, s=ᐦ, LR_def=□, bound_mode=␀):
    x≅␀∧␀≅y →¬ ⨳‹Join missing both values!›
    ¿x≅␀: x,y = y,x
    ¿sᐹ𝑡:
        ¿s₀ᐹ𝑖: bound_mode, 𝕏 = s
        ¡    : 𝕏, bound_mode = s
        𝕏ᐹᔐ ∧ bound_modeᐹ𝑖 ⨳ ‹Bad modifiers!›
    ⸘sᐹ𝑖:
        s, bound_mode = ᐦ, s
    ¿bound_mode≅␀: bound_mode = 𝕏≡␛⟗∧1∨0
    ¿x≅␀: x,y = y,x
    ¿y≅␀:
        𝗜(x) ⨳ ‹Single-arg ⟦t⟧ needs an iterable›
        ↪ 𝗻⋅(𝕏∈␛⟕␛⟗)+ᐦ.join(xᴍᔐ)+(␛⟗␛⟖∋𝕏)⋅𝗻 → ᣆ􋂝ᴸ􋁉ˢ 𝑙
    
    Y = y
    ¿¬𝗙(y): y=󰻾ʸ
    
    x, R = 𝑙(x), []
    ¿x🃌≡0 ∧ (𝕏≠␛⨝ ∨ bound_mode>0):
        v = y(LR_def, LR_def)
        ¿𝕏∈␛⟕␛⟖ ∨ bound_mode≡1: R = [v]
        ¡                     : R = [v,v]
    ¡:
        ¿𝕏∈␛⟕␛⟗: R.append(y(LR_def, x₀))
        ∀i∈x🃌󷸸 : R.extend([xᵢ₋₁, y(xᵢ₋₁, xᵢ)])
        ¿  x🃌  : R.append(x􍨄)
        ¿𝕏∈␛⟖␛⟗: R.append(y(x􍨄, LR_def))
    
    ↪ ᐦ.join(Rᴍᔐ) ¿␛L∉s∧Yᐹᔐ¡ R
⊢ SPLIT_(𝕏, x=␀, y=␀, s=󷰾):
    ¿sᐹ𝑡:
        n, L = sᴙ ¿s₀≡𝑙¡ s
    ¡:  n, L = 󷰾⋄✓ ¿s≡𝑙¡ s⋄✗
    ¿x≅␀∨¬𝗜(x): x,y = y,x
    
    ¿¬L∧xᐹᔐ∧𝕏≡␛󷹎:
        ¿y≅␀: ↪ x.split(maxsplit=n)
        ¿yᐹᔐ: ↪ x.split(y,maxsplit=n)
    
    ¿y≅␀: y=󰻾
    
    YS = yᐹᔐ
    ¿¬L∧YS:
        x, y, Y, Δ = xᙡ0⋄(y🃌-1)→ᴍ⟥ᑀ󰈲→⨝, ᑀ≡ᑅy, y🃌, y🃌-1
    ¡:
        Δ = 0
    r, b = [], []
    x, i = 𝑙(x), 󷰾
    ¿n≡󷰾: V, E = x, []
    ¡   : V, E = x﹕ₙ, xₙ﹕  WRONG not ho wyou number idot
    ➰i+=1→<V🃌:
        v = Vᵢ
        ¿y(v):
            ¿b: r.append(b)
            ¿𝕏≡␛󷹌 ∨ 𝕏≡␛󷹍∧b:
                r.append(v)
            b = []
            i += Δ
        ¡:
            b.append(v)
    ¿b:
        b.extend(E)
        r.append(b)
    ⸘E:
        r.append(E)
    r☾
    ¿YS: r = rᴍ⟥ᑀᐵ₀ᐸ⨝¿⟞ᐹ𝑙¡⟞
    ↪ r
    
     󷹌/󷹍/󷹎
       ⁿ ⇒ number of times
       􋇙 ⇒ force list mode when strings
       󷹎 ⇒ no seps
       󷹍 ⇒ keep only single runs of sep
       󷹌 ⇒ keep seps
       ᔐ,ᔐ: spl by arg 2
       𝒾,ƒ: spl by ƒ
       𝒾: spl by falsy
       ᔐ: spl by whitespace
⊢ FBALZ_(t, ƒ=␀, 𝑔=␀, s=∞):
    ¿¬𝗙(ƒ): ƒ,𝑔 = 𝑔,ƒ
    ¿𝑔≅␀       : 𝑔=󰻾
    ⸘t≡␛⊚ ∧ 𝑔ᐹ𝑖: 𝑔=Ticker(𝑔)
    ⊢ r(⠤𝔸,⠶𝕂):
        n, g = s, 𝑔(ƒ(⠤𝔸,⠶𝕂)≕f)
        ¿t≡␛⊚:
            ¿g: ↪f
            ➰0<n-=1:
                ¿   𝑔(ƒ(f)≕f)   : ↪f
        ⸘t≡␛⊜:
            ➰0<n-=1:
                ¿g≡(𝑔(ƒ(f)≕f)≕g): ↪f
        ⸘t∈␛🟕␛🟖:
            rf, rg = [f], [g]
            ➰0<n-=1:
                ¿𝑔(ƒ(f)≕f)≕g∈rg:
                    ¿t≡␛🟖: ↪ rf
                    ↪ (rg 󰑅ᴵ 󰲡x≡g) 󷸻 rf 
                rf.append(f)
                rg.append(g)
        ↪□
    ↪ r
Ω RANDOM_:
    __slots__ = ␛t,
    __init__ = ⥌𝕊,t↦𝕊ᵗ≔t →► □
    __getitem__ = ⥌𝕊,n↦⥌⠤𝓐,⠶𝓚↦n⭥ᴍ𝚲𝕊(⠤𝓐,⠶𝓚)
    ⊢ __call__(𝕊, x=␀, y=␀):
        ¿𝕊ᵗ≡␛:
            ¿𝗜(x) ∨ 𝗜(y):
                𝒾, n = (x,y) ¿𝗜(x)¡ (y,x)
                ¿n≅␀: ↪shuffle(𝕩≔𝑙∘𝒾) ► 𝕩
                ↪ n⭥ᴍ𝚲choice(𝒾)
            ✗⨳
        ¿␀≅x∧y≅␀: ↪uniform(⠤∓1¿𝕊ᵗ≡␛¡0⋄1)
        ƒ = uniform ¿𝕊ᵗ≡␛¡ randint
        ¿␀≇x∧y≇␀: ↪ƒ(x,y)
        ¿𝗜(𝕩≔𝕣(x⋄y)₀): ↪ƒ(⠤𝕩)
        ¡            : ↪ƒ(0,𝕩)
        ⨳✗
Ω Ticker:
    __slots__ = ␛i,
    __init__ = ⥌𝕊,i↦𝕊ⁱ≔i→►□
    __call__ = 𝕊↦𝕊ⁱ-=1→►𝕊
    __bool__ = 𝕊↦¬𝕊ⁱ
    __repr__ = 𝕊↦‹Ticker[i=⟦𝕊ⁱ⟧]›
Ω 𝑐𝑑(𝑑):
    ⊢ __init__(𝕊, ƒ, ⠤𝔸, 𝑔=□, ⠶𝕂):
        𝕊.ƒ, 𝕊.𝑔 = ƒ, 𝑔
        super().__init__(⠤𝔸,⠶𝕂)
    __call__ = 𝕊↦𝕊.ƒ(⠤𝔸,⠶𝕂)
    __repr__ = 𝕊↦super().__getitem__("__repr__")(𝕊) ¿"__repr__"∈𝕊¡ super().__repr__()
    __getitem__ = ⥌𝕊,x↦super().__getitem__(x) ¿𝗛(x)∧super().__contains__(x)¡ 𝕊.𝑔(x)

𝕣 = 󰲡[y∀y∈x¿y≇␀]
🃌 = len
𝗙, 𝗜, 𝗛 = callable, 󰲡hasattr(x,"__iter__"), ERROR_TRIANGLE_(␛, hash, ✗)

ᐹ´ = ⥌x=␀,y=␀↦type(y¿x≅␀¡x) ¿␀≅x∨y≅␀¡ isinstance(x, y ¿isinstance(y,type)¡ type(y))
ᐴ´ = ⥌y=␀,x=␀↦ᐹ´(x,y)
󰻾´ = 𝑐𝑑(      󰲡x, __repr__=𝚲␛󰻾,
        𝑔=󰲡𝑐𝑑(𝚲x, __repr__=𝚲‹󰻾∘⟦x⟧›))

∘´ = OPWRAP_(⥌ƒ=␀,y=␀,s=1↦ ƒ   (⠤[y]⋅s))
○´ = OPWRAP_(⥌ƒ=␀,𝔤=␀,s=1↦𝚲ƒ∘ˢ𝔤(⠤𝔸,⠶𝕂))
☾´ = ⥌⠤𝔸,flush=✓↦print(⠤𝔸,flush=flush,⠶𝕂)∨𝔸∧𝔸₀

⊢ 󰈲´(x=␀, y=␀, s=␀, neg=✗):
    ¿s≅*: s=y
    ¿neg: y=¬○(󰻾¿y≅␀¡y)
    ¿s≅␀: ↪ 𝑙←filter(□¿y≅␀¡y, x)
    ¿¬𝗙(s): s=󰻾ˢ
    ¿y≅␀: ↪ 𝑙←filter(□, xᴍs)
    ↪ [s(z)¿y(z)¡z ∀z∈x]
󰈳´ = OPWRAP_(𝚲󰈲´(⠤𝔸,⠶𝕂,neg=✓))
󰈲´ = OPWRAP_(󰈲´)

⊢ ´(ƒ):
    ⊢ 𝒻(⠤𝜶,⠶𝜿):
        ⊢ 𝑓(⠤𝔸,⠶𝕂):
            𝓐, 𝔸 = 𝑙(𝜶), 𝑙(𝔸)
            𝓚 = 𝑙(𝜿.items())
            a, k = [], {}
            ➰𝓐:
                x = 𝓐.pop(0)
                a.append(𝔸.pop(0) ¿x≅⬤¡ x)
            ➰𝓚:
                x, y = 𝓚.pop(0)
                kₓ = 𝔸.pop(0) ¿y≅⬤¡ y
            ↪ ƒ(⠤a+𝔸,⠶k|𝕂)
        ↪ 𝑓
    ↪ 𝒻
´ = 𝑐𝑑(t≔ƒ↦𝚲ƒ(⠤𝔸ᴍ𝑙Σ[], ⠶𝕂), 𝑔=t)

Ω ⴳ(𝑖):
    __new__ = ℂ↦𝑖.__new__(ℂ,1)
    __call__, __repr__ = 𝚲ⴳ, 𝕊↦␛ⴳ
Ω ⴴ(𝑖):
    __new__ = ℂ↦𝑖.__new__(ℂ,0)
    __call__, __repr__ = 𝚲ⴴ, 𝕊↦␛ⴴ
ⴳ, ⴴ = ⴳ(), ⴴ()

ſ´ = 𝑏𝑔←⥌x,y,z=␀↦reduce    (y,x,⠤(z,)⋅←z≇␀)
Ϝ´ = 𝑏𝑔←⥌x,y,z=␀↦accumulate(x,y,⠶{}¿z≡␀¡{"initial":z})⥉𝑙
ᙎ´ = 𝑏𝑔←⥌x,y,z=␀↦WINDOW_(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡    1⋄1    , ✗, □¿z≅␀¡z, 1        )
ᙡ´ = 𝑏𝑔←⥌x,y,z=␀↦WINDOW_(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡    1⋄1    , ✓, □¿z≅␀¡z, 1        )
ᗢ´ = 𝑏𝑔←⥌x,y,z=␀↦WINDOW_(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡z≅␀∧1⋄1∨0⋄z, ✗, ␀      , z≅␀∧1∨z+1)
ᙧ´ = 𝑏𝑔←⥌x,y,z=␀↦WINDOW_(h≔𝕣←x⋄y→₀, ⠤yᐹ𝑖∧y⋄y∨y¿h🃌≡2¡z≅␀∧1⋄1∨0⋄z, ✓, ␀      , z≅␀∧1∨z+1)
󰸵´ = 𝑏𝑔←⥌x,y,z=␀↦(  (l⭥ᴍ(ⴴ¿z≅␀¡z¿𝗙(z)¡𝚲z))+x)¿(l≔y-x🃌)>0¡x
󰸷´ = 𝑏𝑔←⥌x,y,z=␀↦(x+(l⭥ᴍ(ⴴ¿z≅␀¡z¿𝗙(z)¡𝚲z))  )¿(l≔y-x🃌)>0¡x

Ω ᴍ´:
    ƒ = 𝒮ℳ(_map_d)
    ⊢ __getitem__(𝕊, i):
        S, ƒ = 𝑠←i ¿iᐹ𝑡¡ (i,), □
        ¿S∋s≔␛D: ƒ = f↦󰲣type(x)←f(x.items(),y)
        ⸘S∋s≔␛K: ƒ = f↦󰲣type(x)←f(x.items(),y)ζx.values()
        ⸘S∋s≔␛V: ƒ = f↦󰲣type(x)←x.keys()ζf(x.items(),y)
        ¿ƒ:
            S.discard(s)
            ↪ ƒ(S ∧ 𝕊[S.pop()] ∨ 𝕊)
        ↪ ⥌x,y,i=i↦𝕊.ƒ(x,y,i)
    __call__ = ⥌𝕊,x,y↦𝕊.ƒ(x,y,1)
Ω ꟿ´(ᴍ´):
    ƒ = 𝒮ℳ(⥌x,y,i↦_map_d(x,󰲡y(⠤(x¿𝗜(x)¡(x,))),i))

Ω √´:
    __getitem__ = ⥌𝕊,x↦⥌y↦yˣ􍩯
    __call__ = ⥌𝕊,x↦x􊽲
√´,ᴍ´,ꟿ´ = √´(),ᴍ´(),ꟿ´()

⊢ ⨳´(α=␀, β=␀):
    ¿α≅␀: α,β = β,α
    assert α, "Assertion failed!"¿β≅␀¡β
    ↪ α

⊢ _wherest(𝕏, ƒ=𝑏, I=ⴴ):
    ¿ƒ≅␀: ƒ=𝑏
    ∀i,x∈↨𝕏:
        ¿ƒ(x): ↪i ¿I¡ x

∖´ = 󰲣x-𝑠(y) ¿xᐹ𝑠¡ [z∀z∈x¿z∉y]
ᣆ´ = 𝑐𝑑(ƒ ≔ 󰲣y(x) ¿(𝔸₀ ¿𝔸🃌¡ x)¡ x, 𝑔=a↦󰲣ƒ(x,y,a))
󰑅´ = 𝑐𝑑(_wherest, I=𝚲_wherest(⠤𝔸,I=✓))
󰑁´ = OPWRAP_(⥌𝕏,ƒ=𝑏,s=□↦s ¿□≅i≔𝕏󰑅ᴵƒ¡ 𝕏﹕ᵢ)
󰑃´ = OPWRAP_(⥌𝕏,ƒ=𝑏,s=□↦s ¿□≅i≔𝕏󰑅ᴵƒ¡ 𝕏ᵢ﹕)
ᴙ´ = 𝑐𝑑(󰲡(x¿xᐹᔐ¡𝑙(x))﹕﹕₋₁, L=󰲡𝑙(x)﹕﹕₋₁)  reverse; ᴙᴸ to force 𝑙
⨉´ = 𝑐𝑑((n↦𝚲product(⠤𝑙(v₀ ¿𝕣(𝔸)≕v🃌≡1¡ v)¿n≡1¡𝑙(𝕣(𝔸))⋅n)ᴍ𝑙)≕𝑓→(1), 𝑔=𝑓)
⊞´ = OPWRAP_(⥌⠤𝔸,s=1↦(ƒ≔⥌⠤𝔸,n=1,r=[]↦𝔸⋅nᑀ₀ᴍ󰲡ƒ(⠤⟞₁﹕,r=r+[x]) ¿⟞🃌>1¡ r+[x])(⠤𝔸, n=s))
⊻´ = 󰲣𝑏(x)^𝑏(y)  ∧←x∨y  xor
⊼´ = 󰲣𝑏(x)∧𝑏(y)→¬∧←x∨y  nand
⨁´ = 󰲣𝑏(x)≡𝑏(y)         xand
⍉´ = 󰲡ζ(⠤x)
⍭´ = 󰲡x.split(␛ )ᴍ⍭´ ¿␛ ∈x¡ x.split(␛ )
ⴵ´ = 󰲡1¿x>0¡x∧¯1∨0
⛶´ = 𝑐𝑑(󰲡[x], S=󰲡{x}, T=󰲡(x,))
▢´ = 𝚲round(⠤𝕣(𝔸))
…´ = 󰲣𝑙←range(x,y)
!´ = 󰲡󷸺xΠ1
∓´,±´ = 𝚲-´⋄+´ᐵ(⠤𝕣(𝔸)), 𝚲+´⋄-´ᐵ(⠤𝕣(𝔸))
⊊´,⊋´ = 󰲣(α≔𝑠←x).issubset(β≔𝑠←y)∧α≠β, 󰲣(α≔𝑠←y).issubset(β≔𝑠←x)∧α≠β
⊂´,⊃´ = 󰲣𝑠(x).issubset(𝑠←y), 󰲣𝑠(y).issubset(𝑠←x)
⊄´,⊅´ = 󰲣¬(x⊂y), 󰲣¬(x⊃y)
∋´,∌´ = 󰲣y∈x, 󰲣y∉x
∣´,∤´ = 󰲣gcd(x,y)≡x, 󰲣gcd(x,y)≠x
∪´,∩´ = 󰲣𝑠(x) | 𝑠(y), 󰲣𝑠(x) & 𝑠(y)
⫰, ⫯ = 󰲡+abs(x), 󰲡¯abs(x)
◄, ► = 󰲡x, 󰲣y
↨, ⭥ = 󰲡𝑙←enumerate←x, 󰲡𝑙←range(x ¿xᐹ𝑖¡ x🃌)
⬓, ⬒ = floor, ceil
 WHY:
⤈, ⤉ = (min,max)ᴍƒ↦𝑐𝑑((𝑓≔󰲡𝚲(ƒ(𝔸₀,key=󰻾¿𝔸₁≅␀¡𝔸₁)¿𝔸₀🃌¡x())¿𝔸₁﹕∧(𝗙(𝔸₁)∨𝗜(𝔸₀))¡(ƒ(⠤h)¿(𝕣(𝔸)≕h🃌)¡x()))(𝚲ValueError),𝑔=󰲡𝑓(󰻾ˣ))

⊢ ⬄´(x=␀,y=␀):
    ¿x≅␀: x,y=y,x
    ¿xᐹᔐ ∧← y≅␀ ∨ yᐹᔐ:
        ↪x.strip(⠤𝕣((y,)))
    ✗⨳  󰤱

⊢ ⋀´(𝑋, v=✓):
    ∀v∈𝑋:
        ¿¬v:↪v
    ↪v
⊢ ⋁´(𝑋, v=✗):
    ∀v∈𝑋:
        ¿ v:↪v
    ↪v

ζ = 𝚲zip(⠤𝕣(𝔸))ᴍ𝑙
Π, Σ = 󰲡ſ´(x,⋅,⠤𝕣(𝔸)), 󰲡ſ´(x,+,⠤𝕣(𝔸))
󰒼, 󰒽 = 󰲣sorted(x,key=□¿y≅␀¡y), 󰲣sorted(x,key=□¿y≅␀¡y,reverse=✓)
 = 𝑐𝑑(𝚲⥌I,ƒ=𝑏↦r≔{}→◄←Iᴍ󰲡r.setdefault(h≔ƒ(x),[]).append(x)󰅂󰅂(⠤𝕣(𝔸),⠶𝕂),
       S=𝚲´(⠤𝔸,⠶𝕂).items 󰒼 ᴍ󰲡x₁,
       B=𝚲h≔{✓:[],✗:[],⠶´(⠤𝔸,⠶𝕂)}→►←[h₀,h₁])

Ω 𝑙𝑙(𝑙): □
⋄ = 󰲣(x¿xᐹ𝑙𝑙¡x≔𝑙𝑙((x,))).append(y)►x

⊢ ´(ƒ,⠤𝔸,⠶𝕂):
    ¿𝗙(ƒ): ↪ ƒ(⠤𝔸,⠶𝕂)
    ¿𝗜(ƒ):
        ∀x∈ƒ: pass
        ↪ ƒ
    ✗⨳‹⟦ƒ⟧ is not iterable or callable.›
⊢ ᚤ´(x=␀, y=␀):
    ¿x≅␀: x,y = y,x
    ¿y≅␀: y = 󰻾
    s, r = [], []
    ∀z∈x:
        ¿(v≔y(z))∈s: ↺
        s.append(v)
        r.append(z)
    ↪ r

@OPWRAP_
⊢ 󰌷´(x=␀, y=␀, s=1):
    ¿x≅␀: x,y = y,x
    ¿y≇␀: x = [x, y]
    v = 𝑙(chain(⠤x))
    ¿s>1: ↪ v󰌷ˢ⁻¹
    ↪ v

⨝´,⟕´,⟖´,⟗´ = ‹⨝⟕⟖⟗›ᴍ󰲡OPWRAP_( JOIN_(x))
󷸹´,󷸺´,󷸸´,󷸻´ = ‹󷸹󷸺󷸸󷸻›ᴍ󰲡OPWRAP_(RANGE_(x))
⊚´,⊜´,🟕´,🟖´ = ‹⊚⊜🟕🟖›ᴍ󰲡OPWRAP_(FBALZ_(x))
󷹌´,󷹍´,󷹎´    =  ‹󷹌󷹍󷹎›ᴍ󰲡OPWRAP_(SPLIT_(x))
´,󰔶´,´    =  ‹󰔶›ᴍ󰲡𝑐𝑑(ƒ≔ERROR_TRIANGLE_(x), 𝑔=󰲡ƒ(𝑇=x))
´,󱅏´,´    =  ‹󱅏›ᴍRANDOM_

⊢ TACITM(λ, m):
    ↪ 󰲡xᴍλ󰅂 ¿m≡1¡ λ
⊢ TACITB(λ, m1, m2, d=□):
    ⊢ ƒ(l=␀, r=␀):
        ¿l≇␀∧r≇␀: □
        ⸘l≅␀∧r≅␀: ↪ ƒ
        ⸘d≡␛r   : ↪ ƒ(⬤,l¿r≅␀¡r)
        ¡       : ↪ ƒ(l¿r≅␀¡r,⬤)
        
        ¿m1≡1≡m2: ↪ lζr ꟿ  λ
        ⸘m1≡1   : ↪ l   ᴍ 󰲡λ(x,r)
        ⸘   1≡m2: ↪   r ᴍ 󰲡λ(l,x)
        ¡       : ↪        λ(l,r)
    ↪ ƒ
TAC_ = ⥌x,d=□↦TACITM(x₀,x₂¿x₁≡󷰾¡x₁) ¿x₁≡󷰾∨x₂≡󷰾¡ TACITB(⠤x,d=d)
␀TACIT´   = 𝑐𝑑(𝚲✗⨳, 𝑔= TAC_)
␀TACITL´  = 𝑐𝑑(𝚲✗⨳, 𝑔=󰲡TAC_(x,␛l))
␀TACITR´  = 𝑐𝑑(𝚲✗⨳, 𝑔=󰲡TAC_(x,␛r))
␀TACITLR´ = 𝑐𝑑(𝚲✗⨳, 𝑔=󰲡TACITB(⠤x))

⊢ ⓦ(⠤𝔸, 𝐀=□):
    𝐀∨=[]
    ⠤𝔸, ƒ = 𝔸
    ¿¬𝔸: ↪ƒ(⠤𝐀)
    𝕒, ⠤𝔸 = 𝔸
    with 𝕒 as 𝐚:
        𝐀.append(𝐚)
        ↪ ⓦ(⠤𝔸, ƒ, 𝐀=𝐀)

 all this be weird
Ω ℵ´(𝑑):
    𝐶𝑛 = ␛ℵ
    __json__ = ⥌𝕊,cb,⠤𝓐,⠶𝓚↦ 𝑑(𝕊) ꟿⱽ 󰲣cb(y,⠤𝓐,⠶𝓚)
    __init__ = 𝕊↦super().__init__(⠤𝔸,⠶𝕂)
    __setattr__ = 𝑑.__setitem__
    __getitem__ = ⥌𝕊,x↦𝑑.__getitem__(𝕊,x) ¿x∈𝕊¡ 𝕊.getdef()
    __getattr__ = __getitem__
    __iter__ = 𝕊↦iter(𝕊.items())
    __repr__ = 𝕊↦‹⟦𝕊.__class__.𝐶𝑛⟧⟦‹[⟦h₀⟧]›¿0∈(h≔𝕊.__dict__)¡ᐦ⟧(⟦␛,𝘀→.join←𝕊.itemsꟿ󰲣‹⟦x⟧=⟦y⟧›⟧)›
    __call__ = 𝕊↦𝑑.update(𝕊,⠤𝔸,⠶𝕂)►𝕊
    __bool__ = 𝕊↦𝕊🃌>0
    __or__   = ⥌𝕊,x↦𝕊.copy()(x)
    ⊢ __getstate__(𝕊):
        ¿𝕊.hasdef(): ↪𝑑(𝕊), 𝕊.getdef()
        ¡          : ↪𝑑(𝕊),
    ⊢ __setstate__(𝕊, s):
        𝕊.__init__(s₀)
        ¿s🃌 > 1: 𝕊.setdef(s₁)
    ⊢ __pow__(𝕊, x):
        ¿x≡-: ↪𝑙∘𝕊.keys   
        ¿x≡+: ↪𝑙∘𝕊.values 
        ¿x≡*: ↪𝑙∘𝕊.items  
        ✗⨳
    hasdef = ⥌𝕊↦0∈𝕊.__dict__
    getdef = ⥌𝕊  ↦𝕊.__dict__₀
    setdef = ⥌𝕊,x↦𝕊.__dict__₀≔x →► 𝕊
    ⊢ copy(𝕊):
        r = type(𝕊)(super().copy())
        ¿𝕊.hasdef(): r.setdef(𝕊.getdef())
        ↪ r
Ω ℶ(ℵ´):
    𝐶𝑛 = ␛ℶ
    __iter__ = 𝕊↦iter(𝕊.values())
Ω _hwrap(𝑑):
    ⊢ __init__(𝕊, 𝑐):
        𝕊􋇑, 𝕊􋇛 = 𝑐, 𝑐􋆷􋇛
    __getitem__ = ⥌𝕊,x↦𝕊􋇑().setdef(x)
    __setitem__ = ⥌𝕊,x,y↦(⒯≔𝕊􋇑()).__setitem__(x,y) →►← ⒯
    __call__ = 𝕊↦𝕊􋇑(⠤𝔸,⠶𝕂)
    __or__   = ⥌𝕊,x↦𝕊􋇑()|x
    __pow__  = ⥌𝕊,x↦𝕊􋇑()⌃x
    __repr__ = 𝕊↦‹⟦𝕊􋇛⟧()›
    __bool__ = 𝚲✗
ℵ´ = _hwrap(ℵ´)
ℶ  = _hwrap(ℶ )

 dbg_wrap = 𝑓↦𝚲☾´(‹⟦𝑓.__name__⟧: 𝔸=⟦𝔸⟧, 𝕂=⟦𝕂⟧ ↓›) ► 𝑓(⠤𝔸,⠶𝕂)☾

⊢ 𝔦𝔪𝔭(x):
    match x:
        case ␛s:  system stuff
            ⨡ os, sys, shutil, subprocess
            ⮌ pathlib ⨡ Path as 𝐩
            ⮌ subprocess ⨡ Popen as 𝐫
            ⮌ time ⨡ time, sleep
            
            i=0
            ➰i+=1:
                G = sys._getframe(i).f_globals
                ¿G["__file__"]≠__file__: ⇥
            G[␛𝐩⥉PEV] = 𝐩
            G[␛𝐫⥉PEV] = 𝐫
            G[h≔PEV("𝐩𝐝")] = 𝚲G["__file__"] ⥉𝐩→.parent
            G["subprocess"] = subprocess
            G["os"], G["sys"], G["shutil"] = os, sys, shutil
            G["time"], G["sleep"] = time, sleep
            G["ldir"] = 𝚲os.chdir←Gₕ

⊢ 󱠨(c, ⠤𝔸, get_ns=✗, ns=□, fname=□,
    interactive_𝕂=□, no_isolate=✗,
    no_isolate_ƒ=󰲡exec(x,globals()), ⠶𝕂):  󱠨(x, return_code=✓)
    
    ⮌ refresher ⨡ basic_cpy_interactive_session
    cpy = basic_cpy_interactive_session(
        print_output=✓, ns=ns, fname="cpy_󱠨" ¿fname≅□¡ fname,
        header_carry=__header_namespace__,
        ⠶interactive_𝕂∨{})
    ¿no_isolate: # absolutely beaned
        ¬get_ns ∧ ns≅□ ∧ fname≅□ ⨳
        c = cpy(c, ⠤𝔸, return_code=✓, ⠶𝕂)☾
        ↪ no_isolate_ƒ(c)
    r = cpy(c, ⠤𝔸, ⠶𝕂)
    ↪ cpyⁿˢ ¿get_ns¡ r

 𝔸∋* ⟶ merge all (public) module contents with globals
 𝔸∋- ⟶ don't set module itself as global (automatic w/ !)
 𝔸∋! ⟶ store the object with module name into globals instead of module
 g ⟶ store anything into globals
 store_code ⟶ m.__cpy_code__ is the source code
⊢ 󰋺(𝔣, ⠤𝔸, g=✓, store_code=✓, just_get_path=✗, just_get_code=✗):
    ¬(just_get_path ∧ just_get_code) ⨳  󰤱 return a tuple if both
    ⮌ sys ⨡ path as P, _getframe as GF
    ⮌ os ⨡ path, listdir
    ⮌ pathlib ⨡ Path as 𝐩
    f, drs = □, (␛., ⠤P) ᴍ󰲡𝐩←x→.resolve()󰅂 󰈲󰲡x.is_dir()
    ∀p∈drs:
        ¿f ≔ ⋁ ← ᐦ⋄".☾" ᴍ 󰲡z≔p/‹⟦𝔣⟧⟦x⟧›→.is_file() ∧ z󰅂: ⇥
    f ⨳ ‹Can't find "⟦𝔣⟧" in [⟦", ".join(drsᴍ󰲡‹"⟦x⟧"›)⟧]!›
    ¿just_get_path: ↪f
    with f.open() as 𝐟: code = 𝐟.read()
    ¿just_get_code: ↪ code
    nam = PEV(na ≔ f.stem)
    m = ℵ(⠶󱠨(␛+code, get_ns=✓, cap_stdout=✗, ns={"__name__": nam}, fname=ᔐ←f))
    𝑘 = (m.keys󰈳󰲡x₀≡␛_) ¿*∈𝔸¡ 𝑙(𝔸 ∖ {!})
    𝑘 += exports ≔ (𝑙(m.__exports__) ¿"__exports__"∈m.keys¡ [])
    ¿store_code: m􋕟􋕟ᶜᵖʸ􋕟ᶜᵒᵈᵉ􋕟􋕟 = code
    ¿g:
        G = GF(1).f_globals
        ∀k∈𝑘ᴍPEV: Gₖ = mₖ
        ¿-∉𝔸 ∧ !∉𝔸 ∧ na∉𝑘:
            Gₙₐₘ = m
    ¿!∈𝔸:
        nam∈m ⨳ ‹Can't find "⟦nam⟧" inside module "⟦f.stem⟧"!›
    ↪ m

ℳℱ_cache = {}
⊢ ℳℱ(load):
    ⊢ ƒ(⠤𝔸,⠶𝕂):
        ¿ℳℱ_cache∋𝓲≔id(load):
            𝑓 = ℳℱ_cache􋜆
        ¡:
            𝑓 = ℳℱ_cache􋜆 = load
        ↪ 𝑓(⠤𝔸,⠶𝕂)
    ↪ ƒ
SUBPROCA = ℳℱ(𝚲󰋺(‹subproca›).SUBPROCA)

__error_printer__ = ℳℱ(𝚲󰋺("highlighter").__error_printer__)
__highlighter__   = ℳℱ(𝚲󰋺("highlighter").__highlighter__  )
__builtins__[t≔"__error_printer__"] = __error_printer__
__builtins__[t≔"__highlighter__"  ] = __highlighter__