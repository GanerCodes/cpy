ó·¹‡ This file is ordered from old to new

"x â«°" = "â«° x" =  abs(x)
"x â«¯" = "â«¯ x" = Â¯abs(x)

fold now has init modifier
    [3]Å¿Â¹+
    â¯ˆ 4

á´: now handles strings well
á´â¿: n layered map
    [1â‹„2,3â‹„4] á´Â² âˆš
    â¯ˆ [[1.0, 1.4142135623730951], [1.7320508075688772, 2.0]]
á´â»â¿: layers above any atom
    confusing so like:
        ["some", ["cool", [[["strings"]]]]] á´â»Â² á´™
        â¯ˆ ['emos', ['looc', [[['sgnirts']]]]]
        ["some", ["cool", [[["h"]]]]] á´â»Â¹ á”.upper
        â¯ˆ [['S', 'O', 'M', 'E'], [['C', 'O', 'O', 'L'], [[[['H']]]]]]
        î¬¦ i think á´â»Â¹ is the same as á´ó°‚ƒ...?
á´ó°‚ƒ: also a thing
êŸ¿â¿: starmap works the same way
  
Where 'â¨' â«¢ operator
  â¨ó°€‚á´¬á´¾ó°€™    âŸ¶ â¨["ó°€‚á´¬á´¾ó°€™"]
  â¨áµƒ       âŸ¶ â¨[a]
  â¨Â¹âºÂ¹     âŸ¶ â¨[1+1]
  â¨Â¹âºÂ¹ğ‘á´¶ğ‘Ë£ âŸ¶ â¨[1+1,"J",x]

Keybinded â¥‰, ğ‘
Changed binds for âŸ¥âŸ¤

"egg"â¬„"g"
â¯ˆ "e"
needs more work to be more general

made âŸ¥ and âŸ¤ work... maybe? i think?

tracebacks show the python code now, terrible monkey things had to be done to do it

added â‰º, basically
    1â‹„2â‰º+
    â¯ˆ 3

* Added hex, binary, and octal parsing
* Random fixes, one tricky peggle bug
* Added some more test cases
We still have the bugs with op swapping and stuff not chaning pres orders

* Added some normalization to some paths
* Trim the caller program from argv

added î®¦
    it just calls a function
    "f î®¦" is "f()"

fixed hex lol

Added basic cli mode, tldr "â˜¾" with no args opens it.
refresher is "â˜¾ --refresher"

added install script [linux only rn]

fixed bug with tracebacks
(Need to fix cli mode not showing errors)

á´ and êŸ¿ support á´° á´· â±½ for mapping dicts, dict keys, and dict values

added ğ‘¡ for tuples b/c it was missing for some reason

print flush by default (idk if this changes anything but it don't hurt)

added bindings (and fixed a bug) for special string chars i.e. ğ—»

added â­, basically (use special char highlighting PLS):
    â€¹aâ€‰bâ€ºâ­ = ['a', 'b']
    â€¹kâ€‰jâŸaâ€‰bâ€ºâ­ = [['k','j'], ['a','b']]

added ğ”¦ğ”ªğ”­(â›s), imports some misc sys related things for ease of use

Working on massive overhaul for compose/font stuff!

AAAAAAAAAAAAAa
ehehehhehe

â´³, â´´ now have a self-returning call method

we now have
    â¨³ ó°»¾(22) â‰¡ 22
    â¨³ ó°»¾Â¹â´("hiii") â‰¡ 14

Ïœ: accumulate
â„µáµ’áµ–áµ—â±áµ’â¿áµƒË¡ô‹•Ÿáµˆáµ‰á¶ áµƒáµ˜Ë¡áµ—: attr dict (iter does .items)
â„¶áµ’áµ–áµ—â±áµ’â¿áµƒË¡ô‹•Ÿáµˆáµ‰á¶ áµƒáµ˜Ë¡áµ—: attr dict (iter does .values)
ó°‘…, ó°‘…á´µ: first, first index of
ó°‘, ó°‘ƒ : before, after
Æ’ ï (a1,a2,â¬¤,j=22,h=â¬¤): partial function
ï€…Æ’: automatically star a function's args
(also ï€…ôŠ½º, which is cool for stuff like â‰¡)

á™á™¡á—¢á™§: windowz
á£†: apply func if...
$áµ’echoâ€‰epic subprocess callsó·¹¹

oh also everything has sub/sup/subsub/subsup/supsub/supsup scripts
oh also font remaking thingy finished check out CONFIGURE.â˜¾ in FontCompose

ok superscripts should now act like exponents when the parsed thing isn't an identifier
â¨³ 2Â² â‰¡ 4 î¬¦ ğŸ˜Š

Added gambling ğŸ˜ŠğŸ˜ŠğŸ˜Š
     î‰°/ó±…/ï´ á´º : list of N of the random thing
      î‰°/ó±…   = uniform(Â¯1, 1)/uniform(0, 1)
      î‰°/ó±… n = uniform/randint(0, n)
      î‰°/ó±… ğ’¾ = uniform/randint(ğ‘–â‚€, ğ‘–â‚)
    x î‰°/ó±… y = uniform/randint(nâ‚€, nâ‚)
    ğ’¾  ï´    = shuffle
    ğ’¾  ï´  n = n choices

New errorz
    (ğ¸ ï±  )         raise ğ¸
    (Æ’ ï± ğ‘¥)(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ‘¥
    (Æ’ ó°”¶  )(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ”¸â‚€ or â–¡
    (Æ’ ó°”¶ ğ”¤)(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ”¤(â ¤ğ”¸, â ¶ğ•‚)
    (Æ’ î©¬  )(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªÎµ
    (Æ’ î©¬ ğ”¤)(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ”¤(Îµ)

aâˆ£b: âœ“/âœ— if a divides b
aâˆ¤b: take a guess

â„‡ is now euler's constant

exponents are now fun 5ôŠ½² = âˆš5
    [ó·¹‡ uses hard-coded list of single char identifiers]

fixed nested â‰” and <op>= calls

Filterz
    (ó·¹‡ ó°ˆ³ is like ó°ˆ² except the checking function is inverted)
    "x ó°ˆ²  Æ’" = [yâˆ€yâˆˆxÂ¿Æ’(y)]
    "x ó°ˆ²ô‹‡” Æ’" = [ğ‘“(y)Â¿Æ’(y)Â¡y âˆ€yâˆˆx]
    "x ó°ˆ²î  Æ’" = x ó°ˆ²ôŠ½º Æ’
    "x ó°ˆ² " = "ó°ˆ²  x" = x ó°ˆ² ó°»¾
    "x ó°ˆ²ô‹‡”" = "ó°ˆ²ô‹‡” x" = (xá´ğ‘“) ó°ˆ²

Better rangessss
    ğ‘, ğ‘, n â«¢ int
    ğ’œ, â„¬ â«¢ iterable
    n=0 by default
        "ğ’œ ó·¸¹â¿  " = ğ’œâ‚€â‚Šâ‚™
        "ğ’œ ó·¸ºâ¿  " = ğ’œô¨„â‚‹â‚™
        "ğ’œ ó·¸»â¿  " = ğ’œâ‚€â‚Šâ‚™, ğ’œô¨„â‚‹â‚™
    n=1 by default
        "ğ’œ ó·¸»â¿ â„¬" = [ğ’œâ‚“ âˆ€ xâˆˆâ„¬ï¹•ï¹•â‚™]
        "ğ’œ ó·¸¸â¿  " = (ğ’œâ‚€, ğ’œâ‚ï¹•ô¨„ï¹•â‚™, ğ’œô¨„)
        ğ‘=1 default, ğ‘=ó·°¾ default
            "ğ’œ ó·¸¹â¿ ğ‘" = ğ’œ   ï¹•ôŠ´  ï¹•â‚™
            "ğ’œ ó·¸ºâ¿ ğ‘" = ğ’œ  â‚ï¹•ôŠ´â‚Šâ‚ï¹•â‚™
            "ğ’œ ó·¸¸â¿ ğ‘" = ğ’œ  â‚ï¹•ôŠ´  ï¹•â‚™
            "ğ’œ ó·¸»â¿ ğ‘" = ğ’œ   ï¹•ôŠ´â‚Šâ‚ï¹•â‚™
            "ğ‘ ó·¸¹â¿ ğ’œ" = ğ’œôŠ´  ï¹•  ô¨„ï¹•â‚™
            "ğ‘ ó·¸ºâ¿ ğ’œ" = ğ’œôŠ´â‚Šâ‚ï¹•   ï¹•â‚™
            "ğ‘ ó·¸¸â¿ ğ’œ" = ğ’œôŠ´â‚Šâ‚ï¹•  ô¨„ï¹•â‚™
            "ğ‘ ó·¸»â¿ ğ’œ" = ğ’œôŠ´  ï¹•   ï¹•â‚™
        ğ‘=0 default
            "ğ‘ ó·¸¹â¿ ğ‘" = [â ¤range(ğ‘  ,ğ‘  ,n)]
            "ğ‘ ó·¸ºâ¿ ğ‘" = [â ¤range(ğ‘+1,ğ‘+1,n)]
            "ğ‘ ó·¸¸â¿ ğ‘" = [â ¤range(ğ‘+1,ğ‘  ,n)]
            "ğ‘ ó·¸»â¿ ğ‘" = [â ¤range(ğ‘  ,ğ‘+1,n)]

i have gone off the deep end we now have
    ó·±…ó·°¾ = Â¯81
    ó·°½ó·±ó·±’ó·±“ó·±ó·±’ó·±ó·±“ó·±“ó·±” = Â¯0xDEADBEEF

attempted to add some implicit multiplication. Most stuff with a a literal number works well, var_spec's work decently (but might be weird in the future), and we don't support strings/regular variables.
    Â½ó·°½ó·±ó·±’ó·±“ó·±ó·±’ó·±ó·±“ó·±“ó·±”ó·ºÂ²ó·±€Ã®Â³ = -13827051355.523182j
    
    (ó·¹‡ implicit mul uses the "â€CAT" order of operations)

added joinz
    "â¨ ğ’œ" = "â¨ ğ’œ" =   á¦.join(ğ’œá´á”)
    "âŸ• ğ’œ" = "âŸ• ğ’œ" = ğ—»+á¦.join(ğ’œá´á”)
    "âŸ– ğ’œ" = "âŸ– ğ’œ" =   á¦.join(ğ’œá´á”)+ğ—»
    "âŸ— ğ’œ" = "âŸ— ğ’œ" = ğ—»+á¦.join(ğ’œá´á”)+ğ—»
    
    (ğ’œ â¨â¿ Æ’) =          ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„
    (ğ’œ âŸ•â¿ Æ’) = Æ’(â–¡,ğ’œâ‚€), ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„
    (ğ’œ âŸ–â¿ Æ’) =          ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„, Æ’(ğ’œô¨„,â–¡)
    (ğ’œ âŸ—â¿ Æ’) = Æ’(â–¡,ğ’œâ‚€), ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„, Æ’(ğ’œô¨„,â–¡)
    
    (if Æ’ is non-callable Æ’=ó°»¾ôŠ½º)
    á´¸ modifier = don't stringify result / cast result to list
    (ó·¹‡ no á´¸ mod and Æ’á¹á” â‡’ we string-sum at end)
    
    â¿ = number of seperators if ğ’œ empty.
        n=0 âŸ¶ no seperator
          1 âŸ¶ 1 seperator
          2 âŸ¶ 2 seperator
        by default, âŸ— â‡’ n=1, n=0 otherwise.  
        (ó·¹‡ sep value = Æ’(â–¡, â–¡))

â„î®¦ efficently iterates non-callable iterable â„ (returns the iterable)

Bootstrapped the grammar parser, so we can use peggle2 entirely for grammar stuff

Added áš¤ "first-unique", basically:
    â¨³ 1â‹„Â¯2â‹„23â‹„2    â†’áš¤ ó°²¡xÂ²ó°…‚ â‰¡ 1â‹„Â¯2â‹„23
    â¨³ 1â‹„ 2â‹„23â‹„Â¯2â‹„1 â†’áš¤      â‰¡ 1â‹„2â‹„23â‹„Â¯2

Added ó°Œ· "chain", basically:
    â¨³ ["abc", â›h, 1â‹„2â‹„3]  ó°Œ·       â‰¡ [â›a,â›b,â›c,â›h,1,2,3]
    â¨³             1â‹„2â‹„3 â†’ ó°Œ· "abc" â‰¡ [1,2,3,â›a,â›b,â›c]

Added â¬’ and â¬“ (Round up/down), entirely:
    â¨³ 2.2 â¬’ â‰¡ â¬’ 2.9 â‰¡ 3
    â¨³ 5.2 â¬“ â‰¡ â¬“ 5.9 â‰¡ 5

Added â‰•, finally:
    2+2 â‰• x î¬¦ x=4
    xâ‰”yâ‰”z âŸ¶ (x := (y := z))
    xâ‰”yâ‰•z âŸ¶ (z := (x := y))
    xâ‰•yâ‰•z âŸ¶ (z := (y := x))

Adddered âŠ, basically
    "abc" âŠ "123" = [[[â›a,â›1],[â›a,â›2],[â›a,â›3]],[[â›b,â›1],[â›b,â›2],[â›b,â›3]],[[â›c,â›1],[â›c,â›2],[â›c,â›3]]]
    "abc" âŠÂ²      = [[[â›a,â›a],[â›a,â›b],â€¦],   â€¦]

Added the á³á‘€á’áµá–á¸á‘…á˜á‘ˆá›s, too tired to explain rn basically lambdas cool cousins

Added á´, the mirror of á¹
    Also, á¹/á´ are `isinstance` in the binary case and `type` in the unary case
    â¨³ "egg"á¹á”
    â¨³ intá´2
    â¨³ "hi"á¹á”á´"egg"

ó°Œ· now has depth supscript modifier, basically
    â¨³ [["l","egg"],["he","we"]] ó°Œ·Â¹ â‰¡ "l"â‹„"egg"â‹„"he"â‹„"we"
    â¨³ [["l","egg"],["he","we"]] ó°Œ·Â² â‰¡ â›lâ‹„â›eâ‹„â›gâ‹„â›gâ‹„â›hâ‹„â›eâ‹„â›wâ‹„â›e

â—‹ and âˆ˜ now have â—‹â¿ âˆ˜â¿ version so basically
     (+) âˆ˜Â²    [1,2]  â‰¡ [1,2,1,2]
    ((+) â—‹Â² ğŸƒŒ)([5,2]) â‰¡ 4

Added âŠš,âŠœ,ğŸŸ•,ğŸŸ– basically
    "Æ’ âŠš    n?2": Æ’(Æ’(Æ’â€¦)) n times
    "Æ’ âŠšË¢ôŠ½¨ô‹”› ğ‘”  ": Æ’(Æ’(Æ’â€¦)) until ğ‘” true
    "Æ’ âŠœË¢ôŠ½¨ô‹”› ğ‘”?ó°»¾": Æ’(Æ’(Æ’â€¦)) until fixed point under ğ‘”
    "Æ’ ğŸŸ•Ë¢ôŠ½¨ô‹”› ğ‘”?ó°»¾": Æ’(Æ’(Æ’â€¦)) until cycle is found.
    "Æ’ ğŸŸ–Ë¢ôŠ½¨ô‹”› ğ‘”?ó°»¾": Æ’(Æ’(Æ’â€¦)) until cycle is found. Include results before cycle.
    ó·¹‡ 's' is max loop count, returns â–¡ on fail (change to err?)
    ó·¹‡ these 2nd order funcs will call Æ’ with args initally, i.e.
        â¨³ (á‘€â‹…ó·°¾á¸ âŠœ âŸ¥á‘€Â²)(100) â‰¡ 100 î¬¦ calls Æ’ 2 times

in cli mode entering just "â˜¾" makes it hot-reload the executable; useful for changing around header

Added ó·¹,ó·¹,ó·¹Œ, quintessentially
    (ó·¹,ó·¹,ó·¹Œ) áµ(0â‹„1â‹„0â‹„0â‹„1â‹„1â‹„1â‹„0â‹„1)â˜¾
        [[1], [1, 1, 1], [1]]
        [[], 0, [1], 0, [1, 1, 1], 0, [1]]
        [[], 0, [1], 0, [], 0, [1, 1, 1], 0, [1]]
    (ó·¹,ó·¹,ó·¹Œ) áµ("abcÎ±Î²Î±Î²xyz", "Î±Î²")â˜¾
        ['abc', 'xyz']
        ['abc', 'Î±Î²', 'xyz']
        ['abc', 'Î±Î²', '', 'Î±Î²', 'xyz']
    (ó·¹,ó·¹,ó·¹Œ) áµ("Î±Î²Î±Î²abcÎ±Î²Î±Î²xyzÎ±Î²Î±Î²", "Î±Î²")â˜¾
        ['abc', 'xyz']
        ['', 'Î±Î²', 'abc', 'Î±Î²', 'xyz', 'Î±Î²', '']
        ['', 'Î±Î²', '', 'Î±Î²', 'abc', 'Î±Î²', '', 'Î±Î²', 'xyz', 'Î±Î²', '', 'Î±Î²', '']
    "ó·¹": no seps
    "ó·¹": keep only single runs of sep
    "ó·¹Œ": keep all seps
    â¿ âŸ¶ number of times
    ô‹‡™ âŸ¶ force list mode when strings
    "á” ó·¹/ó·¹/ó·¹Œ á”": spl by arg 2
    "ğ’¾ ó·¹/ó·¹/ó·¹Œ Æ’": spl by Æ’
    "ğ’¾ ó·¹/ó·¹/ó·¹Œ ğ‘œ": spl with Æ’ = á‘€â‰¡ğ‘œ
    "ğ’¾ ó·¹/ó·¹/ó·¹Œ" = "ó·¹/ó·¹/ó·¹Œ ğ’¾": spl by falsy
    "ó·¹ á”" = "á” ó·¹": spl by whitespace

Added â­œ and â­, ok like basiicaily:
    not bad ternary operator
    "condition â­œ true-value â­ false-value"
    ó·¹‡ "x â­œ y" is â–¡ when Â¬x
    ó·¹‡ presidence level is between â¬…/â¡ and â†/â†’
    "xâ­œyâ­zâ­œwâ­v" = "xâ­œyâ­(zâ­œwâ­v)"
    "xâ­œyâ­œwâ­v" = "xâ­œ(yâ­œw)â­v"
    "xâ­œâ¬…yâ­œwâ­v" = "xâ­œ(yâ­œwâ­v)"

CHANGED/ADDED SYMBOLS:
    ó·º¥ó·º¤ó·º¦ó·º’
    Î© âŸ¶ ó±€˜
    î¬¦ Old version exists but deprecated for the following,
    î¬¦   they will be removed in version 1.13.like in 8 hours
    Î¶ âŸ¶ ó±‘¼
    Î£ âŸ¶ â¨
    Î  âŸ¶ â¨€

For future ref we avoid cluttering up letters/symbols used in math (except implementing their mathematical counterpart). Similar thing applies to common languages

Added âª¡, âª¢ for bitshift left/right

Made ó°¸µ, ó°¸· work better w/ strings, le essentialz iz:
    â¨³ "joe" ó°¸µô‹•©Ë£Ê¸ô‹•© 5 â‰¡ "xyxyjoe"
    â¨³ "joe" ó°¸µ     4 â‰¡ " joe"
    â¨³  [â›a] ó°¸µ     3 â‰¡ âœ—â‹„âœ—â‹„â›a
    â¨³  [â›a] ó°¸·Â¹    3 â‰¡ â›aâ‹„1â‹„1
    â¨³  "ab" ó°¸·Â³    4 â‰¡ "ab33"

Added ó°›”, string replacement for strings, ok, so basically:
    â¨³ "a" ó°›”ô‹•©áµƒáµ‡á¶œô‹•© "k"     â‰¡ "kbc"
    â¨³ ("a" ó°›” "k")("abc") â‰¡ "kbc"
    â¨³ (["hi", "h"] ó°›” ["ih", "j"])("hi") â‰¡ "ij"
    î¬¦ (last one if multiple) right arg is repeated
    â¨³ (["a","b","c"] ó°›” "hi")("ab") â‰¡ "hihi"
    â¨³ (["a","b","c","d"] ó°›” [12, "k"])("abd") â‰¡ "12kk"

ó±‘¼ has a longest mode with fill value v as ó±‘¼áµ›

added ó·¹„, contrain operator, oki so:
    â¨³ 1ó·¹„Â²4 â‰¡ 2
    â¨³ 1ó·¹„â·4 â‰¡ 4
    â¨³ 1ó·¹„ô¨‹4 â‰¡ 1
    â¨³ (1ó·¹„4)(2) â‰¡ 2
    â¨³ â›aó·¹„ô‹‚Â²â›z â‰¡ â›a

added â©” and â©“, basically as useful as an implementation detail but quandasically:
    literally âˆ¨ and âˆ§ but doesn't short circuit
    i now have a todo item of ó·º¥ but no short circuit bruH

oh also ó·º¥ now short circuits
oh and nOW i had to do ó·º’

â€¦stupid idiot Û©â©”ó·º«â©“ó·º¬Û©

Added ğŒ‚, beesbeesentially:
    ó°¤±

if ó°ˆ²/ó°ˆ³/î®†/ó°’¼/ó°’½/ó°¤± has w/ non-Æ’ RHS then it checks for equality

idk how i didnt think of this but like if you're mapping and your function returns ó°®ˆ then its removed from the map

got rid of the `colored` dependency yay

REMOVED: ó°‘ ó°‘ƒ
ADDED: ó·¹“ ó·¹” ó·¹• ó·¹–

slightly less stupid caching

NOTE ON CURRENT DEPRECATED:
    â€¦ Î¶ Î£ Î 
    Sorta deprecated (once off python these may be removed, havent decided)
        ** * / // << >> >= <= !=
        Other python specific stuff but we'll get there when we get there

Added âˆ¾, evajvuahuehae reverses function args.

We can now use á¹ with ğ—™,ğ—œ,ğ—›

Removed Î¶/Î£/Î 

added ï’¼, threadman, biahiuofafu
    superscript is number of threads, default is system cpu count
    otherwise normal map

ó·º—: empty style but works inside strings
ó°¤± docs
ó°¤± docs/tests for âª¢âª¡ó·¹… new window features
ó°¤± docs/test for the â—‹âœó°¬©ó°¬« stuffs
ó·¹: ó°¤± docs (mention á´¸ mod)
ó·¹œ: ó°¤± docs
âˆ…: ó°¤± docs
â: ó°¤± docs