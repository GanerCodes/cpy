"x â«°" = "â«° x" =  abs(x)
"x â«¯" = "â«¯ x" = Â¯abs(x)

fold now has init modifier
    [3]Å¿Â¹+
    â¯ˆ 4

á´: now handles strings well
á´â¿: n layered map
    [1â‹„2,3â‹„4] á´Â² âˆš
    â¯ˆ [[1.0, 1.4142135623730951], [1.7320508075688772, 2.0]]
á´â»â¿: layers above any atom
    confusing so like:
        ["some", ["cool", [[["strings"]]]]] á´â»Â² á´™
        â¯ˆ ['emos', ['looc', [[['sgnirts']]]]]
        ["some", ["cool", [[["h"]]]]] á´â»Â¹ á”.upper
        â¯ˆ [['S', 'O', 'M', 'E'], [['C', 'O', 'O', 'L'], [[[['H']]]]]]
        î¬¦ i think á´â»Â¹ is the same as á´ó°‚ƒ...?
á´ó°‚ƒ: also a thing
êŸ¿â¿: starmap works the same way
  
Where 'â¨' â«¢ operator
  â¨ó°€‚á´¬á´¾ó°€™    âŸ¶ â¨["ó°€‚á´¬á´¾ó°€™"]
  â¨áµƒ       âŸ¶ â¨[a]
  â¨Â¹âºÂ¹     âŸ¶ â¨[1+1]
  â¨Â¹âºÂ¹ğ‘á´¶ğ‘Ë£ âŸ¶ â¨[1+1,"J",x]

Keybinded â¥‰, ğ‘
Changed binds for âŸ¥âŸ¤

"egg"â¬„"g"
â¯ˆ "e"
needs more work to be more general

made âŸ¥ and âŸ¤ work... maybe? i think?

tracebacks show the python code now, terrible monkey things had to be done to do it

added â‰º, basically
    1â‹„2â‰º+
    â¯ˆ 3

* Added hex, binary, and octal parsing
* Random fixes, one tricky peggle bug
* Added some more test cases
We still have the bugs with op swapping and stuff not chaning pres orders

* Added some normalization to some paths
* Trim the caller program from argv

added î®¦
    it just calls a function
    "f î®¦" is "f()"

fixed hex lol

Added basic cli mode, tldr "â˜¾" with no args opens it.
refresher is "â˜¾ --refresher"

added install script [linux only rn]

fixed bug with tracebacks
(Need to fix cli mode not showing errors)

á´ and êŸ¿ support á´° á´· â±½ for mapping dicts, dict keys, and dict values

added ğ‘¡ for tuples b/c it was missing for some reason

print flush by default (idk if this changes anything but it don't hurt)

added bindings (and fixed a bug) for special string chars i.e. ğ—»

added â­, basically (use special char highlighting PLS):
    â€¹aâ€‰bâ€ºâ­ = ['a', 'b']
    â€¹kâ€‰jâŸaâ€‰bâ€ºâ­ = [['k','j'], ['a','b']]

added ğ”¦ğ”ªğ”­(â›s), imports some misc sys related things for ease of use

Working on massive overhaul for compose/font stuff!

AAAAAAAAAAAAAa
ehehehhehe

â´³, â´´ now have a self-returning call method

we now have
    â¨³ ó°»¾(22) â‰¡ 22
    â¨³ ó°»¾Â¹â´("hiii") â‰¡ 14

Ïœ: accumulate
â„µáµ’áµ–áµ—â±áµ’â¿áµƒË¡ô‹•Ÿáµˆáµ‰á¶ áµƒáµ˜Ë¡áµ—: attr dict (iter does .items)
â„¶áµ’áµ–áµ—â±áµ’â¿áµƒË¡ô‹•Ÿáµˆáµ‰á¶ áµƒáµ˜Ë¡áµ—: attr dict (iter does .values)
ó°‘…, ó°‘…á´µ: first, first index of
ó°‘, ó°‘ƒ : before, after
Æ’ ï (a1,a2,â¬¤,j=22,h=â¬¤): partial function
ï€…Æ’: automatically star a function's args
(also ï€…ôŠ½º, which is cool for stuff like â‰¡)

á™á™¡á—¢á™§: windowz
á£†: apply func if...
$áµ’echoâ€‰epic subprocess callsó·¹¹

oh also everything has sub/sup/subsub/subsup/supsub/supsup scripts
oh also font remaking thingy finished check out CONFIGURE.â˜¾ in FontCompose

ok superscripts should now act like exponents when the parsed thing isn't an identifier
â¨³ 2Â² â‰¡ 4 î¬¦ ğŸ˜Š

Added gambling ğŸ˜ŠğŸ˜ŠğŸ˜Š
     î‰°/ó±…/ï´ á´º : list of N of the random thing
      î‰°/ó±…   = uniform(Â¯1, 1)/uniform(0, 1)
      î‰°/ó±… n = uniform/randint(0, n)
      î‰°/ó±… ğ’¾ = uniform/randint(ğ‘–â‚€, ğ‘–â‚)
    x î‰°/ó±… y = uniform/randint(nâ‚€, nâ‚)
    ğ’¾  ï´    = shuffle
    ğ’¾  ï´  n = n choices

New errorz
    (ğ¸ ï±  )         raise ğ¸
    (Æ’ ï± ğ‘¥)(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ‘¥
    (Æ’ ó°”¶  )(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ”¸â‚€ or â–¡
    (Æ’ ó°”¶ ğ”¤)(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ”¤(â ¤ğ”¸, â ¶ğ•‚)
    (Æ’ î©¬  )(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªÎµ
    (Æ’ î©¬ ğ”¤)(â ¤ğ”¸, â ¶ğ•‚) try â†ªÆ’(â ¤ğ”¸, â ¶ğ•‚), catch Îµ=(supscript? / any), â†ªğ”¤(Îµ)

aâˆ£b: âœ“/âœ— if a divides b
aâˆ¤b: take a guess

â„‡ is now euler's constant

exponents are now fun 5ôŠ½² = âˆš5
    [ó·¹‡ uses hard-coded list of single char identifiers]

fixed nested â‰” and <op>= calls

Filterz
    (ó·¹‡ ó°ˆ³ is like ó°ˆ² except the checking function is inverted)
    "x ó°ˆ²  Æ’" = [yâˆ€yâˆˆxÂ¿Æ’(y)]
    "x ó°ˆ²ô‹‡” Æ’" = [ğ‘“(y)Â¿Æ’(y)Â¡y âˆ€yâˆˆx]
    "x ó°ˆ²î  Æ’" = x ó°ˆ²ôŠ½º Æ’
    "x ó°ˆ² " = "ó°ˆ²  x" = x ó°ˆ² ó°»¾
    "x ó°ˆ²ô‹‡”" = "ó°ˆ²ô‹‡” x" = (xá´ğ‘“) ó°ˆ²

Better rangessss
    ğ‘, ğ‘, n â«¢ int
    ğ’œ, â„¬ â«¢ iterable
    n=0 by default
        "ğ’œ ó·¸¹â¿  " = ğ’œâ‚€â‚Šâ‚™
        "ğ’œ ó·¸ºâ¿  " = ğ’œô¨„â‚‹â‚™
        "ğ’œ ó·¸»â¿  " = ğ’œâ‚€â‚Šâ‚™, ğ’œô¨„â‚‹â‚™
    n=1 by default
        "ğ’œ ó·¸»â¿ â„¬" = [ğ’œâ‚“ âˆ€ xâˆˆâ„¬ï¹•ï¹•â‚™]
        "ğ’œ ó·¸¸â¿  " = (ğ’œâ‚€, ğ’œâ‚ï¹•ô¨„ï¹•â‚™, ğ’œô¨„)
        ğ‘=1 default, ğ‘=ó·°¾ default
            "ğ’œ ó·¸¹â¿ ğ‘" = ğ’œ   ï¹•ôŠ´  ï¹•â‚™
            "ğ’œ ó·¸ºâ¿ ğ‘" = ğ’œ  â‚ï¹•ôŠ´â‚Šâ‚ï¹•â‚™
            "ğ’œ ó·¸¸â¿ ğ‘" = ğ’œ  â‚ï¹•ôŠ´  ï¹•â‚™
            "ğ’œ ó·¸»â¿ ğ‘" = ğ’œ   ï¹•ôŠ´â‚Šâ‚ï¹•â‚™
            "ğ‘ ó·¸¹â¿ ğ’œ" = ğ’œôŠ´  ï¹•  ô¨„ï¹•â‚™
            "ğ‘ ó·¸ºâ¿ ğ’œ" = ğ’œôŠ´â‚Šâ‚ï¹•   ï¹•â‚™
            "ğ‘ ó·¸¸â¿ ğ’œ" = ğ’œôŠ´â‚Šâ‚ï¹•  ô¨„ï¹•â‚™
            "ğ‘ ó·¸»â¿ ğ’œ" = ğ’œôŠ´  ï¹•   ï¹•â‚™
        ğ‘=0 default
            "ğ‘ ó·¸¹â¿ ğ‘" = [â ¤range(ğ‘  ,ğ‘  ,n)]
            "ğ‘ ó·¸ºâ¿ ğ‘" = [â ¤range(ğ‘+1,ğ‘+1,n)]
            "ğ‘ ó·¸¸â¿ ğ‘" = [â ¤range(ğ‘+1,ğ‘  ,n)]
            "ğ‘ ó·¸»â¿ ğ‘" = [â ¤range(ğ‘  ,ğ‘+1,n)]

i have gone off the deep end we now have
    ó·±…ó·°¾ = Â¯81
    ó·°½ó·±ó·±’ó·±“ó·±ó·±’ó·±ó·±“ó·±“ó·±” = Â¯0xDEADBEEF

attempted to add some implicit multiplication. Most stuff with a a literal number works well, var_spec's work decently (but might be weird in the future), and we don't support strings/regular variables.
    Â½ó·°½ó·±ó·±’ó·±“ó·±ó·±’ó·±ó·±“ó·±“ó·±”ó·ºÂ²ó·±€Ã®Â³ = -13827051355.523182j
    
    (ó·¹‡ implicit mul uses the "â€CAT" order of operations)

added joinz
    "â¨ ğ’œ" = "â¨ ğ’œ" =   á¦.join(ğ’œá´á”)
    "âŸ• ğ’œ" = "âŸ• ğ’œ" = ğ—»+á¦.join(ğ’œá´á”)
    "âŸ– ğ’œ" = "âŸ– ğ’œ" =   á¦.join(ğ’œá´á”)+ğ—»
    "âŸ— ğ’œ" = "âŸ— ğ’œ" = ğ—»+á¦.join(ğ’œá´á”)+ğ—»
    
    (ğ’œ â¨â¿ Æ’) =          ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„
    (ğ’œ âŸ•â¿ Æ’) = Æ’(â–¡,ğ’œâ‚€), ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„
    (ğ’œ âŸ–â¿ Æ’) =          ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„, Æ’(ğ’œô¨„,â–¡)
    (ğ’œ âŸ—â¿ Æ’) = Æ’(â–¡,ğ’œâ‚€), ğ’œâ‚€, Æ’(ğ’œâ‚€,ğ’œâ‚), ğ’œâ‚, Æ’(ğ’œâ‚,ğ’œâ‚‚), â€¦, ğ’œô¨„, Æ’(ğ’œô¨„,â–¡)
    
    (if Æ’ is non-callable Æ’=ó°»¾ôŠ½º)
    á´¸ modifier = don't stringify result / cast result to list
    (ó·¹‡ no á´¸ mod and Æ’á¹á” â‡’ we string-sum at end)
    
    â¿ = number of seperators if ğ’œ empty.
        n=0 âŸ¶ no seperator
          1 âŸ¶ 1 seperator
          2 âŸ¶ 2 seperator
        by default, âŸ— â‡’ n=1, n=0 otherwise.  
        (ó·¹‡ sep value = Æ’(â–¡, â–¡))

â„î®¦ efficently iterates non-callable iterable â„ (returns the iterable)

Bootstrapped the grammar parser, so we can use peggle2 entirely for grammar stuff

Added áš¤ "first-unique", basically:
    â¨³ 1â‹„Â¯2â‹„23â‹„2    â†’áš¤ ó°²¡xÂ²ó°…‚ â‰¡ 1â‹„Â¯2â‹„23
    â¨³ 1â‹„ 2â‹„23â‹„Â¯2â‹„1 â†’áš¤      â‰¡ 1â‹„2â‹„23â‹„Â¯2

Added ó°Œ· "chain", basically:
    â¨³ ["abc", â›h, 1â‹„2â‹„3]  ó°Œ·       â‰¡ [â›a,â›b,â›c,â›h,1,2,3]
    â¨³             1â‹„2â‹„3 â†’ ó°Œ· "abc" â‰¡ [1,2,3,â›a,â›b,â›c]

Added â¬’ and â¬“ (Round up/down), entirely:
    â¨³ 2.2 â¬’ â‰¡ â¬’ 2.9 â‰¡ 3
    â¨³ 5.2 â¬“ â‰¡ â¬“ 5.9 â‰¡ 5

Added â‰•, finally:
    2+2 â‰• x î¬¦ x=4
    xâ‰”yâ‰”z âŸ¶ (x := (y := z))
    xâ‰”yâ‰•z âŸ¶ (z := (x := y))
    xâ‰•yâ‰•z âŸ¶ (z := (y := x))

Adddered âŠ, basically
    "abc" âŠ "123" = [[[â›a,â›1],[â›a,â›2],[â›a,â›3]],[[â›b,â›1],[â›b,â›2],[â›b,â›3]],[[â›c,â›1],[â›c,â›2],[â›c,â›3]]]
    "abc" âŠÂ²      = [[[â›a,â›a],[â›a,â›b],â€¦],   â€¦]

Added the á³á‘€á’áµá–á¸á‘…á˜á‘ˆá›s, too tired to explain rn basically lambdas cool cousins