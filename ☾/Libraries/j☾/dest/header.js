/* AUTOGENERATED, DO NOT EDIT */ const  ASCII_CHARS_STANDARD  =  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ; 

 const  ğ‘œ  =  Object ; 
 const  ğ‘™  =  (A) => [ ... A] ; 
 const   Ã¾1F0CC   =  (l) => l . length ; 
 const   Ã¾F0EFE   =  (x) => x
 const  ğ’®  =  (d , k , v) => ( ! (k in d)  ||  d[k] === null)  ? (d[k] = v) :  d[k] ; 
 const  [ğ’ª ,  ğ’Ÿ ,  ğ’ªk ,  ğ’ªv]  =  [ğ‘œ . entries ,  ğ‘œ . fromEntries ,  ğ‘œ . keys ,  ğ‘œ . values] ; 
 const  á´   =  (l , ğ‘“) => ğ‘™(l) . map(ğ‘“) ; 
 const  á´v  =  (d , ğ‘“) => ğ’Ÿ(ğ’ª(d) . map(([k , v]) => [k , ğ‘“(v)])) ; 
 const  á´k  =  (d , ğ‘“) => ğ’Ÿ(ğ’ª(d) . map(([k , v]) => [ğ‘“(k) , v])) ; 
 const   Ã¾F147C    =  (ğ‘¥ , ğ‘¦) => ğ‘™(ğ‘¥) . map((k , i) => [k ,  ğ‘¦[i]]) ; 

 const  int  =  Math . floor ; 
 const   Ã¾022C0   =  (A) => A . every( Ã¾F0EFE ) ; 
 const  ends  =  (l) => l . map((ğ‘¥ , i) => [i == 0 , ğ‘¥ , i ==  Ã¾1F0CC (l) - 1]) ; 
 const  sort  =  (A , f , r = ğ”½) =>  A . sort((a , b) => (r  ? 1 :  -1) * (b > a  ? 1 :  -1))  //  what ? 
 const  range  =  (a , b) => [ ... Array(b - a) . keys()] . map((i) => i + a) ; 
 const  merge  =  (  ... o) => ğ‘œ . assign({} ,   ... o)
 const   print             =  ( ... x) => console . log  ( ... x)  ||  x[0]
 const  print_table  =  ( ... x) => console . table( ... x)  ||  x[0]
 const  sleep  =  (s) => new Promise((r) => setTimeout(r ,  1000 * s)) ; 
 const  strfmt  =  (s , ğ”¸) => {
     for ( const [k , v]  of  ğ’ª(ğ”¸)) s  =  s . replace( new RegExp("\\{"  +  k  +  "\\}" ,  "gi") ,  v) ; 
     return  s ;  } ; 
 const  mk_id  =  (l ,  chars = ASCII_CHARS_STANDARD) =>  
    range(0 ,  l)
         . map(() => chars . charAt(int(Math . random() * chars . l)))
         . reduce((a , b) => a + b ,   "" ) ; 
 const  groups  =  (l , ğ‘“) => {
    O  =  {} ; 
    l . forEach((ğ‘¥) => ğ’®(O ,  ğ‘“(ğ‘¥) ,  []) . push(ğ‘¥))
     return  O ;  }

objIdMap =  new WeakMap ,  objectCount = 0 ; 
 const  id  =  (obj) => {
     ! objIdMap . has(obj)  &&  objIdMap . set(obj ,   ++ objCount) ; 
     objIdMap . get(obj) ;  }
    
 const  GID  =  (id) => document . getElementById(id) ; 
 const  VAL  =  (id) => GID(id) . value ; 
 const  SAT  =  (Îµ , a , v) => Îµ . setAttribute(a ,  v) ; 
 const  QSA  =  (sel , e = document) => ğ‘™(e . querySelectorAll(sel)) ; 

 const  setLocal  =  (k , v) => localStorage[k]  =  JSON . stringify(v) ; 
 const  getLocal  =  (k  ) => JSON . parse(localStorage[k]) ; 

 const  Îµ_clone  =  (Îµ) => {
     if ( ! (Îµ instanceof Node))  return  Îµ ; 
     if (Îµ . tagName  ==  'F')  return  Îµ . ğ‘“() ; 
     const  É™  =  Îµ . cloneNode(false) ; 
     if ('ğ•¤' in Îµ) É™ . ğ•¤  =  Îµ . ğ•¤ ; 
     if (Îµ instanceof HTMLElement)
        É™ . append( ... á´(Îµ . childNodes ,  Îµ_clone)) ; 
     return  É™ ;  }

 const  ğ¶  =  (d) => {
     const  cache_specials  =  (ğ•Š) => {
         const  psu  =  ğ•Š . e . parentElement  ??  mkÉ™(false , false , [(ğ•Š . e)]) ; 
         for ( const  c  of  psu . querySelectorAll("[T]")) {
             if ('ğ•¤'  in  c) continue ; 
            ğ•Š[ğ•Š . ğ´[id(c)]  =  c . getAttribute('T')]  =  c ; 
            c . removeAttribute('T') ;  }
         for ( let  c  of  psu . querySelectorAll('*')) {
             if ('ğ•¤'  in  c) {
                 if ( ! ('ğ‘ƒ'  in  c . ğ•¤)) c . ğ•¤ . ğ‘ƒ  =  ğ•Š ; 
                continue ;  }
            c . ğ•¤  =  ğ•Š ;  } }
     const  ğ‘“  =  ( ... par) => {
         const  ğ•Š  =  merge(d ,   ... par) ; 
        á´(ğ’ª(ğ•Š) ,  ([k , Îµ]) => (Îµ instanceof Node) && (ğ•Š[k]  =  Îµ_clone(Îµ))) ; 
        ğ•Š . ğ´  =  {} ; 
        ğ•Š . ğ¿  =  (ğ•Š , ğ‘¥) => {
             let  k  =  ğ•Š ; 
            while(k  &&   ! (ğ‘¥  in  k)) k  =  k . ğ‘ƒ ; 
             return  k[ğ‘¥] ;  } ; 
        (ğ•Š . ğ‘…  =  cache_specials . bind(null ,  ğ•Š))() ; 
         for ( const  [k ,  v]  of  ğ’ª(ğ•Š))
             if (v instanceof Function)
                ğ•Š[k]  =  v . bind(null ,  v . isğ¶  ? {ğ‘ƒ :  ğ•Š} :  ğ•Š)
        ğ•Š . init() ; 
         return  ğ•Š . e ;  }
    ğ‘“ . isğ¶  =   true  ; 
     return  ğ‘“ ;  } ; 

 //  `ó±€âœ¨ó±€âœ¨ó±€ topaz notation ó±€âœ¨ó±€âœ¨ó±€`
mkÉ™  =  (name ,  attrs ,  kids) => {
     const  remaps  =  { ğ‘† : "style" , ğ¼ : "id" , ğ¶ : "class" } ; 
     if (name ===  false ) name  =  "div" ; 
     let  É™  =  document . createElement(name) ; 
     if (attrs)  for ( let  [k , v]  of  ğ’ª(attrs)) É™[remaps[k] ?? k]  =  v ; 
     if (typeof kids  ===  "string") É™ . innerText  =  kids ; 
     else if (kids instanceof Array ) kids . forEach((ğš) => {
         if (typeof ğš  ===  "string") ğš  =  document . createTextNode(ğš) ; 
        É™ . appendChild(ğš) ; 
    }) ; 
     //  Ã¾F0931 htmlelements / function type / general objects / etc
     return  É™ ;  } ; 